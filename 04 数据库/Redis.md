# 一、前言

## 1.1 数据存储发展历程


> **单机MySQL时代**

APP -> DAL(Data Access Layer) -> MySQL

这种模式下的瓶颈：
- 数据量太大，一个机器存放不下
- 数据的索引太大，一个机器的内存放不下
- 访问量（读写混合）太大，一个服务器承受不住 

> **缓存MemCache + 读写分离**

网站上80%的情况都是在读，每次都去查询数据库，效率很低。

此时可以引入缓存机制，第一次查询去MySQL中读取数据，数据返回给用户时，在缓存中也存储下来。第二次访问，就可以直接从缓存中读取


> **分库分表 + 水平拆分(MySQL集群)**

随着社会的发展，要存储数据的类型（音乐，视频，地理位置，人际交往圈、用户自己产生的数据，用户日志等）也越来越繁多，数据量也爆发式增长。这样MySQL等关系型数据库就越来越不够用了！NoSQL数据库就开始进入人们的视野！NoSQL数据库可以很好的解决这些问题。


## 1.2 NOSQL简介

NoSQL（Not Only SQL） 泛指非关系型数据库

> **NoSQL特点**

- 方便扩展（数据之间没有关系）
- 大数据量高性能（Redis写8w/s, 读11w/s，NoSQL的缓存记录级是一种细粒度的，性能会更高）
- 数据类型多样：不需要事先设计数据库，随取随用
- **存储方式多样**：键值对，列存储，文档存储，图形数据库
- 没有固定的查询语言

> **NoSQL的四大分类**

- **Key-Value 键值对:** 新浪 Redis、美团 Redis+Tair 、阿里与百度 Redis+Memcached 
- **文档型数据库 bson格式：** MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档；MongoDB是一个介于关系型数据库和非关系型数据库的中间产品。MongoDB是非关系型数据库。
- **列存储数据库：** HBase、分布式文件系统 GFS
- **图关系数据库：** 不是用于存储图片，而是用来存储关系，比如：朋友圈社交网络、广告推荐！Neo4j，infoGrid

**四种分类对比**

|   分类    |   Example |   典型应用场景    |   数据模型    |   优点    |   缺点    |
|   ----    |   ---- |   ----    |   ----    |   ----    |   ----   |
|   Key-Value 键值对    |   Tokyo Cabinet/Tyrant、redis、Voldemort、Oracle DBD |   ==内容缓存==，主要用于处理大量数据的高访问负载，也用于一些日志系统    |   Key-Value键值对，通常利用Hash-table实现    |   查找速度快    |   数据无结构化、通常只被当做字符串或二进制数据  | 
|   列存储数据库    |   Cassandra、Hbase、Riak |   ==分布式文件系统==    |   以列簇式存储，将同一列数据存储在一起    |   查找速度快、可扩展性强，更容易进行分布式扩展    |   功能相对局限  |
|   文档型数据库     |   CouchDB、MongoDB |   ==web应用==（与Key-Value相似，value是结构化的，不同的是数据库能够了解value的内容）    |   Key-Value对应的键值对，Value为结构化数据    |   数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构    |   查询性能不高，而且缺乏统一的查询语法  |  
|   图关系数据库     |   Neo4j、InfoGrid、Infinite Graph |   社交网络，推荐系统。专注于构建==关系图谱==    |   图结构    |   利用图结构相关算法，如最短路径寻址，N度关系查找等    |   很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式方案  |  

# 二、 Redis 简介

## 2.1 Redis简介

- Redis是一种开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。
- Redis提供数据结构，例如**字符串**，**哈希，列表，集合，带范围查询的排序集合，位图，超日志，地理空间索引和流**。
- Redis具有内置的复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过`Redis Sentinel哨兵`和`Redis Cluster`自动分区提供了高可用性。

> **Redis、Memcached、MySQL和PostgreSQL比较**

> **Redis为什么单线程还这么快？**

Redis是C语言实现的，基于内存操作，CPU不是Redis的性能瓶颈，Redis的瓶颈就是根
据机器的内存和网络带宽。

Redis官方数据：读：110000/s 写： 80000/s

**核心：** Redis是将所有的数据全部放在内存中的，此时使用单线程操作效率就是最高的，相比多线程，减少了CPU上下文切换的耗时。
- **纯内存操作** ，避免大量访问数据库，减少直接读取磁盘数据，redis将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度快；
- **单线程操作**，避免了**不必要的上下文切换和竞争条件**，不用去考虑各种**锁的问题**，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
- 采用了非阻塞I/O多路复用机制

**注意：** Redis读写是单线程的，但Redis server是多线程，因为redis它还要做其他事情

## 2.2 Redis基本命令

Redis 默认有16个数据库，默认使用的是第0个数据库，可以通过select切换数据库 **(Redis的命令同SQL语句一样对大小写不敏感）**

> **数据库相关命令**

```shell
# 启动客户端
redis-cli

# 启动客户端，-p 指定端口号
redis-cli -p 6379

# 切换数据库
select 3

# 查看当前数据库中键keys的个数是(元素个数)
dbsize

# 清空当前数据库
flushdb

# 清空所有数据库
flushall

```

> **Redis键值对，键key相关命令**
```shell
# 查看当前数据库所有key
keys *

# 设置key
set stu wang

# 查看key的值
get stu

# 设置key的国企时间
expire stu 10

# 查看key的过期时间
ttl stu

# 判断key是否存在
exists stu

# 删除key
del stu

# 查看key对应的value的类型
type stu
```

> **帮助命令**

```bash
help

help 命令  # help set

help @类型  # help @string
```

****

# 三、Redis数据类型


# 四、Redis数据结构

## 4.1 前言

> **Redis为什么这么快?**

- 内存数据
- 实现的数据库，使得我们对数据进行增删改查操作时，Redis能高效处理

> **注意**

Redis数据结构是指**数据的保存形式**，是指Redis键值对中`value`的数据类型在底层实现的方式。

> **Redis对象和底层数据结构的对应关系**

Redis **数据类型的底层数据结构随着版本的更新也有所不同**,如:
- 在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的；
- 在最新的 Redis 代码（还未发布正式版本）中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。

![Redis对象和底层数据结构的对应关系图](https://camo.githubusercontent.com/e27c316103db0dd0b585b0bc569efc263bd0736dc55feb01828abafe0f84807a/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f39666132366137343936356566626630663536623730376130336262396237662e706e67)


本文对Redis新旧版本的数据结构进行讲解：共有 9 种数据结构：SDS、双向链表、压缩列表、哈希表、跳表、整数集合、quicklist、listpack。
![Redis数据结构](https://camo.githubusercontent.com/5d4451175e10f2befdea0ccdb31f45d41abc3830224f925b83b5b3b11b2dc7dd/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f61396333653764633461633739333633643865623865623232393061353865362e706e67)

## 4.2 键值对数据库的实现

Redis键值对中:
- Key：字符串对象
- Value：可以是字符串对象，也可以是集合数据类型的对象，如List对象、Hash对象、Set对象和Zset对象

> **几种 Redis 新增键值对的命令**

```bash
# name:字符串键，因为键的对象是一个字符串对象
> SET name "xiaolincoding"
ok

# person：哈希表键，因为键值时一个包含两个键值对的哈希表对象
> HSET person name "xiaolincoding" age 18
0

# stu：列表键，因为键值是一个包含两个元素的列表对象
> RPUSH stu "xiaolin" "xiaomei"
(integer) 4
```

> **键值对如何保存在Redis**

Redis使用一个**哈希表**保存所有键值对，哈希表的最大好处是可以用${O(1)}$的时间复杂度来快速查找到键值对。

哈希表其实就是一个数组，数组的中的元素叫**哈希桶**

> **Redis的哈希桶是如何保存键值对**

哈希桶存放的是指向键值对数据的指针（dictEntry*），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void * key 和 void * value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。

我这里画了一张 Redis 保存键值对所涉及到的数据结构。

![Redis保存键值对涉及到的数据结构](https://img-blog.csdnimg.cn/img_convert/f302fce6c92c0682024f47bf7579b44c.png)

图中涉及到的数据结构的名字和用途：

- **redisDb 结构：** 表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；
- **dict 结构：** 结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；
- **ditctht 结构：** 表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；
- **dictEntry 结构：** 表示哈希表节点的结构，结构里存放了 **void * key 和 void * value 指针， *key 指向的是 String 对象，而 *value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象**。

特别说明下，void * key 和 void * value 指针指向的是 **Redis 对象**，Redis 中的每个**对象都由 redisObject 结构**表示，如下图：

![](https://img-blog.csdnimg.cn/img_convert/58d3987af2af868dca965193fb27c464.png)

对象结构里包含的成员变量：

- type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；
- encoding，标识该对象使用了哪种底层的数据结构；
- **ptr，指向底层数据结构的指针**。

我画了一张**Redis 键值对数据库的全景图**，你就能清晰知道 Redis 对象和数据结构的关系了：

![Redis 键值对数据库的全景图](https://img-blog.csdnimg.cn/img_convert/3c386666e4e7638a07b230ba14b400fe.png)

## 4.3 SDS(简单动态字符串,simple dynamic string）

字符串在 Redis 中是很常用的，键值对中的键是字符串类型，值有时也是字符串类型。

Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 **Redis 的 String 数据类型的底层数据结构是 SDS。**

既然 Redis 设计了 SDS 结构来表示字符串，肯定是 C 语言的 char* 字符数组存在一些缺陷。

要了解这一点，得先来看看 char* 字符数组的结构。

### 4.3.1 C 语言字符串的缺陷

> **char\* 字符数组的结构**

C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。

比如，下图就是字符串“xiaolin”的 char* 字符数组的结构：

![char* 字符数组结构](https://img-blog.csdnimg.cn/img_convert/376128646c75a893ad47914858fa2131.png)

在 C 语言里，对字符串操作时，char * 指针只是指向字符数组的起始位置，而**字符数组的结尾位置就用“\0”表示，意思是指字符串的结束**。

因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 “\0” 来决定要不要停止操作，如果当前字符不是 “\0” ，说明字符串还没结束，可以继续操作，如果当前字符是 “\0”  是则说明字符串结束了，就要停止操作。

> **C 语言字符串的缺陷**

举个例子，C 语言获取字符串长度的函数 `strlen`，就是通过字符数组中的每一个字符，并进行计数，等遇到字符为 “\0” 后，就会停止遍历，然后返回已经统计到的字符个数，即为字符串长度。下图显示了 strlen 函数的执行流程：

![](https://img-blog.csdnimg.cn/img_convert/bcf6bde3b647bdc343efcbc1a8f10579.png)


很明显，**C 语言获取字符串长度的时间复杂度是 O（N）（*这是一个可以改进的地方***）

C 语言字符串用 “\0” 字符作为结尾标记有个缺陷。假设有个字符串中有个 “\0” 字符，这时在操作这个字符串时就会**提早结束**，比如 “xiao\0lin” 字符串，计算字符串长度的时候则会是 4，如下图：                                                                               

![](https://img-blog.csdnimg.cn/img_convert/6286480eb1840a8930e18fd215d82565.png)


因此，除了字符串的末尾之外，**字符串里面不能含有 “\0” 字符**，否则最先被程序读入的 “\0” 字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存文本数据，**不能保存像图片、音频、视频文化这样的二进制数据（*这也是一个可以改进的地方*）**

另外， C 语言标准库中字符串的操作函数是很不安全的，对程序员很不友好，稍微一不注意，就会导致缓冲区溢出。

 举个例子，strcat 函数是可以将两个字符串拼接在一起。

 ```c
 //将 src 字符串拼接到 dest 字符串后面
 char *strcat(char *dest, const char* src);
 ```

**C 语言的字符串是不会记录自身的缓冲区大小的**，所以 strcat 函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而**一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，（*这是一个可以改进的地方***）。


而且，strcat 函数和 strlen 函数类似，时间复杂度也很高，也都需要先通过遍历字符串才能得到目标字符串的末尾。然后对于 strcat 函数来说，还要再遍历源字符串才能完成追加，**对字符串的操作效率不高**。

好了， 通过以上的分析，我们可以得知**C 语言的字符串不足之处以及可以改进的地方：**

- 获取字符串长度的时间复杂度为  O（N）；
- 字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；
- 字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；


Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。

### 4.3.2 SDS 结构设计

#### SDS数据结构

下图就是 Redis 5.0 的 SDS 的数据结构：

![](https://img-blog.csdnimg.cn/img_convert/516738c4058cdf9109e40a7812ef4239.png)

结构中的每个成员变量分别介绍下：

- **len，记录了字符串长度**。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。
- **alloc，分配给字符数组的空间长度**。这样在修改字符串的时候，可以通过 `alloc - len` 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS  的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。
- **flags，用来表示不同类型的 SDS**。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。
- **buf[]，字符数组，用来保存实际数据**。不仅可以保存字符串，也可以保存二进制数据。

总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。

#### SDS解决C语言字符串缺陷

> **O（1）复杂度获取字符串长度**

C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。

而 Redis 的 SDS 结构因为加入了 len 成员变量，那么**获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）**。

> **二进制安全**

因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是**有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据**。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\0” 字符。

因此， SDS 的 API 都是以处理二进制的方式来处理 SDS 存放在 buf[] 里的数据，程序不会对其中的数据做任何限制，数据写入的时候时什么样的，它被读取时就是什么样的。

通过使用二进制安全的 SDS，而不是 C 字符串，使得 **Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。**

> **不会发生缓冲区溢出**

C 语言的字符串标准库提供的字符串操作函数，大多数（比如 strcat 追加字符串函数）都是不安全的，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够用，当发生了缓冲区溢出就有可能造成程序异常结束。

Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 `alloc - len` 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。

而且，**当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容）**，以满足修改所需的大小。

在扩展 SDS 空间之前，SDS API 会优先检查未使用空间是否足够，如果不够的话，API 不仅会为 SDS 分配修改所必须要的空间，还会给 SDS 分配额外的「未使用空间」。

这样的好处是，下次在操作 SDS 时，如果 SDS 空间够的话，API 就会直接使用「未使用空间」，而无须执行内存分配，**有效的减少内存分配次数**。

所以，使用 SDS 即不需要手动修改 SDS 的空间大小，也不会出现缓冲区溢出的问题。

> **节省内存空间**

**1. 设计不同的结构体**

SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。

Redis 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。

这 5 种类型的主要**区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同**。

比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下：

```c
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len;
    uint16_t alloc; 
    unsigned char flags; 
    char buf[];
};


struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len;
    uint32_t alloc; 
    unsigned char flags;
    char buf[];
};
```

可以看到：

- sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。
- sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。

**之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间**。比如，在保存小字符串时，结构头占用空间也比较少。

**2. 使用编译优化实现节省内存空间**

除了设计不同类型的结构体，Redis 在编程上还**使用了专门的编译优化来节省内存空间**，即在 struct 声明了 `__attribute__ ((packed))` ，它的作用是：**告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐**。

比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 16 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 16 个字节，编译器也会给它分配 16 个字节。

举个例子，假设下面这个结构体，它有两个成员变量，类型分别是 char 和 int，如下所示：

```c
#include <stdio.h>

 struct test1 {
    char a;
    int b;
 } test1;
 
int main() {
     printf("%lu\n", sizeof(test1));
     return 0;
}
```


大家猜猜这个结构体大小是多少？我先直接说答案，这个结构体大小计算出来是 8。

![](https://img-blog.csdnimg.cn/img_convert/35820959e8cf4376391c427ed7f81495.png)

这是因为默认情况下，编译器是使用「字节对齐」的方式分配内存，虽然 char 类型只占一个字节，但是由于成员变量里有 int 类型，它占用了 4 个字节，所以在成员变量为 char 类型分配内存时，会分配 4 个字节，其中这多余的 3 个字节是为了字节对齐而分配的，相当于有 3 个字节被浪费掉了。


如果不想编译器使用字节对齐的方式进行分配内存，可以采用了 `__attribute__ ((packed))` 属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间。

比如，我用 `__attribute__ ((packed))` 属性定义下面的结构体 ，同样包含 char 和 int 两个类型的成员变量，代码如下所示：


```c
#include <stdio.h>

struct __attribute__((packed)) test2  {
    char a;
    int b;
 } test2;
 
int main() {
     printf("%lu\n", sizeof(test2));
     return 0;
}
```

这时打印的结果是 5（1 个字节 char  + 4 字节 int）。

![](https://img-blog.csdnimg.cn/img_convert/47e6c8fbc17fd6c89bdfcb5eedaaacff.png)

可以看得出，这是按照实际占用字节数进行分配内存的，这样可以节省内存空间。

---

## 4.4 链表

Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构。

### 4.4.1 链表节点结构设计

先来看看「链表节点」结构的样子：

```c
typedef struct listNode {
    //前置节点
    struct listNode *prev;
    //后置节点
    struct listNode *next;
    //节点的值
    void *value;
} listNode;
```

有前置节点和后置节点，可以看的出，这个是一个**双向链表**。

![](https://img-blog.csdnimg.cn/img_convert/4fecbf7f63c73ec284a4821e0bfe2843.png)

### 4.4.2 链表结构设计

Redis 在 listNode 结构体基础上又封装了 list 这个数据结构，这样操作起来会更方便，**链表 list 结构**如下：


```c
typedef struct list {
    //链表头节点
    listNode *head;
    //链表尾节点
    listNode *tail;
    //节点值复制函数
    void *(*dup)(void *ptr);
    //节点值释放函数
    void (*free)(void *ptr);
    //节点值比较函数
    int (*match)(void *ptr, void *key);
    //链表节点数量
    unsigned long len;
} list;
```

list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。

举个例子，下面是**由 list 结构和 3 个 listNode 结构组成的链表。**

![](https://img-blog.csdnimg.cn/img_convert/cadf797496816eb343a19c2451437f1e.png)

### 4.4.3 链表的优势与缺陷

> **Redis 的链表实现优点如下**

- listNode 链表节点的结构里带有 prev 和 next 指针，**获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表**；
- list 结构因为提供了表头指针 head 和表尾节点 tail，所以**获取链表的表头节点和表尾节点的时间复杂度只需O(1)**；
- list 结构因为提供了链表节点数量 len，所以**获取链表中的节点数量的时间复杂度只需O(1)**；
- listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此**链表节点可以保存各种不同类型的值**；

> **链表的缺陷**：

- 链表每个节点之间的内存都是不连续的，意味着**无法很好利用 CPU 缓存**。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。

- 还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，**内存开销较大**。

因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。

不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。

然后在  Redis 5.0 设计了新的数据结构 listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由  listpack 实现。

---

## 4.5 压缩列表

压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。

但是，压缩列表的缺陷也是有的：

- 不能保存过多的元素，否则查询效率就会降低；
- 新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。

因此，Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。

接下来，就跟大家详细聊下压缩列表。 

### 4.5.1 压缩列表结构设计


压缩列表是 Redis 为了**节约内存而开发的**，它是**由连续内存块组成的顺序型数据结构**，有点类似于数组。

![](https://img-blog.csdnimg.cn/img_convert/ab0b44f557f8b5bc7acb3a53d43ebfcb.png)

> **压缩列表在表头有三个字段**

- ***zlbytes***，记录整个压缩列表占用对内存字节数；
- ***zltail***，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；
- ***zllen***，记录压缩列表包含的节点数量；
- ***zlend***，标记压缩列表的结束点，固定值 0xFF（十进制255）。


在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而**查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素**。

> **压缩列表节点（entry）的构成**

![](https://img-blog.csdnimg.cn/img_convert/a3b1f6235cf0587115b21312fe60289c.png)

**压缩列表节点包含三部分内容：**

- ***prevlen***，记录了「前一个节点」的长度；
- ***encoding***，记录了当前节点实际数据的类型以及长度；
- ***data***，记录了当前节点的实际数据；

当我们往压缩列表中插入数据时，压缩列表就会根据数据是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，**这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的**。

> **prevlen 与 encoding 实现不同大小空间分配**


**prevlen 属性**都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：

- 如果**前一个节点的长度小于 254 字节**，那么 prevlen 属性需要用 **1 字节的空间**来保存这个长度值；
- 如果**前一个节点的长度大于等于 254 字节**，那么 prevlen 属性需要用 **5 字节的空间**来保存这个长度值；

**encoding 属性**的空间大小跟数据是字符串还是整数，以及字符串的长度有关：

- 如果**当前节点的数据是整数**，则 encoding 会使用 **1 字节的空间**进行编码。
- 如果**当前节点的数据是字符串，根据字符串的长度大小**，encoding 会使用 **1 字节/2字节/5字节的空间**进行编码。

### 4.5.2 压缩列表的缺陷 - 连锁更新

压缩列表除了查找复杂度高的问题，还有一个问题。

**压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降**。

前面提到，压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：

- 如果前一个**节点的长度小于 254 字节**，那么 prevlen 属性需要用 **1 字节的空间**来保存这个长度值；
- 如果前一个**节点的长度大于等于 254 字节**，那么 prevlen 属性需要用 **5 字节的空间**来保存这个长度值；

现在假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图：

![](https://img-blog.csdnimg.cn/img_convert/462c6a65531667f2bcf420953b0aded9.png)

因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。

这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图：

![](https://img-blog.csdnimg.cn/img_convert/d1a6deff4672580609c99a5b06bf3429.png)

因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。

多米诺牌的效应就此开始。

![](https://img-blog.csdnimg.cn/img_convert/1f0e5ae7ab749078cadda5ba0ed98eac.png)

e1 原本的长度在 250～253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。

正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展.... 一直持续到结尾。

**这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」**，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下....，

### 4.5.3 总结

空间扩展操作也就是重新分配内存，因此**连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能**。

所以说，**虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题**。

因此，**压缩列表只会用于保存的节点数量不多的场景**，只要节点数量足够小，即使发生连锁更新，也是能接受的。

虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。

