# 一、消息队列(消息中间件)

## 1.1 定义

**消息中间件**：是利用**高效可靠的消息传递机制**进行**异步的数据传输**，并基于**数据通信进行分布式系统的集成**。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。

通俗而言：消息中间件就是一个具有接受和发布消息集于一体的容器，而这个消息器还具有保证消息有序性，分发，数据存储等多种特性。

![消息队列](https://camo.githubusercontent.com/f9daf61dc1c3e5cde6caa40b0418c86769166b107685d58f10a570a1d716c5a6/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f2545362542362538382545362538312541462545392539382539462545352538382539372f6d6573736167652d71756575652d736d616c6c2e706e67)

## 1.2 消息队列(中间件)的组成
![](https://pica.zhimg.com/50/v2-6f5d0203500e1c33862987973b92cad3_720w.jpg?source=1940ef5c)

- **Broker**: 消息服务器，作为server提供消息核心服务
- **Exchange**: 消息交换机,它指定消息按什么规则,路由到哪个队列。
- **Producer**: 消息生产者，业务的发起方，负责生产消息传输给broker
- **Consumer**: 消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理
- **Topic**: 主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播
- **Queue**: 队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收
- **Message**: 消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输


## 1.3 为什么要使用消息队列

重点为异步处理、应用解耦、削峰/限流

> **异步处理**

- **应用场景**
  在用户注册后，需要发送注册邮件和发送注册信息，传统的做法有两种：串行方式、并行方式

- **串行方式**
  将注册信息写入数据库成功后，发送注册邮件，然后发送注册短信，而所有任务执行完成后，返回信息给客户端；如图
  ![串行方式](https://img-blog.csdnimg.cn/f015c0ddd12d40628e88511caccdb39b.png)

  由上图可见串行方式需要150ms，因为cpu在单位时间内处理的请求数量是一致的，假设CPU每1秒吞吐量是100次，则串行方式1秒内可执行的请求量为1000/150，不到7次；

- **并行方式**
  将注册信息写入数据库成功后，同时进行发送注册邮件和发送注册短信的操作。而所有任务执行完成后，返回信息给客户端。同串行方式相比，并行方式可以提高执行效率，减少执行时间

  ![并行方式](https://img-blog.csdnimg.cn/6513364c05eb4c7dbc8dbc4ed82db89b.png)

  由上图可见并行方式需要100ms，因为cpu在单位时间内处理的请求数量是一致的，假设CPU每1秒吞吐量是100次，并行方式1秒内可执行的请求量为1000/100，为10次；

- **消息队列异步处理**

    ![异步处理](https://img-blog.csdnimg.cn/b33b9fe2c4e14ee688e842cfba2366b1.png)

    用户的响应时间基本相当于将用户数据写入数据库的时间，发送注册邮件、发送注册短信的消息在写入消息队列后，即可返回执行结果，写入消息队列的时间很快，几乎可以忽略，也有此可以将系统吞吐量提升至20QPS（每秒查询率），比串行方式提升近3倍，比并行方式提升2倍

     > QPS：每秒查询率，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准, 因特网上，经常用每秒查询率来衡量域名系统服务器的机器的性能，即为QPS对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力

> **应用解耦**

- **应用场景**
某一个系统A要与其他系统打交道（即调用其中的方法），如果其它系统改变或者新增系统，那么A系统都会改变，这样的话耦合度比较高
![解耦前系统](https://img-blog.csdnimg.cn/3a683d7f11044ea8991517f0be892080.png)

- **使用消息队列降低系统耦合性**
如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。
![系统解耦](https://img-blog.csdnimg.cn/b95336ff929a4c46bde134cf5022a6cc.png)
消息队列使用**发布-订阅模式**工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。 从上图可以看到消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计

> **削峰/限流**
- **应用场景**
    举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。

- **使用消息队列削峰/限流**
    ![削峰/限流](https://raw.githubusercontent.com/hac135/my_images/master/20210316_MQ_xuefeng.png)

    先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。

> **日志处理**

日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题

![日志处理](https://img-blog.csdnimg.cn/6f6f1caad7ab451bbc0bd5abd0065fd5.png)

- **日志采集客户端**：负责日志数据采集，定时写受写入Kafka队列
- **Kafka消息队列**：负责日志数据的接收，存储和转发
- **日志处理应用**：订阅并消费kafka队列中的日志数据

> **消息通信**

消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通 讯。比如实现点对点消息队列，或者聊天室等。
 
## 1.4 引入消息队列产生的问题

- **系统可用性降低：** 系统可用性在某种程度上降低，因为在加入 MQ 之前，不需要考虑消息丢失或者说 MQ 挂掉等情况，但引入 MQ 之后需要考虑上述问题；
- **系统复杂性提高：** 加入 MQ 之后，需要保证消息没有被重复消费、保证消息不会丢失、保证消息传递的顺序性等问题！
- **一致性问题：** 消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!

# 二、消息队列中的两种消息传递模式

## 2.1 点对点模式

**点对点模式：** 消息生产者将消息发送到队列中，消息消费者从队列中接收消息。消息可以在队列中进行异步传输。

![点对点模式](https://img-blog.csdnimg.cn/20200114105911331.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5MzM5NDUyNjg5,size_16,color_FFFFFF,t_70)

**说明：** 消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。

比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）

## 2.2 发布/订阅模式

**发布-订阅模式：** 发布订阅模式是通过一个内容节点来发布和订阅消息，这个内容节点称为主题（topic），消息发布者将消息发布到某个主题，消息订阅者订阅这个主题的消息，主题相当于一个中介。主题是的消息的发布与订阅相互独立，不需要进行基础即可保证消息的传递，发布/订阅模式采用的是一对多广播。

![发布订阅模式](https://img-blog.csdnimg.cn/20200114110026696.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5MzM5NDUyNjg5,size_16,color_FFFFFF,t_70)

**说明：** 消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。

## 2.3 两种模式的区别
- queue实现了负载均衡，将producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者。
- topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到一个消息的拷贝
  
# 四、JMS VS AMQP

## 4.1 JMS

> **简介**

**JMS（JAVA Message Service,java 消息服务）**是 java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。
**JMS API** 是一个消息服务的标准或者说是规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。

**ActiveMQ 就是基于 JMS 规范实现的**

> **JMS两种消息模式**

详细内容见上文
- 点对点模式
- 发布/订阅模式

> **JMS五种不同的消息正文格式**

**JMS 定义了五种不同的消息正文格式**，以及调用的消息类型，允许发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。
- StreamMessage -- Java 原始值的数据流
- MapMessage--一套名称-值对
- TextMessage--一个字符串对象
- ObjectMessage--一个序列化的 Java 对象
- BytesMessage--一个字节的数据流
  
## 4.2 AMQP

> **简介**

**AMQP(Advanced Message Queuing Protocol)**，一个提供统一消息服务的应用层标准 高级消息队列协议（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。

RabbitMQ 就是基于 AMQP 协议实现的。

> **AMQP的五种消息模式**

- direct exchange
- fanout exchange
- topic change
- headers exchange
- system exchange

## 4.3  JMS vs AMQP
| 对比方向     | JMS                                     | AMQP                                                         |
| :----------- | :-------------------------------------- | :----------------------------------------------------------- |
| 定义         | Java API                                | 协议                                                         |
| 跨语言       | 否                                      | 是                                                           |
| 跨平台       | 否                                      | 是                                                           |
| 支持消息类型 | 提供两种消息模型：①Peer-2-Peer;②Pub/sub | 提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分； |
| 支持消息类型 | 支持多种消息类型 ，我们在上面提到过     | byte[]（二进制）                                             |
  
  **总结：**

- AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。
- JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。
- 由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。
# 五、常见的消息中间件

## 5.1 ActiveMQ

> **简介**

Apache下的一个子项目。使用Java完全支持JMS1.1和J2EE 1.4规范的 JMS       Provider实现，少量代码就可以高效地实现高级应用场景。

**可插拔的传输协议支持**，比如：in-VM, TCP, SSL, NIO, UDP,multicast, JGroups and JXTA transports。

RabbitMQ、ZeroMQ、ActiveMQ均支持常用的多种语言客户端C++、Java、.Net,、Python、 Php、 Ruby等。

> **优点**

- 跨平台(JAVA编写与平台无关，ActiveMQ几乎可以运行在任何的JVM上)；
- 可以用JDBC：可以将数据持久化到数据库。虽然使用JDBC会降低ActiveMQ的性能，但是数据库一直都是开发人员最熟悉的存储介质；
- 支持JMS规范：支持JMS规范提供的统一接口;
- 支持自动重连和错误重试机制；
- 有安全机制：支持基于shiro，jaas等多种安全配置机制，可以对Queue/Topic进行认证和授权；、
- 监控完善：拥有完善的监控，包括WebConsole，JMX，Shell命令行，Jolokia的RESTful API；
- 界面友善：提供的WebConsole可以满足大部分情况，还有很多第三方的组件可以使用，比如hawtio；


> **缺点**

- 社区活跃度不及RabbitMQ高；
- 根据其他用户反馈，会出莫名其妙的问题，会丢失消息；
- 目前重心放到activemq6.0产品Apollo，对5.x的维护较少；
- 不适合用于上千个队列的应用场景；


## 5.2 RocketMQ

> **简介**

阿里系下开源的一款分布式、队列模型的消息中间件，原名Metaq，3.0版本名称改为RocketMQ，是阿里参照kafka设计思想使用java实现的一套mq。同时将阿里系内部多款mq产品（Notify、metaq）进行整合，只维护核心功能，去除了所有其他运行时依赖，保证核心功能最简化，在此基础上配合阿里上述其他开源产品实现不同场景下mq的架构，目前主要多用于订单交易系统。

**其特点如下:**
- 能够保证严格的消息顺序

- 提供针对消息的过滤功能

- 提供丰富的消息拉取模式

- 高效的订阅者水平扩展能力

- 实时的消息订阅机制

- 亿级消息堆积能力

> **优点**
- 单机支持1万以上持久化队列；

- RocketMQ的所有消息都是持久化的，先写入系统PAGECACHE，然后刷盘，可以保证内存与磁盘都有一份数据，而访问时，直接从内存读取。

- 模型简单，接口易用（JMS的接口很多场合并不太实用）；

- 性能非常好，可以允许大量堆积消息在Broker中；

- 支持多种消费模式，包括集群消费、广播消费等；

- 各个环节分布式扩展设计，支持主从和高可用；

- 开发度较活跃，版本更新很快。

> **缺点**

- 支持的 客户端语言不多，目前是Java及C++，其中C++还不成熟；

- RocketMQ社区关注度及成熟度也不及rabbitMQ等；

- 没有Web管理界面，提供了一个 CLI (命令行界面) 管理工具带来查询、管理和诊断各种问题；

- 没有在MQ核心里实现JMS等接口；

## 5.3 RabbitMQ

> **简介**

使用Erlang编写的一个开源的消息队列，**本身支持很多的协议**：AMQP，XMPP,       SMTP,STOMP，也正是如此，使其变的非常重量级，更适合于企业级的开发。
**同时实现了Broker架构**，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队。**对路由(Routing)，负载均衡(Load        balance)、数据持久化都有很好的支持。** 多用于进行**企业级**的ESB整合。

> **优点**

- 由于Erlang语言的特性，消息队列性能较好，支持高并发；
- 健壮、稳定、易用、跨平台、支持多种语言、文档齐全；
- 有消息确认机制和持久化机制，可靠性高；
- 高度可定制的路由；
- 管理界面较丰富，在互联网公司也有较大规模的应用，社区活跃度高。

> **缺点**

- 尽管结合 Erlang 语言本身的并发优势，性能较好，但是不利于做二次开发和维护；

- 实现了代理架构，意味着消息在发送到客户端之前可以在中央节点上排队。此特性使得RabbitMQ易于使用和部署，但是使得其运行速度较慢，因为中央节点增加了延迟，消息封装后也比较大；需要学习比较复杂的接口和协议，学习和维护成本较高。



## 5.4 Kafka

> **简介**

Apache下的一个子项目，使用scala实现的一个高性能分布式Publish/Subscribe消息队列系统，具有以下特性：

- **快速持久化**：通过磁盘顺序读写与零拷贝机制，可以在O(1)的系统开销下进行消息持久化；

- **高吞吐**：在一台普通的服务器上既可以达到10W/s的吞吐速率；

- **高堆积**：支持topic下消费者较长时间离线，消息堆积量大；

- **完全的分布式系统**：Broker、Producer、Consumer都原生自动支持分布式，依赖zookeeper自动实现复杂均衡；

- **支持Hadoop数据并行加载**：对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。

> **优点**
- **客户端语言丰富**：支持Java、.Net、PHP、Ruby、Python、Go等多种语言；

- **高性能**：单机写入TPS约在100万条/秒，消息大小10个字节；

- **提供完全分布式架构**，并有replica机制，拥有较高的可用性和可靠性，理论上支持消息无限堆积；

- **支持批量操作**；

- **消费者采用Pull方式获取消息**。消息有序，通过控制能够保证所有消息被消费且仅被消费一次；

- **有优秀的第三方KafkaWeb管理界面Kafka**-Manager；

- **在日志领域比较成熟**，被多家公司和多个开源项目使用。

> **缺点**

- Kafka单机超过64个队列/分区时，Load时会发生明显的飙高现象。队列越多，负载越高，发送消息响应时间变长；

- 使用短轮询方式，实时性取决于轮询间隔时间；

- 消费失败不支持重试；

- 支持消息顺序，但是一台代理宕机后，就会产生消息乱序；

- 社区更新较慢。

## 5.5 Redis

> **简介**
使用C语言开发的一个Key-Value的NoSQL数据库，开发维护很活跃，虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，**所以完全可以当做一个轻量级的队列服务来使用**。

> **RabbitMQ和Redis对比**

- **实验场景**
对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。

- **实验结果**
**入队时**，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；
**出队时，**无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。

下面对主流的四大消息中间件做一个对比图展示：

## 5.6 性能对比

| 对比方向  |  ActiveMQ     |  RocketMQ  |  RabbitMQ  |   Kafka    |  ZeroMQ    |
| -------  |  --------     |  --------  |  --------  |  --------  |  --------  |
| **定位**      |  可靠消息传输  |  非日志的可靠消息传输  |   可靠消息传输  |  实时数据处理以及日志处理  |  --------  |
| **单机吞吐量**      |  比RabbitMQ低  |  2.6W/s（消息持久化）  |   11.6W/s  |  17.3W/s  |  29w/s  |
| **开发语言**      | java   |  Erlang  |   Java  | Scala/Java  |  C  |
| **主要维护者**      | Apache   |  Mozilla/Spring  |   Alibaba  | Apache  |  iMatix创始人  |
| **成熟度**      | 成熟   |  成熟  |   开源版本不够成熟  | 比较成熟  |  只有C、PHP等版本成熟  |
| **订阅形式**      | 点对点 (p2p)、广 播（发布订阅）   |  提供了4 种： direct,topic,Headers 和 fanout。fanout就 是广播模 式  |   基于 topic/me ssageTag 以及按照消息类型、属性进行正则匹配的发布订阅模 式  | 基于topic 以及按照 topic进行正则匹配的发布订阅模式  |  点对点(P2P)  |
| **持久化**      | 支持少量堆积    |  支持少量堆积  |  支持大量堆积   | 支持大量堆积 |  不支持  |
| **顺序消息**      | 不支持    |  不支持  |  支持   | 支持 |  不支持  |
| **性能稳定性**  | 好    |  好  |  一般   | 较差 |  很好  |
| **集群方式**  | 支持简单集群模式，比如’主备’，对高级集群模式支持不好  |  支持简单集群，'复制’模式，对高级集群模式支持不好。|  常用多对‘Master-Slave’ 模式，开源版本需手动切换Slave变成Master  | 天然 的‘Lead erSlave’无状态集群，每台 服务器既是Master也是Slave |  不支持 |
| **管理界面**  | 一般  |  较好  | 一般  | 无 |  无 |

## 5.7 使用建议

 - ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。

- RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。

- RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的

- Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。

- **所以中小型公司**，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是 不错的选择；**大型公司，基础架构研发实力较强**，用 RocketMQ 是很好的选择。
**如果是大数据领域的实时计算**、日志采集等场景，用 Kafka 是业内标准的，绝 对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性 规范。
