# 十三、设计模式总结

## 13.1 一个目标

管理变化，提高复用！

## 13.2 两种手段

分解 vs. 抽象

### 13.3 八大原则

- 依赖倒置原则（DIP)
- 开放封闭原则（OCP)
- 单一职责原则（SRP)
- Liskov 替换原则（LSP)
- 接口隔离原则（ISP)
- 对象组合由于类继承
- 封装变化点
- 面向接口编程

## 13.4 重构技法

- 静态 -> 动态
- 早绑定 -> 晚绑定
- 继承 -> 组合
- 编译时依赖 -> 运行时依赖
- 紧耦合 -> 松耦合

## 13.5 从封装变化角度对模式分类

- 组件协作：
  - Template Method
  - Observer / Event
  - Strategy

- 单一职责：
  - Decorator
  - Bridge

- 对象创建:
  - Factory Method
  - Abstract Factory
  - Prototype
  - Builder 【注：不是很常用】

- 对象性能：
  - Singleton
  - Flyweight

- 接口隔离:
  - Façade
  - Proxy
  - Mediator 【注：不是很常用】
  - Adapter

- 状态变化：
  - Memento 【注：不是很常用】
  - State

- 数据结构：
  - Composite
  - Iterator 【注：不是很常用】
  - Chain of Resposibility 【注：不是很常用】

- 行为变化：
  - Command 【注：不是很常用】
  - Visitor 【注：不是很常用】

- 领域问题：
  - Interpreter 【注：不是很常用】

## 13.6 C++ 对象模型

![](https://img-blog.csdnimg.cn/img_convert/17c219b6a16a182c8afbaf0005e1d952.png)

继承和组合对象在C++对象模型上来说，都是B嵌入到A的内存中，且在A的内存的前面部分，A和B紧耦合，且B对象不具有灵活性，是不可变的；而第三种的组合一个指针就具有灵活性，指针指向的对象是可变的。

所有的模式最终都是通过指针指向多态对象来表达灵活性。

指针指向多态对象变成了松耦合对象模型的基础。

## 13.7 关注变化点和稳定点

![](https://img-blog.csdnimg.cn/img_convert/a8541e23c075ce5409d33c25487c46ad.png)

## 13.8 什么时候不用模式

- 代码可读性很差时
- 需求理解还很浅时
- 变化没有显现时
- 不是系统的关键依赖点
- 项目没有复用价值时
- 项目将要发布时

## 13.9 经验之谈

- 不要为模式而模式
- 关注抽象类 & 接口
- 理清变化点和稳定点
- 审视依赖关系
- 要有Framework 和 Application 的区隔思维
- 良好的设计是演化的结果

## 13.10 设计模式成长之路

- “手中无剑，心中无剑”：见模式而不知
- “手中有剑，心中无剑”：可以识别模式，作为应用开发人员使用模式
- “手中有剑，心中有剑”：作为框架开发人员为应用设计某些模式
- “手中无剑，心中有剑”：忘掉模式，只有原则
