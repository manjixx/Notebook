# 一、前言

# 二、Zookeeper基本定义

- Zookeeper主要应用于分布式系统，用于实现：**统一配置管理**、**统一命名服务**、**分布式锁**、**集群管理**
- 使用分布式系统就无法避免对节点管理的问题(需要实时感知节点的状态、对节点进行统一管理等等)，而由于这些问题处理起来可能相对麻烦和提高了系统的复杂性，ZooKeeper作为一个能够通用解决这些问题的中间件就应运而生了。

# 三、Zookeeper的数据结构

从上述我们可以知道Zookeeper可以实现统一配置管理、统一命名服务、分布式锁、集群管理，那么Zookeeper是如何实现的呢？

简单来说是通过节点与监听器实现的！

## 2.1 Zookeeper的数据结构

ZooKeeper的数据结构，跟Unix文件系统非常类似，可以看做是一颗树，每个节点叫做`ZNode`。每一个节点可以通过路径来标识，结构图如下：
![](https://pic4.zhimg.com/80/v2-787d82f1f9b7a9a1db8f08aa932058fb_1440w.jpg)

> **ZNode的分类**

ZooKeeper和Redis一样，也是C/S结构(分成客户端和服务端)

- 短暂/临时(Ephemeral)：当客户端和服务端断开连接后，所创建的**Znode(节点)会自动删除**
- 持久(Persistent)：当客户端和服务端断开连接后，所创建的**Znode(节点)不会删除**

## 2.2 监听器

在上面我们已经简单知道了ZooKeeper的数据结构了，**ZooKeeper还配合了监听器才能够做那么多事的。**

> 常见的监听场景

- 监听Znode节点**数据变化**
- 监听子节点的**增减变化**

# 四、Zookeeper具体功能实现

## 4.1 统一配置管理

> **场景**

比如我们现在有三个系统A、B、C，他们有三份配置，分别是ASystem.yml、BSystem.yml、CSystem.yml，然后，这三份配置又非常类似，很多的配置项几乎都一样。

此时，如果我们要改变其中一份配置项的信息，很可能其他两份都要改。并且，改变了配置项的信息很可能就要重启系统
于是，我们希望把ASystem.yml、BSystem.yml、CSystem.yml相同的配置项抽取出来成一份公用的配置common.yml，并且即便common.yml改了，也不需要系统A、B、C重启。

> **采取方案**

- 1.公共配置抽取存放于zookeeper中并落地数据库

- 2.对公共配置修改后发布到zookeeper中并落地数据库

- 3.对应用开启配置实时监听，zookeeper配置文件一旦被修改，应用可实时监听到并获取

> **场景解决方案实现**

我们可以将common.yml这份配置放在ZooKeeper的Znode节点中，系统A、B、C监听着这个Znode节点有无变更，如果变更了，及时响应。

![](https://pic4.zhimg.com/80/v2-40a7b398992105e1b278fca39ba1338b_1440w.jpg)

## 4.2 统一命名服务

统一命名服务的理解其实跟域名一样，是我们为这某一部分的资源给它取一个名字，别人通过这个名字就可以拿到对应的资源。

> **应用场景举例**

比如说，现在我有一个域名www.java3y.com，但我这个域名下有多台机器：

- 192.168.1.1
- 192.168.1.2
- 192.168.1.3
- 192.168.1.4

别人访问www.java3y.com即可访问到我的机器，而不是通过IP去访问。

![](https://pic3.zhimg.com/80/v2-4b86e886479dc91b9527f46fe125e45a_1440w.jpg)

## 4.3 分布式锁

> **应用场景举例**

系统A、B、C都去访问/locks节点

![](https://pic4.zhimg.com/80/v2-4d762a6ece13303b72f33b46a15f0097_1440w.jpg)

- 访问的时候会**创建带顺序号的临时/短暂(EPHEMERAL_SEQUENTIAL)节点**，比如，系统A创建了id_000000节点，系统B创建了id_000002节点，系统C创建了id_000001节点。

![](https://pic3.zhimg.com/80/v2-338b221850de334723018c9164804576_1440w.jpg)

- 拿到/locks节点下的所有子节点(id_000000,id_000001,id_000002)，**判断自己创建的是不是最小的那个节点**
  - 如果是，则拿到锁。执行完操作后，释放锁，将把创建的节点给删掉
  - 如果不是，则监听比自己要小1的节点变化

- 一个流程
  - 系统A拿到/locks节点下的所有子节点，经过比较，发现自己(id_000000)，是所有子节点最小的。所以得到锁
  - 系统B拿到/locks节点下的所有子节点，经过比较，发现自己(id_000002)，不是所有子节点最小的。所以监听比自己小1的节点id_000001的状态
  - 系统C拿到/locks节点下的所有子节点，经过比较，发现自己(id_000001)，不是所有子节点最小的。所以监听比自己小1的节点id_000000的状态
  ......
  - 等到系统A执行完操作以后，将自己创建的节点删除(id_000000)。通过监听，系统C发现id_000000节点已经删除了，发现自己已经是最小的节点了，于是顺利拿到锁
  ......
  - 系统B如上

## 4.4 集群管理

> **应用场景举例**

还是以我们三个系统A、B、C为例，**在ZooKeeper中创建临时节点即可**：

**感知节点的删除与新增**

![](https://pic1.zhimg.com/80/v2-64f633e7f829b5daeedf5e4d116972bc_1440w.jpg)

- 只要系统A挂了，那/groupMember/A这个节点就会删除，通过监听groupMember下的子节点，系统B和C就能够感知到系统A已经挂了。(新增也是同理)

**动态选举Master**

- 原理也很简单，如果想要实现动态选举Master的功能，Znode节点的类型是带顺序号的临时节点(EPHEMERAL_SEQUENTIAL)就好了。

- Zookeeper会每次选举最小编号的作为Master，如果Master挂了，自然对应的Znode节点就会删除。然后让**新的最小编号作为Master**，这样就可以实现动态选举的功能了。
