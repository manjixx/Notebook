## 1.3 SSO单点登录详解

### 3.1 前言

> **SSO**

SSO（Single Sign On），单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。https://baike.baidu.com/item/SSO/3451380


**举个栗子**

例如访问在网易账号中心（https://reg.163.com/ ）登录之后 访问以下站点都是登录状态

网易直播 https://v.163.com
网易博客 https://blog.163.com
网易花田 https://love.163.com
网易考拉 https://www.kaola.com
网易Lofter http://www.lofter.com

> **单点登录的好处**
- 用户角度 :用户能够做到一次登录多次使用，无需记录多套用户名和密码，省心。
- 系统管理员角度 : 管理员只需维护好一个统一的账号中心就可以了，方便。
- 新系统开发角度: 新系统开发时只需直接对接统一的账号中心即可，简化开发流程，省时。

> **设计目标**

SSO系统需要实现的核心功能：
- 单点登录
- 单点登出
- 支持跨域单点登录
- 支持跨域单点登出

### 3.2 SSO设计与实现

> **核心应用与依赖**

![SSO系统核心应用于依赖](https://camo.githubusercontent.com/2117be049297ed01acd96db36d2b9738be95d828b76352b9db7dd6f4c8dcd86f/68747470733a2f2f696d672e6b656e2e696f2f626c6f672f73736f2f73736f2d73797374656d2e706e672d6b626c622e706e67)

应用/模块/对象

- 前台站点:需要登录的站点
- SSO站点-登录:提供登录的页面
- SSO站点-登出:提供注销登录的入口
- SSO服务-登录:提供登录服务
- SSO服务-登录状态:提供登录状态校验/登录信息查询的服务
- SSO服务-登出:提供用户注销登录的服务
- 数据库:存储用户账户信息
- 缓存:存储用户的登录信息，通常使用Redis

> **用户登录状态的存储与校验**

常见的Web框架对于Session的实现都是生成一个SessionId存储在浏览器Cookie中。然后将Session内容存储在服务器端内存中

整体也是借鉴上述思路。 用户登录成功之后，生成AuthToken交给客户端保存。如果是浏览器，就保存在Cookie中。如果是手机App就保存在App本地缓存中。本篇主要探讨基于Web站点的SSO。 用户在浏览需要登录的页面时，客户端将AuthToken提交给SSO服务校验登录状态/获取用户登录信息

对于登录信息的存储，建议采用Redis，使用Redis集群来存储登录信息，既可以保证高可用，又可以线性扩充。同时也可以让SSO服务满足负载均衡/可伸缩的需求

|   对象    |   说明    |
|   ----    |   ----    |
|   AuthToken   | 直接使用UUID/GUID即可，如果有验证AuthToken合法性需求，可以将UserName+时间戳加密生成，服务端解密之后验证合法性|
|   登录信息	|通常是将UserId，UserName缓存起来|

> **用户登录/登录校验**

- **登录时序图**

![用户登录/登录校验](https://camo.githubusercontent.com/1a2ae7a04cd4592e50a0714688f48e3607bba6527860a7e4ed42bb28ae3a54f0/68747470733a2f2f696d672e6b656e2e696f2f626c6f672f73736f2f73736f2d6c6f67696e2d73657175656e63652e706e672d6b6272622e706e67)

按照上图，用户登录后AuthToken保存在Cookie中。 domain=test.com 浏览器会将domain设置成 .test.com， 这样访问所有*.test.com的web站点，都会将AuthToken携带到服务器端。 然后通过SSO服务，完成对用户状态的校验/用户登录信息的获取

- **登录信息获取/登录状态校验**

![登录信息获取/登录状态校验](https://camo.githubusercontent.com/fdd05df571fbcfda39b8672c1f739a385a7d470c1460b3173336ce0a26f74818/68747470733a2f2f696d672e6b656e2e696f2f626c6f672f73736f2f73736f2d6c6f67696e636865636b2d73657175656e63652e706e672d6b6272622e706e67)

> **用户登出**

用户登出需要做如下两件事:

- 服务端清除缓存（Redis）中的登录状态
- 客户端清除存储的AuthToken

- **登出时序图**
![登出时序图](https://camo.githubusercontent.com/607788a2f281daeb2310f3f998cb15d5420ac96b2d96910e04eaa5c046c6cf97/68747470733a2f2f696d672e6b656e2e696f2f626c6f672f73736f2f73736f2d6c6f676f75742d73657175656e63652e706e672d6b6272622e706e67)

> **跨域登录、登出**

核心思路是客户端存储AuthToken，服务器端通过Redis存储登录信息。由于客户端是将AuthToken存储在Cookie中的。所以跨域要解决的问题，就是如何解决Cookie的跨域读写问题。

**解决跨域的核心思路**
- 登录完成之后通过回调的方式，将AuthToken传递给主域名之外的站点，该站点自行将AuthToken保存在当前域下的Cookie中。
- 登出完成之后通过回调的方式，调用非主域名站点的登出页面，完成设置Cookie中的AuthToken过期的操作。


**跨域登录（主域名已登录）** 
![跨域登录（主域名已登录）](https://camo.githubusercontent.com/5d090b5e2fdca43ec3a925a7f63e1c1c303c67a8f8c6f6929ae09de66576614c/68747470733a2f2f696d672e6b656e2e696f2f626c6f672f73736f2f73736f2d63726f7373646f6d61696e2d6c6f67696e2d6c6f67676564696e2d73657175656e63652e706e672d6b6272622e706e67)

**跨域登录（主域名未登录）**

![跨域登录（主域名未登录）](https://camo.githubusercontent.com/7055753ac6603f055cfb2bcff4d1a90b42e4b41f5e479363105e55acc51ae718/68747470733a2f2f696d672e6b656e2e696f2f626c6f672f73736f2f73736f2d63726f7373646f6d61696e2d6c6f67696e2d756e6c6f67696e2d73657175656e63652e706e672d6b6272622e706e67)

**跨域登出**

![跨域登出](https://camo.githubusercontent.com/fbe650ec44a88da5b57edb076fd370a2a8d23882bf31b293689ee77eedc90c04/68747470733a2f2f696d672e6b656e2e696f2f626c6f672f73736f2f73736f2d63726f7373646f6d61696e2d6c6f676f75742d73657175656e63652e706e672d6b6272622e706e67)

## 1.4 OAuth 2.0

### 1.4.1 前言

OAuth 是一个行业的标准授权协议，主要用来授权第三方应用获取有限的权限。而 OAuth 2.0 是对 OAuth 1.0 的完全重新设计，OAuth 2.0 更快，更容易实现，OAuth 1.0 已经被废弃。详情请见：rfc6749。

实际上它就是一种授权机制，它的最终目的是为第三方应用颁发一个有时效性的令牌 Token，使得第三方应用能够通过该令牌获取相关的资源。

OAuth 2.0 比较常用的场景就是第三方登录，当你的网站接入了第三方登录的时候一般就是使用的 OAuth 2.0 协议。

另外，现在 OAuth 2.0 也常见于支付场景（微信支付、支付宝支付）和开发平台（微信开放平台、阿里开放平台等等）。


微信支付账户相关参数：
![微信支付账户相关参数：](https://github.com/Snailclimb/JavaGuide/raw/main/docs/system-design/security/images/basis-of-authority-certification/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98-fnglfdlgdfj.jpeg)

下图是 [Slack OAuth 2.0](https://api.slack.com/legacy/oauth) 第三方登录的示意图：

![Slack OAuth 2.0 第三方登录](https://camo.githubusercontent.com/c90fe9f67adc3e7688436e30ebdc5b97d1634166db9323e49e8ae547c8c7d38e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303631353135313731363334302e706e67)

**推荐阅读**
[OAuth 2.0 的一个简单解释](http://www.ruanyifeng.com/blog/2019/04/oauth_design.html)
[10 分钟理解什么是 OAuth 2.0 协议](https://deepzz.com/post/what-is-oauth2-protocol.html)
[OAuth 2.0 的四种方式](http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html)
[GitHub OAuth 第三方登录示例教程](http://www.ruanyifeng.com/blog/2019/04/github-oauth.html)

***
# 二、数据脱敏

数据脱敏说的就是我们根据特定的规则对敏感信息数据进行变形，比如我们把手机号、身份证号某些位数使用 * 来代替。

***
# 三、敏感词过滤

系统需要对用户输入的文本进行敏感词过滤如色情、政治、暴力相关的词汇。

敏感词过滤用的使用比较多的 **Trie 树算法** 和 **DFA 算法**。

## 3.1 算法实现

### 3.1.1 Trie树

> **Trie 树是什么**

Trie 树 也称为字典树、单词查找树，哈希树的一种变种，通常被用于字符串匹配，用来解决在一组字符串集合中快速查找某个字符串的问题。像浏览器搜索的关键词提示一般就是基于 **Trie 树**来做的。

![浏览器搜索关键词](https://github.com/Snailclimb/JavaGuide/blob/main/docs/system-design/security/images/sentive-words-filter/brower-trie.png)

> **举例**

如果我们的敏感词库中有如下敏感词：
- 高清有码
- 高清 AV
- 东京冷
- 东京热

我们构造出来的敏感词Trie树如图所示:
![敏感词 Trie 树](https://github.com/Snailclimb/JavaGuide/blob/main/docs/system-design/security/images/sentive-words-filter/trie.png)

当我们要查找对应的字符串“东京热”的话，我们会把这个字符串切割成单个的字符“东”、“京”、“热”，然后我们从 Trie 树的根节点开始匹配。

可以看出，**Trie 树的核心原理其实很简单，就是通过公共前缀来提高字符串匹配效率**。

> **Trie树实现**

[Apache Commons Collecions](https://mvnrepository.com/artifact/org.apache.commons/commons-collections4) 这个库中就有 Trie 树实现：

![Trie树的实现](https://github.com/Snailclimb/JavaGuide/blob/main/docs/system-design/security/images/sentive-words-filter/common-collections-trie.png)

```java
Trie<String, String> trie = new PatriciaTrie<>();
trie.put("Abigail", "student");
trie.put("Abi", "doctor");
trie.put("Annabel", "teacher");
trie.put("Christina", "student");
trie.put("Chris", "doctor");
Assertions.assertTrue(trie.containsKey("Abigail"));
assertEquals("{Abi=doctor, Abigail=student}", trie.prefixMap("Abi").toString());
assertEquals("{Chris=doctor, Christina=student}", trie.prefixMap("Chr").toString());
```

### 3.1.2 AC自动机

Aho-Corasick（AC）自动机是一种建立在 Trie 树上的一种改进算法，是一种多模式匹配算法，由贝尔实验室的研究人员 Alfred V. Aho 和 Margaret J.Corasick 发明。

**AC 自动机算法**使用 Trie 树来存放模式串的前缀，**通过失败匹配指针**（失配指针）来处理匹配失败的跳转。

[AC自动机](https://zhuanlan.zhihu.com/p/146369212)

### 3.1.3 DFA

**DFA（Deterministic Finite Automata)**即确定有穷自动机，与之对应的是 NFA（Non-Deterministic Finite Automata，有穷自动机)。

> **自动机介绍**

**有穷自动机(finite state automata)**是一个识别器，它对每个输入的字符做识别和判断，以确定其能到达的最终状态或状态集和路径，有穷自动机分为两类，即**不确定的有穷自动机NFA**和**确定的有穷自动机DFA**

- 举个栗子：红绿灯系统： G（绿灯亮了的状态）；R（红灯亮的状态）；Y（黄灯亮的状态）
- 举个栗子：零售机（vending machine）。它接受五角和一块的硬币，但是要至少积累到3元才能按下选择，并且只有作出选择才会执行。所以从初始state开始，每一个状态之后都有两种选择：要么投5角，要么投1元；每次投完都会到达一个新的状态（目前投入硬币总数）。

> **专有名词解释**

- **alphabet 字母表**：符号的有限集合。 记作： ${Σ}$ 例如：${a, b, ... , x, m}$

- **strings 字符串**: 通常我们用到建立在 ${Σ}$ 上的字符串：有穷的符号序列。 例如：对于 ${Σ={a, b, c}}$, ${“ababc”}$ 就是 ${Σ}$ 上的一个字符串。

- **languages 语言**:通常我们也只用建立在${Σ}$上的语言，语言就是多个字符串的集合。例如 ${{ababc, ab, bc, ..}}$

- **sentences 句子**:句子是语言集合中元素（字符串）的另一个称呼。

- **notation 符号**: ${Σ*}$ 是${Σ}$上所有可能的字符串的集合。例如：Σ={a, b}, Σ* = { ε, a, b, ab, ba}
  
> **DFA**

**DFA:** Deterministic Finite State 确定的有穷自动机

- 1. 第一种计算模型：用来解决对一个已知字符串，看它是否能被某个自动机所接受。
- 2. 一个DFA有有穷个状态（state），主要分为三种状态：「状态间转换的公式： 状态 x 输入字符 --> 状态」
  -  初始状态（initial state）：自动机开始的状态；
  -  终止状态（final state）：一个DFA至少有一个终止状态；
  -  中间状态。
- 3. DFA的定义：${A = ( Σ, S, s_0, F, N )}$
- 4. “确定”意味着对于一个输入字符，只有唯一的可能状态
- 5. 例子
  ![例子](https://pic4.zhimg.com/80/v2-df2acb9639b29a6efabdabd4280c8423_720w.jpg)
  ![转换公式表格](https://pic4.zhimg.com/80/v2-20183c3a35d2cdc9eafdcdc1072d4f83_720w.jpg)
  - 单步表示：${ N (S0, 0)}$,是自动机从s0状态，读取符号0之后的状态。从表格中可以看出N (S0, 0) = S1.
  - 多步表示：${ N (N (S0, 0), 1) = S2}$
  - > **重要定理：**对S中所有的状态s，所有 Σ*中的字符串 α,β， 有： ${N*(s, αβ) = N*(N*(s, α), β)。}$

- 6.最终状态公式(eventual state function):从任意一个状态，经过一个string到达的最终状态的所有可能情况。表达为：${N* : S × Σ* → S}$

- 7.如果一个字符串从一个DFA的初始状态出发，能在某一个终止状态结束，那这个字符串就被这个DFA所接受。所有的这种字符串的集合就是这个自动机的语言（language）。

- 8.**自动机等同**：如果两个自动机接受相同的语言，就说这两个自动机相等。

- 9.**状态等同**：如果对于所有的输入字符串 w， 有并且只有${N*(Sj,w) ∈ F 并且N*(Sk,w) ∈ F （F是final state的集合）}$,注意一个非终止状态永远不可能与一个终止状态等同。
  
- 10.**状态消除**
  - **等同状态消除**：如果两个状态等同，那么其中一个可以被消除，来简化自动机。以上面9.为例，Sk可以被消除， 消除Sk之后的新的自动机。${A' = (Σ, S', s0, F', N' ); S' = S-Sk; F' = F-Sk;N'（s，w）= （if N（s，w）=Sk then Sj else N（s，w））}$,注意这里有个前提，Sk不能是初始状态，因为初始状态不能被消除。
  - **无法到达的状态消除**：如果一个状态是无法从初始状态到达的，那么它可以被消除，例如下图的S3。
  ![无法到达的消除状态](https://pic2.zhimg.com/80/v2-021e5a575b69031fe52c8ad09914a7ed_720w.jpg)

- 11. 传统的分组算法，可以用来最简化自动机

> **NFA**

**NFA(Non-Deeterministic Finite State Automata)不确定的有穷自动机**: 对一个输入符号，有两种或两种以上可能对状态，所以是不确定的。

**NFA可以转换成DFA，NFA和DFA的主要区别在于：**
- DFA没有输入空串之上的转换动作
- 对于DFA，一个特定的符号输入，有且只能得到一个状态，而NFA就有可能得到一个状态集；

**NFA的定义:**${A = ( Σ, S, s0, F, N ) }$

**对于输入字符串w，如果满足$ ∃ s ∈F. R*(s0, w, s)$， 那么w是被自动机所接受的。 所有被该自动机接受的字符串就是这个自动机的语言。**

**定理：**如果语言L被一个NFA所接受，那么一定存在一些DFA也接受这一语言L。

> **Hutool提供DFA的实现算法**

![Hutool实现DFA](https://github.com/Snailclimb/JavaGuide/raw/main/docs/system-design/security/images/sentive-words-filter/hutool-dfa.png)

```java
WordTree wordTree = new WordTree();
wordTree.addWord("大");
wordTree.addWord("大憨憨");
wordTree.addWord("憨憨");
String text = "那人真是个大憨憨！";
// 获得第一个匹配的关键字
String matchStr = wordTree.match(text);
System.out.println(matchStr);   // 输出大
// 标准匹配，匹配到最短关键词，并跳过已经匹配的关键词
List<String> matchStrList = wordTree.matchAll(text, -1, false, false);
System.out.println(matchStrList); // [大、憨憨]
//匹配到最长关键词，跳过已经匹配的关键词
List<String> matchStrList2 = wordTree.matchAll(text, -1, false, true);
System.out.println(matchStrList2);// [大、大憨憨]
```

## 3.2 开源项目

- [ToolGood.Words ](https://github.com/toolgood/ToolGood.Words):一款高性能敏感词(非法词/脏字)检测过滤组件，附带繁体简体互换，支持全角半角互换，汉字转拼音，模糊搜索等功能。
  
- [sensitive-words-filter](https://github.com/hooj0/sensitive-words-filter):敏感词过滤项目，提供 TTMP、DFA、DAT、hash bucket、Tire 算法支持过滤。可以支持文本的高亮、过滤、判词、替换的接口支持。
