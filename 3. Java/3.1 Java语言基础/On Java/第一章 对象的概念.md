>“我们没有意识到惯用语言的结构有多大的力量。可以毫不夸张地说，它通过语义反应机制奴役我们。语言表现出来并在无意识中给我们留下深刻印象的结构会自动投射到我们周围的世界。” -- Alfred Korzybski (1930)

面向对象编程（Object-Oriented Programming OOP）是一种**编程思维方式**和**编码架构**。
# 一、 抽象

所有编程语言都提供抽象机制。问题的复杂度直接取决于抽象的类型和质量。这里的“类型”意思是：抽象的内容是什么？比如汇编语言是对底层机器的轻微抽象。

程序员必须要在**机器模型**（“解决方案空间”）和**实际解决的问题模型**（“问题空间”）之间建立起一种关联。这个过程既费精力，又脱离编程语言本身的范畴。为机器建模的另一个方法是为要解决的问题制作模型。

早期语言都设计了相应的方法，每种方法都有自己特殊的用途，适合解决某一类的问题。只要超出了它们力所能及的范围，就会显得非常笨拙。

面向对象程序设计：利用一些工具表达“问题空间”内的元素，这种表达非常具有普遍性，所以不必受限于特定类型的问题。我们将**问题空间中的元素**以及它们**在解决方案空间的表示**称作“对象”（**Object**）。OOP 允许我们根据问题来描述问题，而不是根据运行解决方案的计算机。

面向对象程序设计方法的特征：
1.  **万物皆对象**。你可以将对象想象成一种特殊的变量。它存储数据，但可以在你对其“发出请求”时执行本身的操作。理论上讲，你总是可以从要解决的问题身上抽象出概念性的组件，然后在程序中将其表示为一个对象。
2.  **程序是一组对象，通过消息传递来告知彼此该做什么**。要请求调用一个对象的方法，你需要向该对象发送消息。
3. **每个对象都有自己的存储空间，可容纳其他对象**。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。
4. **每个对象都有一种类型**。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。
5. **同一类所有对象都能接收相同的消息**。这实际是别有含义的一种说法，大家不久便能理解。由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收发送给"形状”的消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。
# 二、接口

创建好一个类后，可以根据需要生成多个对象。那么**如何利用对象完成真正有用的工作呢**？必须有一种办法能**向对象发出请求**，令其解决一些实际的问题。

我们**向对象发出的请求**是通过它的“**接口**”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类型”与“接口”的对应关系是面向对象程序设计的基础。

## 2.1 例子

下图遵循 **UML**（Unified Modeling Language，统一建模语言）的格式。

每个类由一个框表示，**框的顶部**有类型名称，**框中间部分**是要描述的任何**数据成员**，方法（属于此对象的方法，它们接收任何发送到该对象的消息）在**框的底部**。
![](https://zyb0408.github.io/gitbooks/onjava8/docs/images/reader.png)
```java
Light lt = new Light();
lt.on()
```

- 类型／类的名称是 **Light**
- 接口 / 请求名称可以包括打开 `on`、关闭 `off`、变得更明亮 `brighten` 或者变得更暗淡 `dim`
- 使用句点符号 `.` 将 `lt` 和消息名称 `on` 连接起来，便可**向对象发送请求**
# 三、服务提供

在开发或理解程序设计时，我们可以将**对象看成是“服务提供者”**。我们的**最终目标**是开发或调用工具库中已有的一些对象，提供理想的服务来解决问题。

我们该选择哪个对象来解决问题呢？那对于还没有的对象，我们该设计成啥样呢？

... ...

我们可以将这些问题一一分解，抽象成一组服务。软件设计的**基本原则是高内聚**：每个组件的内部作用明确，功能紧密相关。

在良好的面向对象设计中，每个对象功能单一且高效。
# 四、封装

我们以把编程的侧重领域划分为**研发**和**应用**：
-  **研发程序员开发一个工具类**，该工具类仅向应用程序员公开必要的内容，并隐藏内部实现的细节。这样可以有效地避免该工具类被错误的使用和更改，从而减少程序出错的可能。
- **应用程序员调用研发程序员构建的基础工具类来做快速开发**。通过使用现成的工具类组装应用程序或者构建更大的工具库。

但使用过程中需要设定**访问控制**，避免应用程序员按照正确的规则来使用。**使用访问控制的原因**：
- **让应用程序员不要触摸他们不应该触摸的部分**。（请注意，这也是一个哲学决策。部分编程语言认为如果程序员有需要，则应该让他们访问细节部分。）
- **使类库的创建者（研发程序员）在不影响后者使用的情况下完善更新工具库**。例如，我们开发了一个功能简单的工具类，后来发现可以通过优化代码来提高执行速度。假如工具类的接口和实现部分明确分开并受到保护，那我们就可以轻松地完成改造。

Java 有三个显式关键字来**设置类中的访问权限**：`public`（公开），`private`（私有）和`protected`（受保护）。这些访问修饰符决定了谁能使用它们修饰的方法、变量或类。**

 1. `public`（公开）表示任何人都可以访问和使用该元素；
   
2. `private`（私有）除了类本身和类内部的方法，外界无法直接访问该元素。`private` 是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误；

3. `protected`（受保护）类似于 `private`，区别是子类（下一节就会引入继承的概念）可以访问 `protected` 的成员，但不能访问 `private` 成员；

4. `default`（默认）如果你不使用前面的三者，默认就是 `default` 访问权限。`default` 被称为包访问，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。


# 五、复用

**代码和设计方案的复用性**是面向对象程序设计的优点之一。
- 我们可以通过**重复使用某个类的对象**来达到这种复用性。
- 同时，我们也可以将**一个类的对象作为另一个类的成员变量使用**。

这里涉及**组合**和**聚合**的概念：
- **组合**（Composition）经常用来表示“拥有”关系（has-a relationship）。例如，“汽车拥有引擎”。
    
- **聚合**（Aggregation）动态的**组合**

![](https://zyb0408.github.io/gitbooks/onjava8/docs/images/1545758268350.png)

上图中实心三角形指向“ **Car** ”表示 **组合** 的关系；如果是 **聚合** 关系，可以使用空心三角形。

组合和聚合都属于关联关系的一种，只是额外具有整体-部分的意义。至于是聚合还是组合，需要根据实际的业务需求来判断。只看代码是无法区分聚合和组合的，具体是哪一种关系，只能从**语义级别来区分**。
- 聚合关系中，**整件不会拥有部件的生命周期**，所以整件删除时，部件不会被删除。再者，**多个整件可以共享同一个部件**。
- 组合关系中，**整件拥有部件的生命周期**，所以整件删除时，部件一定会跟着删除。而且，**多个整件不可以同时共享同一个部件**。
- 两个类生命周期**不同步**，则是**聚合关系**，生命周期**同步就是组合关系**。

在面向对象编程中经常重点强调“继承”。但沿着这种思路产生的程序设计通常拙劣又复杂。相反，**在创建新类时首先要考虑“组合”**，因为它更简单灵活，而且设计更加清晰。

# 六、继承
## 6.1 继承的设计目标
通过使用 `class` 关键字，这些概念形成了编程语言中的基本单元。

继承是为了解决：在创建了一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类的问题。

即利用现成的数据类型，对其进行“克隆”，再根据情况进行添加和修改。但继承并不完全等价于克隆。

在继承过程中，若原始类（正式名称叫作基类、超类或父类）发生了变化，修改过的“克隆”类（正式名称叫作继承类或者子类）也会反映出这种变化。

继承通过基类和派生类的概念来表达这种相似性。**基类**包含派生自它的类型之间共享的所有特征和行为。创建基类以表示思想的核心。从基类中**派生出其他类型来表示实现该核心的不同方式**。图中的箭头从派生类指向基类。

![](https://zyb0408.github.io/gitbooks/onjava8/docs/images/1545763399825.png)

## 6.2 继承的例子

每个形状可以绘制、擦除、移动、着色等。由此，可以派生出（继承出）具体类型的形状——圆形、正方形、三角形等等——每个形状可以具有附加的特征和行为。例如，某些形状可以翻转。有些行为可能不同，比如计算形状的面积。

![](https://zyb0408.github.io/gitbooks/onjava8/docs/images/1545764780795.png)

类型层次结构体现了**形状之间的相似性和差异性**。通过使用对象，类型层次结构成为了主要模型，因此你可以直接从真实世界中对系统的描述过渡到用代码对系统进行描述。

从现有类型继承创建新类型。这种新类型不仅包含现有类型的所有成员（尽管私有成员被隐藏起来并且不可访问），而且更重要的是它复制了基类的接口。也就是说，**基类对象接收的所有消息也能被派生类对象接收。** 根据类接收的消息，我们知道类的类型，因此派生类与基类是相同的类型。

**区分新的派生类与原始的基类:**
- 在派生类中添加新方法。这些新方法不是基类接口的一部分。
- 第二种也是更重要地区分派生类和基类的方法是改变现有基类方法的行为，这被称为覆盖 (overriding)。要想覆盖一个方法，只需要在派生类中重新定义这个方法即可。

## 6.3 是一个和像是一个的关系

对于继承可能会引发争论：继承应该只覆盖基类的方法(不应该添加基类中没有的方法)吗？如果这样的话，基类和派生类就是相同的类型了，因为它们具有相同的接口。

这会造成，**可以用一个派生类对象完全替代基类对象，这叫作"纯粹替代"，也经常被称作"替代原则"。** 在某种意义上，这是一种处理继承的理想方式。我们经常把这种基类和派生类的关系称为是 **一个（is-a）关系**，因为可以说"圆是一个形状"。判断是否继承，就看在你的类之间有无这种 is-a 关系。

有时你在派生类添加了新的接口元素，从而扩展接口。虽然新类型仍然可以替代基类，但是这种替代不完美，原因在于基类无法访问新添加的方法。这种关系称为**像是一个(is-like-a)关系**。新类型不但拥有旧类型的接口，而且包含其他方法，所以不能说新旧类型完全相同。

![](https://zyb0408.github.io/gitbooks/onjava8/docs/images/1545764820176.png)

以空调为例，假设房间里已经安装好了制冷设备的控制器，即你有了控制制冷设备的接口。想象一下，现在空调坏了，你重新安装了一个既制冷又制热的热力泵。热力泵就像是一个（is-like-a）空调，但它可以做更多。因为当初房间的控制系统被设计成只能控制制冷设备，所以它只能与新对象(热力泵)的制冷部分通信。新对象的接口已经扩展了，现有控制系统却只知道原来的接口，一旦看到这个设计，你就会发现，作为基类的制冷系统不够一般化，应该被重新命名为"温度控制系统"，也应该包含制热功能，这样的话，我们就可以使用替代原则了。上图反映了在现实世界中进行设计时可能会发生的事情。

# 七、多态

# 八、单继承
# 九、集合
# 十、生命周期
# 十一、异常处理
