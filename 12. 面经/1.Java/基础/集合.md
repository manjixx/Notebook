- [ä¸€ã€é›†åˆæ¦‚è¿°](#ä¸€é›†åˆæ¦‚è¿°)
  - [1.1  Java é›†åˆæ¦‚è¿°](#11--java-é›†åˆæ¦‚è¿°)
  - [1.2 è¯´è¯´ List, Set, Queue, Map å››è€…çš„åŒºåˆ«ï¼Ÿ](#12-è¯´è¯´-list-set-queue-map-å››è€…çš„åŒºåˆ«)
  - [1.3 é›†åˆæ¡†æ¶åº•å±‚æ•°æ®ç»“æ„æ€»ç»“](#13-é›†åˆæ¡†æ¶åº•å±‚æ•°æ®ç»“æ„æ€»ç»“)
    - [List](#list)
    - [Set](#set)
    - [Queue](#queue)
    - [Map](#map)
    - [å¦‚ä½•é€‰ç”¨é›†åˆ?](#å¦‚ä½•é€‰ç”¨é›†åˆ)
  - [1.4 ä¸ºä»€ä¹ˆè¦ä½¿ç”¨é›†åˆï¼Ÿ](#14-ä¸ºä»€ä¹ˆè¦ä½¿ç”¨é›†åˆ)
- [äºŒã€List](#äºŒlist)
  - [2.1 å¸¸è§é¢è¯•é¢˜](#21-å¸¸è§é¢è¯•é¢˜)
  - [2.2 ArrayListæºç ä¸æ‰©å®¹æœºåˆ¶åˆ†æ](#22-arraylistæºç ä¸æ‰©å®¹æœºåˆ¶åˆ†æ)
    - [ArrayListæºç ](#arraylistæºç )
    - [ArrayList çš„æ„é€ å‡½æ•°](#arraylist-çš„æ„é€ å‡½æ•°)
    - [åˆ†æArrayListæ‰©å®¹æœºåˆ¶](#åˆ†æarraylistæ‰©å®¹æœºåˆ¶)
      - [add æ–¹æ³•](#add-æ–¹æ³•)
      - [ensureCapacityInternalæ–¹æ³•](#ensurecapacityinternalæ–¹æ³•)
      - [ensureExplicitCapacity æ–¹æ³•](#ensureexplicitcapacity-æ–¹æ³•)
      - [growæ–¹æ³•](#growæ–¹æ³•)
      - [hugeCapacityæ–¹æ³•](#hugecapacityæ–¹æ³•)
      - [æµç¨‹åˆ†æ](#æµç¨‹åˆ†æ)
- [ä¸‰ã€Set](#ä¸‰set)
  - [3.1 å¸¸è§é¢è¯•é¢˜](#31-å¸¸è§é¢è¯•é¢˜)
    - [comparable å’Œ Comparator çš„åŒºåˆ«](#comparable-å’Œ-comparator-çš„åŒºåˆ«)
    - [æ— åºæ€§å’Œä¸å¯é‡å¤æ€§çš„å«ä¹‰æ˜¯ä»€ä¹ˆ](#æ— åºæ€§å’Œä¸å¯é‡å¤æ€§çš„å«ä¹‰æ˜¯ä»€ä¹ˆ)
    - [æ¯”è¾ƒ HashSetã€LinkedHashSet å’Œ TreeSet ä¸‰è€…çš„å¼‚åŒ](#æ¯”è¾ƒ-hashsetlinkedhashset-å’Œ-treeset-ä¸‰è€…çš„å¼‚åŒ)
- [å››ã€ Queue](#å››-queue)
  - [4.1 Queueå¸¸è§é¢è¯•é¢˜](#41-queueå¸¸è§é¢è¯•é¢˜)
    - [Queueå’ŒDequeçš„åŒºåˆ«](#queueå’Œdequeçš„åŒºåˆ«)
    - [ArrayDeque ä¸ LinkedList çš„åŒºåˆ«](#arraydeque-ä¸-linkedlist-çš„åŒºåˆ«)
    - [PriorityQueue](#priorityqueue)
- [äº”ã€Map](#äº”map)
  - [5.1 å¸¸è§é¢è¯•é¢˜](#51-å¸¸è§é¢è¯•é¢˜)
    - [HashMap å’Œ Hashtable çš„åŒºåˆ«](#hashmap-å’Œ-hashtable-çš„åŒºåˆ«)
    - [HashMap å’Œ HashSet åŒºåˆ«](#hashmap-å’Œ-hashset-åŒºåˆ«)
    - [HashMap å’Œ TreeMap åŒºåˆ«](#hashmap-å’Œ-treemap-åŒºåˆ«)
    - [HashSet å¦‚ä½•æ£€æŸ¥é‡å¤?](#hashset-å¦‚ä½•æ£€æŸ¥é‡å¤)
    - [HashMap çš„åº•å±‚å®ç°](#hashmap-çš„åº•å±‚å®ç°)
      - [JDK1.8 ä¹‹å‰](#jdk18-ä¹‹å‰)
      - [JDK1.8 ä¹‹å](#jdk18-ä¹‹å)
    - [HashMap çš„é•¿åº¦ä¸ºä»€ä¹ˆæ˜¯ 2 çš„å¹‚æ¬¡æ–¹](#hashmap-çš„é•¿åº¦ä¸ºä»€ä¹ˆæ˜¯-2-çš„å¹‚æ¬¡æ–¹)
    - [HashMap å¤šçº¿ç¨‹æ“ä½œå¯¼è‡´æ­»å¾ªç¯é—®é¢˜](#hashmap-å¤šçº¿ç¨‹æ“ä½œå¯¼è‡´æ­»å¾ªç¯é—®é¢˜)
    - [HashMap æœ‰å“ªå‡ ç§å¸¸è§çš„éå†æ–¹å¼?](#hashmap-æœ‰å“ªå‡ ç§å¸¸è§çš„éå†æ–¹å¼)
    - [ConcurrentHashMap å’Œ Hashtable çš„åŒºåˆ«](#concurrenthashmap-å’Œ-hashtable-çš„åŒºåˆ«)
    - [ConcurrentHashMap çº¿ç¨‹å®‰å…¨çš„å…·ä½“å®ç°æ–¹å¼/åº•å±‚å…·ä½“å®ç°](#concurrenthashmap-çº¿ç¨‹å®‰å…¨çš„å…·ä½“å®ç°æ–¹å¼åº•å±‚å…·ä½“å®ç°)
      - [JDK 1.8 ä¹‹å‰](#jdk-18-ä¹‹å‰)
      - [JDK 1.8 ä¹‹å](#jdk-18-ä¹‹å)
    - [JDK 1.7 å’Œ JDK 1.8 çš„ ConcurrentHashMap å®ç°æœ‰ä»€ä¹ˆä¸åŒï¼Ÿ](#jdk-17-å’Œ-jdk-18-çš„-concurrenthashmap-å®ç°æœ‰ä»€ä¹ˆä¸åŒ)
  - [5.2 HashMap åº•å±‚æ•°æ®ç»“æ„ä¸æºç åˆ†æ](#52-hashmap-åº•å±‚æ•°æ®ç»“æ„ä¸æºç åˆ†æ)
    - [5.2.1 åº•å±‚æ•°æ®ç»“æ„åˆ†æ](#521-åº•å±‚æ•°æ®ç»“æ„åˆ†æ)
      - [5.2.1.1 JDK1.8 ä¹‹å‰](#5211-jdk18-ä¹‹å‰)
      - [5.2.1.2 JDK1.8 ä¹‹å](#5212-jdk18-ä¹‹å)
    - [5.2.2 HashMap æºç åˆ†æ](#522-hashmap-æºç åˆ†æ)
  - [5.3 HashMap å¸¸ç”¨æ–¹æ³•æµ‹è¯•](#53-hashmap-å¸¸ç”¨æ–¹æ³•æµ‹è¯•)
  - [5.4 ConcurrentHashMapåº•å±‚æ•°æ®ç»“æ„ä¸æºç åˆ†æ](#54-concurrenthashmapåº•å±‚æ•°æ®ç»“æ„ä¸æºç åˆ†æ)
    - [5.4.1 ConcurrentHashMap 1.7](#541-concurrenthashmap-17)
    - [5.4.2 ConcurrentHashMap 1.8](#542-concurrenthashmap-18)
    - [5.4.3 æ€»ç»“](#543-æ€»ç»“)
- [å…­ã€Collectionså·¥å…·ç±»](#å…­collectionså·¥å…·ç±»)
  - [6.1 æ’åºæ“ä½œ](#61-æ’åºæ“ä½œ)
  - [6.2 æŸ¥æ‰¾,æ›¿æ¢æ“ä½œ](#62-æŸ¥æ‰¾æ›¿æ¢æ“ä½œ)
  - [6.3 åŒæ­¥æ§åˆ¶](#63-åŒæ­¥æ§åˆ¶)
# ä¸€ã€é›†åˆæ¦‚è¿°

## 1.1  Java é›†åˆæ¦‚è¿°

Java é›†åˆï¼Œ ä¹Ÿå«ä½œå®¹å™¨ï¼Œä¸»è¦æ˜¯ç”±ä¸¤å¤§æ¥å£æ´¾ç”Ÿè€Œæ¥ï¼š

- ä¸€ä¸ªæ˜¯ `Collection`æ¥å£ï¼Œä¸»è¦ç”¨äºå­˜æ”¾å•ä¸€å…ƒç´ ï¼Œå¯¹äº`Collection` æ¥å£ï¼Œä¸‹é¢åˆæœ‰ä¸‰ä¸ªä¸»è¦çš„å­æ¥å£ï¼š`List`ã€`Set` å’Œ `Queue`ã€‚
- å¦ä¸€ä¸ªæ˜¯ `Map` æ¥å£ï¼Œä¸»è¦ç”¨äºå­˜æ”¾é”®å€¼å¯¹ã€‚

Java é›†åˆæ¡†æ¶å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java-collection-hierarchy.png)


æ³¨ï¼šå›¾ä¸­åªåˆ—ä¸¾äº†ä¸»è¦çš„ç»§æ‰¿æ´¾ç”Ÿå…³ç³»ï¼Œå¹¶æ²¡æœ‰åˆ—ä¸¾æ‰€æœ‰å…³ç³»ã€‚æ¯”æ–¹çœç•¥äº†`AbstractList`, `NavigableSet`ç­‰æŠ½è±¡ç±»ä»¥åŠå…¶ä»–çš„ä¸€äº›è¾…åŠ©ç±»ï¼Œå¦‚æƒ³æ·±å…¥äº†è§£ï¼Œå¯è‡ªè¡ŒæŸ¥çœ‹æºç ã€‚

## 1.2 è¯´è¯´ List, Set, Queue, Map å››è€…çš„åŒºåˆ«ï¼Ÿ

- `List`(å¯¹ä»˜é¡ºåºçš„å¥½å¸®æ‰‹): å­˜å‚¨çš„å…ƒç´ æ˜¯æœ‰åºçš„ã€å¯é‡å¤çš„ã€‚
- `Set`(æ³¨é‡ç‹¬ä¸€æ— äºŒçš„æ€§è´¨): å­˜å‚¨çš„å…ƒç´ æ˜¯æ— åºçš„ã€ä¸å¯é‡å¤çš„ã€‚
- `Queue`(å®ç°æ’é˜ŸåŠŸèƒ½çš„å«å·æœº): æŒ‰ç‰¹å®šçš„æ’é˜Ÿè§„åˆ™æ¥ç¡®å®šå…ˆåé¡ºåºï¼Œå­˜å‚¨çš„å…ƒç´ æ˜¯æœ‰åºçš„ã€å¯é‡å¤çš„ã€‚
- `Map`(ç”¨ key æ¥æœç´¢çš„ä¸“å®¶): ä½¿ç”¨é”®å€¼å¯¹ï¼ˆkey-valueï¼‰å­˜å‚¨ï¼Œç±»ä¼¼äºæ•°å­¦ä¸Šçš„å‡½æ•° y=f(x)ï¼Œ"x" ä»£è¡¨ keyï¼Œ"y" ä»£è¡¨ valueï¼Œkey æ˜¯æ— åºçš„ã€ä¸å¯é‡å¤çš„ï¼Œvalue æ˜¯æ— åºçš„ã€å¯é‡å¤çš„ï¼Œæ¯ä¸ªé”®æœ€å¤šæ˜ å°„åˆ°ä¸€ä¸ªå€¼ã€‚

## 1.3 é›†åˆæ¡†æ¶åº•å±‚æ•°æ®ç»“æ„æ€»ç»“

å…ˆæ¥çœ‹ä¸€ä¸‹ `Collection` æ¥å£ä¸‹é¢çš„é›†åˆã€‚

### List

- `ArrayList`ï¼š `Object[]` æ•°ç»„
- `Vector`ï¼š`Object[]` æ•°ç»„
- `LinkedList`ï¼š åŒå‘é“¾è¡¨(JDK1.6 ä¹‹å‰ä¸ºå¾ªç¯é“¾è¡¨ï¼ŒJDK1.7 å–æ¶ˆäº†å¾ªç¯)

### Set

- `HashSet`(æ— åºï¼Œå”¯ä¸€): åŸºäº `HashMap` å®ç°çš„ï¼Œåº•å±‚é‡‡ç”¨ `HashMap` æ¥ä¿å­˜å…ƒç´ 
- `LinkedHashSet`: `LinkedHashSet` æ˜¯ `HashSet` çš„å­ç±»ï¼Œå¹¶ä¸”å…¶å†…éƒ¨æ˜¯é€šè¿‡ `LinkedHashMap` æ¥å®ç°çš„ã€‚æœ‰ç‚¹ç±»ä¼¼äºæˆ‘ä»¬ä¹‹å‰è¯´çš„ `LinkedHashMap` å…¶å†…éƒ¨æ˜¯åŸºäº `HashMap` å®ç°ä¸€æ ·ï¼Œä¸è¿‡è¿˜æ˜¯æœ‰ä¸€ç‚¹ç‚¹åŒºåˆ«çš„
- `TreeSet`(æœ‰åºï¼Œå”¯ä¸€): çº¢é»‘æ ‘(è‡ªå¹³è¡¡çš„æ’åºäºŒå‰æ ‘)

### Queue

- `PriorityQueue`: `Object[]` æ•°ç»„æ¥å®ç°äºŒå‰å †
- `ArrayQueue`: `Object[]` æ•°ç»„ + åŒæŒ‡é’ˆ

å†æ¥çœ‹çœ‹ `Map` æ¥å£ä¸‹é¢çš„é›†åˆã€‚

### Map

- `HashMap`ï¼š 
  - JDK1.8 ä¹‹å‰ `HashMap` ç”±æ•°ç»„+é“¾è¡¨ç»„æˆçš„ï¼Œæ•°ç»„æ˜¯ `HashMap` çš„ä¸»ä½“ï¼Œé“¾è¡¨åˆ™æ˜¯ä¸»è¦ä¸ºäº†è§£å†³å“ˆå¸Œå†²çªè€Œå­˜åœ¨çš„ï¼ˆâ€œæ‹‰é“¾æ³•â€è§£å†³å†²çªï¼‰ã€‚
  - JDK1.8 ä»¥ååœ¨è§£å†³å“ˆå¸Œå†²çªæ—¶æœ‰äº†è¾ƒå¤§çš„å˜åŒ–ï¼Œå½“é“¾è¡¨é•¿åº¦å¤§äºé˜ˆå€¼ï¼ˆé»˜è®¤ä¸º 8ï¼‰ï¼ˆå°†é“¾è¡¨è½¬æ¢æˆçº¢é»‘æ ‘å‰ä¼šåˆ¤æ–­ï¼Œå¦‚æœå½“å‰æ•°ç»„çš„é•¿åº¦å°äº 64ï¼Œé‚£ä¹ˆä¼šé€‰æ‹©å…ˆè¿›è¡Œæ•°ç»„æ‰©å®¹ï¼Œè€Œä¸æ˜¯è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼‰æ—¶ï¼Œå°†é“¾è¡¨è½¬åŒ–ä¸ºçº¢é»‘æ ‘ï¼Œä»¥å‡å°‘æœç´¢æ—¶é—´
- `LinkedHashMap`ï¼š 
  - `LinkedHashMap` ç»§æ‰¿è‡ª `HashMap`ï¼Œæ‰€ä»¥åº•å±‚ä»ç„¶æ˜¯åŸºäºæ‹‰é“¾å¼æ•£åˆ—ç»“æ„å³ç”±æ•°ç»„å’Œé“¾è¡¨æˆ–çº¢é»‘æ ‘ç»„æˆã€‚
  - `LinkedHashMap` åœ¨ä¸Šé¢ç»“æ„çš„åŸºç¡€ä¸Šï¼Œå¢åŠ äº†ä¸€æ¡åŒå‘é“¾è¡¨ï¼Œä½¿å¾—ä¸Šé¢çš„ç»“æ„å¯ä»¥ä¿æŒé”®å€¼å¯¹çš„æ’å…¥é¡ºåºã€‚åŒæ—¶é€šè¿‡å¯¹é“¾è¡¨è¿›è¡Œç›¸åº”çš„æ“ä½œï¼Œå®ç°äº†è®¿é—®é¡ºåºç›¸å…³é€»è¾‘ã€‚è¯¦ç»†å¯ä»¥æŸ¥çœ‹ï¼š[ã€ŠLinkedHashMap æºç è¯¦ç»†åˆ†æï¼ˆJDK1.8ï¼‰ã€‹](https://www.imooc.com/article/22931)
- `Hashtable`ï¼š æ•°ç»„+é“¾è¡¨ç»„æˆçš„ï¼Œæ•°ç»„æ˜¯ `Hashtable` çš„ä¸»ä½“ï¼Œé“¾è¡¨åˆ™æ˜¯ä¸»è¦ä¸ºäº†è§£å†³å“ˆå¸Œå†²çªè€Œå­˜åœ¨çš„
- `TreeMap`ï¼š çº¢é»‘æ ‘ï¼ˆè‡ªå¹³è¡¡çš„æ’åºäºŒå‰æ ‘ï¼‰

### å¦‚ä½•é€‰ç”¨é›†åˆ?

ä¸»è¦æ ¹æ®é›†åˆçš„ç‰¹ç‚¹æ¥é€‰ç”¨ï¼š

- éœ€è¦æ ¹æ®é”®å€¼è·å–åˆ°å…ƒç´ å€¼æ—¶å°±é€‰ç”¨ `Map` æ¥å£ä¸‹çš„é›†åˆï¼Œéœ€è¦æ’åºæ—¶é€‰æ‹© `TreeMap`,ä¸éœ€è¦æ’åºæ—¶å°±é€‰æ‹© `HashMap`,éœ€è¦ä¿è¯çº¿ç¨‹å®‰å…¨å°±é€‰ç”¨ `ConcurrentHashMap`ã€‚
- åªéœ€è¦å­˜æ”¾å…ƒç´ å€¼æ—¶ï¼Œå°±é€‰æ‹©å®ç°`Collection` æ¥å£çš„é›†åˆï¼Œéœ€è¦ä¿è¯å…ƒç´ å”¯ä¸€æ—¶é€‰æ‹©å®ç° `Set` æ¥å£çš„é›†åˆæ¯”å¦‚ `TreeSet` æˆ– `HashSet`ï¼Œä¸éœ€è¦å°±é€‰æ‹©å®ç° `List` æ¥å£çš„æ¯”å¦‚ `ArrayList` æˆ– `LinkedList`ï¼Œç„¶åå†æ ¹æ®å®ç°è¿™äº›æ¥å£çš„é›†åˆçš„ç‰¹ç‚¹æ¥é€‰ç”¨ã€‚

## 1.4 ä¸ºä»€ä¹ˆè¦ä½¿ç”¨é›†åˆï¼Ÿ

å½“æˆ‘ä»¬éœ€è¦ä¿å­˜ä¸€ç»„ç±»å‹ç›¸åŒçš„æ•°æ®çš„æ—¶å€™ï¼Œæˆ‘ä»¬åº”è¯¥æ˜¯ç”¨ä¸€ä¸ªå®¹å™¨æ¥ä¿å­˜ï¼Œè¿™ä¸ªå®¹å™¨å°±æ˜¯æ•°ç»„ï¼Œä½†æ˜¯ï¼Œä½¿ç”¨æ•°ç»„å­˜å‚¨å¯¹è±¡å…·æœ‰ä¸€å®šçš„å¼Šç«¯ï¼Œ

å› ä¸ºæˆ‘ä»¬åœ¨å®é™…å¼€å‘ä¸­ï¼Œå­˜å‚¨çš„æ•°æ®çš„ç±»å‹æ˜¯å¤šç§å¤šæ ·çš„ï¼Œäºæ˜¯ï¼Œå°±å‡ºç°äº†â€œé›†åˆâ€ï¼Œé›†åˆåŒæ ·ä¹Ÿæ˜¯ç”¨æ¥å­˜å‚¨å¤šä¸ªæ•°æ®çš„ã€‚

æ•°ç»„çš„ç¼ºç‚¹æ˜¯ä¸€æ—¦å£°æ˜ä¹‹åï¼Œé•¿åº¦å°±ä¸å¯å˜äº†ï¼›
å£°æ˜æ•°ç»„æ—¶çš„æ•°æ®ç±»å‹ä¹Ÿå†³å®šäº†è¯¥æ•°ç»„å­˜å‚¨çš„æ•°æ®çš„ç±»å‹ï¼›
æ•°ç»„å­˜å‚¨çš„æ•°æ®æ˜¯æœ‰åºçš„ã€å¯é‡å¤çš„ï¼Œç‰¹ç‚¹å•ä¸€ã€‚

ä½†æ˜¯é›†åˆæé«˜äº†æ•°æ®å­˜å‚¨çš„çµæ´»æ€§ï¼ŒJava é›†åˆä¸ä»…å¯ä»¥ç”¨æ¥å­˜å‚¨ä¸åŒç±»å‹ä¸åŒæ•°é‡çš„å¯¹è±¡ï¼Œè¿˜å¯ä»¥ä¿å­˜å…·æœ‰æ˜ å°„å…³ç³»çš„æ•°æ®ã€‚

---

# äºŒã€List

## 2.1 å¸¸è§é¢è¯•é¢˜

> **ArrayList ç®€ä»‹**

`ArrayList` çš„åº•å±‚æ˜¯æ•°ç»„é˜Ÿåˆ—ï¼Œç›¸å½“äºåŠ¨æ€æ•°ç»„ã€‚

ä¸Java ä¸­çš„æ•°ç»„ç›¸æ¯”ï¼Œå®ƒçš„å®¹é‡èƒ½åŠ¨æ€å¢é•¿ã€‚

åœ¨æ·»åŠ å¤§é‡å…ƒç´ å‰ï¼Œåº”ç”¨ç¨‹åºå¯ä»¥ä½¿ç”¨`ensureCapacity`æ“ä½œæ¥å¢åŠ  `ArrayList` å®ä¾‹çš„å®¹é‡ã€‚è¿™å¯ä»¥å‡å°‘é€’å¢å¼å†åˆ†é…çš„æ•°é‡ã€‚

ArrayListç»§æ‰¿äº AbstractList ï¼Œå®ç°äº†   `List, RandomAccess, Cloneable, java.io.Serializable` è¿™äº›æ¥å£ã€‚

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{

}
```

- `RandomAccess` æ˜¯ä¸€ä¸ªæ ‡å¿—æ¥å£ï¼Œè¡¨æ˜å®ç°è¿™ä¸ªè¿™ä¸ªæ¥å£çš„ `List` é›†åˆæ˜¯**æ”¯æŒå¿«é€Ÿéšæœºè®¿é—®çš„**ã€‚åœ¨ ArrayList ä¸­ï¼Œæˆ‘ä»¬å³å¯ä»¥é€šè¿‡å…ƒç´ çš„åºå·å¿«é€Ÿè·å–å…ƒç´ å¯¹è±¡ï¼Œè¿™å°±æ˜¯å¿«é€Ÿéšæœºè®¿é—®ã€‚
- `ArrayList` å®ç°äº† `Cloneable` æ¥å£ ï¼Œå³è¦†ç›–äº†å‡½æ•°`clone()`ï¼Œ**èƒ½è¢«å…‹éš†**ã€‚
- `ArrayList` å®ç°äº† `java.io.Serializable`æ¥å£ï¼Œè¿™æ„å‘³ç€**ArrayListæ”¯æŒåºåˆ—åŒ–ï¼Œèƒ½é€šè¿‡åºåˆ—åŒ–å»ä¼ è¾“**ã€‚

> **Arraylist å’Œ Vector çš„åŒºåˆ«**

- ArrayList æ˜¯ List çš„**ä¸»è¦å®ç°ç±»**ï¼Œåº•å±‚ä½¿ç”¨ Object[ ]å­˜å‚¨ï¼Œé€‚ç”¨äºé¢‘ç¹çš„æŸ¥æ‰¾å·¥ä½œï¼Œ**çº¿ç¨‹ä¸å®‰å…¨** ï¼›
- Vector æ˜¯ List çš„**å¤è€å®ç°ç±»**ï¼Œåº•å±‚ä½¿ç”¨ Object[ ]å­˜å‚¨ï¼Œ**çº¿ç¨‹å®‰å…¨çš„**ã€‚

> **ArrayList å’Œ LinkedListçš„åŒºåˆ«**

- **1. æ˜¯å¦ä¿è¯çº¿ç¨‹å®‰å…¨:** ArrayList å’Œ LinkedList éƒ½æ˜¯ä¸åŒæ­¥çš„ï¼Œ**å³éƒ½ä¸ä¿è¯çº¿ç¨‹å®‰å…¨**ï¼›

- **2. åº•å±‚æ•°æ®ç»“æ„:**
  - `ArrayList` åº•å±‚ä¸º`Object`æ•°ç»„
  - `LinkedList` åº•å±‚ä¸ºåŒå‘é“¾è¡¨ï¼ŒJDK1.7ä¹‹å‰ä¸ºå¾ªç¯é“¾è¡¨ï¼ŒJDK1.7å–æ¶ˆäº†å¾ªç¯

- **3. æ’å…¥å’Œåˆ é™¤å…ƒç´ æ˜¯å¦å—ä½ç½®å½±å“**
  - `ArrayList`: **é‡‡ç”¨æ•°ç»„å­˜å‚¨ï¼Œæ‰€ä»¥æ’å…¥å’Œåˆ é™¤å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦å—å…ƒç´ ä½ç½®çš„å½±å“ã€‚** æ¯”å¦‚ï¼š**æ‰§è¡Œadd(E e)æ–¹æ³•çš„æ—¶å€™**ï¼Œ ArrayList ä¼šé»˜è®¤åœ¨å°†æŒ‡å®šçš„å…ƒç´ è¿½åŠ åˆ°æ­¤åˆ—è¡¨çš„æœ«å°¾ï¼Œè¿™ç§æƒ…å†µæ—¶é—´å¤æ‚åº¦å°±æ˜¯ O(1)ã€‚å¦‚æœè¦**åœ¨æŒ‡å®šä½ç½® i æ’å…¥å’Œåˆ é™¤å…ƒç´ çš„è¯ï¼ˆadd(int index, E element)ï¼‰**æ—¶é—´å¤æ‚åº¦å°±ä¸º O(n-i)ã€‚å› ä¸ºåœ¨è¿›è¡Œä¸Šè¿°æ“ä½œçš„æ—¶å€™é›†åˆä¸­ç¬¬ i å’Œç¬¬ i ä¸ªå…ƒç´ ä¹‹åçš„(n-i)ä¸ªå…ƒç´ éƒ½è¦æ‰§è¡Œå‘åä½/å‘å‰ç§»ä¸€ä½çš„æ“ä½œã€‚
  - `LinkedList`: LinkedList é‡‡ç”¨é“¾è¡¨å­˜å‚¨ï¼Œæ‰€ä»¥**å¯¹äºadd(E e)æ–¹æ³•çš„æ’å…¥**ï¼Œåˆ é™¤å…ƒç´ æ—¶é—´å¤æ‚åº¦ä¸å—å…ƒç´ ä½ç½®çš„å½±å“ï¼Œè¿‘ä¼¼ O(1);**å¦‚æœæ˜¯è¦åœ¨æŒ‡å®šä½ç½®iæ’å…¥å’Œåˆ é™¤å…ƒç´ çš„è¯ï¼ˆ(add(int index, E element)ï¼‰** æ—¶é—´å¤æ‚åº¦è¿‘ä¼¼ä¸ºo(n))å› ä¸ºéœ€è¦å…ˆç§»åŠ¨åˆ°æŒ‡å®šä½ç½®å†æ’å…¥ã€‚

- **4. æ˜¯å¦æ”¯æŒå¿«é€Ÿéšæœºè®¿é—®:**
  - `ArrayList`æ”¯æŒé«˜æ•ˆçš„éšæœºå…ƒç´ è®¿é—®ï¼Œå³å¯ä»¥é€šè¿‡get(int index)æ–¹æ³•è·å–å…ƒç´ å¯¹è±¡
  - `LinkedList` ä¸æ”¯æŒé«˜æ•ˆçš„éšæœºå…ƒç´ è®¿é—®
  
- **5. å†…å­˜ç©ºé—´å ç”¨:**
  - `ArrayList`: ç©ºé—´æµªè´¹ä¸»è¦ä½“ç°åœ¨åœ¨ list åˆ—è¡¨çš„ç»“å°¾ä¼šé¢„ç•™ä¸€å®šçš„å®¹é‡ç©ºé—´
  - `LinkedList` ç©ºé—´èŠ±è´¹åˆ™ä½“ç°åœ¨å®ƒçš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½éœ€è¦æ¶ˆè€—æ¯” ArrayList æ›´å¤šçš„ç©ºé—´ï¼ˆå› ä¸ºè¦å­˜æ”¾ç›´æ¥åç»§å’Œç›´æ¥å‰é©±ä»¥åŠæ•°æ®ï¼‰ã€‚

## 2.2 ArrayListæºç ä¸æ‰©å®¹æœºåˆ¶åˆ†æ

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d7eb6a67a5247fb9575953e62a9a49b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?)

### ArrayListæºç 

```java
package java.util;

import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;


public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * é»˜è®¤åˆå§‹å®¹é‡å¤§å°
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * ç©ºæ•°ç»„ï¼ˆç”¨äºç©ºå®ä¾‹ï¼‰ã€‚
     */
    private static final Object[] EMPTY_ELEMENTDATA = {};

    //ç”¨äºé»˜è®¤å¤§å°ç©ºå®ä¾‹çš„å…±äº«ç©ºæ•°ç»„å®ä¾‹ã€‚
    //æˆ‘ä»¬æŠŠå®ƒä»EMPTY_ELEMENTDATAæ•°ç»„ä¸­åŒºåˆ†å‡ºæ¥ï¼Œä»¥çŸ¥é“åœ¨æ·»åŠ ç¬¬ä¸€ä¸ªå…ƒç´ æ—¶å®¹é‡éœ€è¦å¢åŠ å¤šå°‘ã€‚
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    /**
     * ä¿å­˜ArrayListæ•°æ®çš„æ•°ç»„
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * ArrayList æ‰€åŒ…å«çš„å…ƒç´ ä¸ªæ•°
     */
    private int size;

    /**
     * å¸¦åˆå§‹å®¹é‡å‚æ•°çš„æ„é€ å‡½æ•°ï¼ˆç”¨æˆ·å¯ä»¥åœ¨åˆ›å»ºArrayListå¯¹è±¡æ—¶è‡ªå·±æŒ‡å®šé›†åˆçš„åˆå§‹å¤§å°ï¼‰
     */
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            //å¦‚æœä¼ å…¥çš„å‚æ•°å¤§äº0ï¼Œåˆ›å»ºinitialCapacityå¤§å°çš„æ•°ç»„
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            //å¦‚æœä¼ å…¥çš„å‚æ•°ç­‰äº0ï¼Œåˆ›å»ºç©ºæ•°ç»„
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            //å…¶ä»–æƒ…å†µï¼ŒæŠ›å‡ºå¼‚å¸¸
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }

    /**
     *é»˜è®¤æ— å‚æ„é€ å‡½æ•°
     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA ä¸º0.åˆå§‹åŒ–ä¸º10ï¼Œä¹Ÿå°±æ˜¯è¯´åˆå§‹å…¶å®æ˜¯ç©ºæ•°ç»„ å½“æ·»åŠ ç¬¬ä¸€ä¸ªå…ƒç´ çš„æ—¶å€™æ•°ç»„å®¹é‡æ‰å˜æˆ10
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    /**
     * æ„é€ ä¸€ä¸ªåŒ…å«æŒ‡å®šé›†åˆçš„å…ƒç´ çš„åˆ—è¡¨ï¼ŒæŒ‰ç…§å®ƒä»¬ç”±é›†åˆçš„è¿­ä»£å™¨è¿”å›çš„é¡ºåºã€‚
     */
    public ArrayList(Collection<? extends E> c) {
        //å°†æŒ‡å®šé›†åˆè½¬æ¢ä¸ºæ•°ç»„
        elementData = c.toArray();
        //å¦‚æœelementDataæ•°ç»„çš„é•¿åº¦ä¸ä¸º0
        if ((size = elementData.length) != 0) {
            // å¦‚æœelementDataä¸æ˜¯Objectç±»å‹æ•°æ®ï¼ˆc.toArrayå¯èƒ½è¿”å›çš„ä¸æ˜¯Objectç±»å‹çš„æ•°ç»„æ‰€ä»¥åŠ ä¸Šä¸‹é¢çš„è¯­å¥ç”¨äºåˆ¤æ–­ï¼‰
            if (elementData.getClass() != Object[].class)
                //å°†åŸæ¥ä¸æ˜¯Objectç±»å‹çš„elementDataæ•°ç»„çš„å†…å®¹ï¼Œèµ‹å€¼ç»™æ–°çš„Objectç±»å‹çš„elementDataæ•°ç»„
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // å…¶ä»–æƒ…å†µï¼Œç”¨ç©ºæ•°ç»„ä»£æ›¿
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }

    /**
     * ä¿®æ”¹è¿™ä¸ªArrayListå®ä¾‹çš„å®¹é‡æ˜¯åˆ—è¡¨çš„å½“å‰å¤§å°ã€‚ åº”ç”¨ç¨‹åºå¯ä»¥ä½¿ç”¨æ­¤æ“ä½œæ¥æœ€å°åŒ–ArrayListå®ä¾‹çš„å­˜å‚¨ã€‚
     */
    public void trimToSize() {
        modCount++;
        if (size < elementData.length) {
            elementData = (size == 0)
              ? EMPTY_ELEMENTDATA
              : Arrays.copyOf(elementData, size);
        }
    }

//ä¸‹é¢æ˜¯ArrayListçš„æ‰©å®¹æœºåˆ¶
//ArrayListçš„æ‰©å®¹æœºåˆ¶æé«˜äº†æ€§èƒ½ï¼Œå¦‚æœæ¯æ¬¡åªæ‰©å……ä¸€ä¸ªï¼Œ
//é‚£ä¹ˆé¢‘ç¹çš„æ’å…¥ä¼šå¯¼è‡´é¢‘ç¹çš„æ‹·è´ï¼Œé™ä½æ€§èƒ½ï¼Œè€ŒArrayListçš„æ‰©å®¹æœºåˆ¶é¿å…äº†è¿™ç§æƒ…å†µã€‚
    /**
     * å¦‚æœ‰å¿…è¦ï¼Œå¢åŠ æ­¤ArrayListå®ä¾‹çš„å®¹é‡ï¼Œä»¥ç¡®ä¿å®ƒè‡³å°‘èƒ½å®¹çº³å…ƒç´ çš„æ•°é‡
     * @param   minCapacity   æ‰€éœ€çš„æœ€å°å®¹é‡
     */
    public void ensureCapacity(int minCapacity) {
        //å¦‚æœæ˜¯trueï¼ŒminExpandçš„å€¼ä¸º0ï¼Œå¦‚æœæ˜¯false,minExpandçš„å€¼ä¸º10
        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            // any size if not default element table
            ? 0
            // larger than default for default empty table. It's already
            // supposed to be at default size.
            : DEFAULT_CAPACITY;
        //å¦‚æœæœ€å°å®¹é‡å¤§äºå·²æœ‰çš„æœ€å¤§å®¹é‡
        if (minCapacity > minExpand) {
            ensureExplicitCapacity(minCapacity);
        }
    }
   //1.å¾—åˆ°æœ€å°æ‰©å®¹é‡
   //2.é€šè¿‡æœ€å°å®¹é‡æ‰©å®¹
    private void ensureCapacityInternal(int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
              // è·å–â€œé»˜è®¤çš„å®¹é‡â€å’Œâ€œä¼ å…¥å‚æ•°â€ä¸¤è€…ä¹‹é—´çš„æœ€å¤§å€¼
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);
    }
  //åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹
    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            //è°ƒç”¨growæ–¹æ³•è¿›è¡Œæ‰©å®¹ï¼Œè°ƒç”¨æ­¤æ–¹æ³•ä»£è¡¨å·²ç»å¼€å§‹æ‰©å®¹äº†
            grow(minCapacity);
    }

    /**
     * è¦åˆ†é…çš„æœ€å¤§æ•°ç»„å¤§å°
     */
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /**
     * ArrayListæ‰©å®¹çš„æ ¸å¿ƒæ–¹æ³•ã€‚
     */
    private void grow(int minCapacity) {
        // oldCapacityä¸ºæ—§å®¹é‡ï¼ŒnewCapacityä¸ºæ–°å®¹é‡
        int oldCapacity = elementData.length;
        //å°†oldCapacity å³ç§»ä¸€ä½ï¼Œå…¶æ•ˆæœç›¸å½“äºoldCapacity /2ï¼Œ
        //æˆ‘ä»¬çŸ¥é“ä½è¿ç®—çš„é€Ÿåº¦è¿œè¿œå¿«äºæ•´é™¤è¿ç®—ï¼Œæ•´å¥è¿ç®—å¼çš„ç»“æœå°±æ˜¯å°†æ–°å®¹é‡æ›´æ–°ä¸ºæ—§å®¹é‡çš„1.5å€ï¼Œ
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        //ç„¶åæ£€æŸ¥æ–°å®¹é‡æ˜¯å¦å¤§äºæœ€å°éœ€è¦å®¹é‡ï¼Œè‹¥è¿˜æ˜¯å°äºæœ€å°éœ€è¦å®¹é‡ï¼Œé‚£ä¹ˆå°±æŠŠæœ€å°éœ€è¦å®¹é‡å½“ä½œæ•°ç»„çš„æ–°å®¹é‡ï¼Œ
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        //å†æ£€æŸ¥æ–°å®¹é‡æ˜¯å¦è¶…å‡ºäº†ArrayListæ‰€å®šä¹‰çš„æœ€å¤§å®¹é‡ï¼Œ
        //è‹¥è¶…å‡ºäº†ï¼Œåˆ™è°ƒç”¨hugeCapacity()æ¥æ¯”è¾ƒminCapacityå’Œ MAX_ARRAY_SIZEï¼Œ
        //å¦‚æœminCapacityå¤§äºMAX_ARRAY_SIZEï¼Œåˆ™æ–°å®¹é‡åˆ™ä¸ºInterger.MAX_VALUEï¼Œå¦åˆ™ï¼Œæ–°å®¹é‡å¤§å°åˆ™ä¸º MAX_ARRAY_SIZEã€‚
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    //æ¯”è¾ƒminCapacityå’Œ MAX_ARRAY_SIZE
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }

    /**
     *è¿”å›æ­¤åˆ—è¡¨ä¸­çš„å…ƒç´ æ•°ã€‚
     */
    public int size() {
        return size;
    }

    /**
     * å¦‚æœæ­¤åˆ—è¡¨ä¸åŒ…å«å…ƒç´ ï¼Œåˆ™è¿”å› true ã€‚
     */
    public boolean isEmpty() {
        //æ³¨æ„=å’Œ==çš„åŒºåˆ«
        return size == 0;
    }

    /**
     * å¦‚æœæ­¤åˆ—è¡¨åŒ…å«æŒ‡å®šçš„å…ƒç´ ï¼Œåˆ™è¿”å›true ã€‚
     */
    public boolean contains(Object o) {
        //indexOf()æ–¹æ³•ï¼šè¿”å›æ­¤åˆ—è¡¨ä¸­æŒ‡å®šå…ƒç´ çš„é¦–æ¬¡å‡ºç°çš„ç´¢å¼•ï¼Œå¦‚æœæ­¤åˆ—è¡¨ä¸åŒ…å«æ­¤å…ƒç´ ï¼Œåˆ™ä¸º-1
        return indexOf(o) >= 0;
    }

    /**
     *è¿”å›æ­¤åˆ—è¡¨ä¸­æŒ‡å®šå…ƒç´ çš„é¦–æ¬¡å‡ºç°çš„ç´¢å¼•ï¼Œå¦‚æœæ­¤åˆ—è¡¨ä¸åŒ…å«æ­¤å…ƒç´ ï¼Œåˆ™ä¸º-1
     */
    public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i < size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = 0; i < size; i++)
                //equals()æ–¹æ³•æ¯”è¾ƒ
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    /**
     * è¿”å›æ­¤åˆ—è¡¨ä¸­æŒ‡å®šå…ƒç´ çš„æœ€åä¸€æ¬¡å‡ºç°çš„ç´¢å¼•ï¼Œå¦‚æœæ­¤åˆ—è¡¨ä¸åŒ…å«å…ƒç´ ï¼Œåˆ™è¿”å›-1ã€‚.
     */
    public int lastIndexOf(Object o) {
        if (o == null) {
            for (int i = size-1; i >= 0; i--)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = size-1; i >= 0; i--)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    /**
     * è¿”å›æ­¤ArrayListå®ä¾‹çš„æµ…æ‹·è´ã€‚ ï¼ˆå…ƒç´ æœ¬èº«ä¸è¢«å¤åˆ¶ã€‚ï¼‰
     */
    public Object clone() {
        try {
            ArrayList<?> v = (ArrayList<?>) super.clone();
            //Arrays.copyOfåŠŸèƒ½æ˜¯å®ç°æ•°ç»„çš„å¤åˆ¶ï¼Œè¿”å›å¤åˆ¶åçš„æ•°ç»„ã€‚å‚æ•°æ˜¯è¢«å¤åˆ¶çš„æ•°ç»„å’Œå¤åˆ¶çš„é•¿åº¦
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;
            return v;
        } catch (CloneNotSupportedException e) {
            // è¿™ä¸åº”è¯¥å‘ç”Ÿï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯å¯ä»¥å…‹éš†çš„
            throw new InternalError(e);
        }
    }

    /**
     *ä»¥æ­£ç¡®çš„é¡ºåºï¼ˆä»ç¬¬ä¸€ä¸ªåˆ°æœ€åä¸€ä¸ªå…ƒç´ ï¼‰è¿”å›ä¸€ä¸ªåŒ…å«æ­¤åˆ—è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„æ•°ç»„ã€‚
     *è¿”å›çš„æ•°ç»„å°†æ˜¯â€œå®‰å…¨çš„â€ï¼Œå› ä¸ºè¯¥åˆ—è¡¨ä¸ä¿ç•™å¯¹å®ƒçš„å¼•ç”¨ã€‚ ï¼ˆæ¢å¥è¯è¯´ï¼Œè¿™ä¸ªæ–¹æ³•å¿…é¡»åˆ†é…ä¸€ä¸ªæ–°çš„æ•°ç»„ï¼‰ã€‚
     *å› æ­¤ï¼Œè°ƒç”¨è€…å¯ä»¥è‡ªç”±åœ°ä¿®æ”¹è¿”å›çš„æ•°ç»„ã€‚ æ­¤æ–¹æ³•å……å½“åŸºäºé˜µåˆ—å’ŒåŸºäºé›†åˆçš„APIä¹‹é—´çš„æ¡¥æ¢ã€‚
     */
    public Object[] toArray() {
        return Arrays.copyOf(elementData, size);
    }

    /**
     * ä»¥æ­£ç¡®çš„é¡ºåºè¿”å›ä¸€ä¸ªåŒ…å«æ­¤åˆ—è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„æ•°ç»„ï¼ˆä»ç¬¬ä¸€ä¸ªåˆ°æœ€åä¸€ä¸ªå…ƒç´ ï¼‰;
     *è¿”å›çš„æ•°ç»„çš„è¿è¡Œæ—¶ç±»å‹æ˜¯æŒ‡å®šæ•°ç»„çš„è¿è¡Œæ—¶ç±»å‹ã€‚ å¦‚æœåˆ—è¡¨é€‚åˆæŒ‡å®šçš„æ•°ç»„ï¼Œåˆ™è¿”å›å…¶ä¸­ã€‚
     *å¦åˆ™ï¼Œå°†ä¸ºæŒ‡å®šæ•°ç»„çš„è¿è¡Œæ—¶ç±»å‹å’Œæ­¤åˆ—è¡¨çš„å¤§å°åˆ†é…ä¸€ä¸ªæ–°æ•°ç»„ã€‚
     *å¦‚æœåˆ—è¡¨é€‚ç”¨äºæŒ‡å®šçš„æ•°ç»„ï¼Œå…¶ä½™ç©ºé—´ï¼ˆå³æ•°ç»„çš„åˆ—è¡¨æ•°é‡å¤šäºæ­¤å…ƒç´ ï¼‰ï¼Œåˆ™ç´§è·Ÿåœ¨é›†åˆç»“æŸåçš„æ•°ç»„ä¸­çš„å…ƒç´ è®¾ç½®ä¸ºnull ã€‚
     *ï¼ˆè¿™ä»…åœ¨è°ƒç”¨è€…çŸ¥é“åˆ—è¡¨ä¸åŒ…å«ä»»ä½•ç©ºå…ƒç´ çš„æƒ…å†µä¸‹æ‰èƒ½ç¡®å®šåˆ—è¡¨çš„é•¿åº¦ã€‚ï¼‰
     */
    @SuppressWarnings("unchecked")
    public <T> T[] toArray(T[] a) {
        if (a.length < size)
            // æ–°å»ºä¸€ä¸ªè¿è¡Œæ—¶ç±»å‹çš„æ•°ç»„ï¼Œä½†æ˜¯ArrayListæ•°ç»„çš„å†…å®¹
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
            //è°ƒç”¨Systemæä¾›çš„arraycopy()æ–¹æ³•å®ç°æ•°ç»„ä¹‹é—´çš„å¤åˆ¶
        System.arraycopy(elementData, 0, a, 0, size);
        if (a.length > size)
            a[size] = null;
        return a;
    }

    // Positional Access Operations

    @SuppressWarnings("unchecked")
    E elementData(int index) {
        return (E) elementData[index];
    }

    /**
     * è¿”å›æ­¤åˆ—è¡¨ä¸­æŒ‡å®šä½ç½®çš„å…ƒç´ ã€‚
     */
    public E get(int index) {
        rangeCheck(index);

        return elementData(index);
    }

    /**
     * ç”¨æŒ‡å®šçš„å…ƒç´ æ›¿æ¢æ­¤åˆ—è¡¨ä¸­æŒ‡å®šä½ç½®çš„å…ƒç´ ã€‚
     */
    public E set(int index, E element) {
        //å¯¹indexè¿›è¡Œç•Œé™æ£€æŸ¥
        rangeCheck(index);

        E oldValue = elementData(index);
        elementData[index] = element;
        //è¿”å›åŸæ¥åœ¨è¿™ä¸ªä½ç½®çš„å…ƒç´ 
        return oldValue;
    }

    /**
     * å°†æŒ‡å®šçš„å…ƒç´ è¿½åŠ åˆ°æ­¤åˆ—è¡¨çš„æœ«å°¾ã€‚
     */
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //è¿™é‡Œçœ‹åˆ°ArrayListæ·»åŠ å…ƒç´ çš„å®è´¨å°±ç›¸å½“äºä¸ºæ•°ç»„èµ‹å€¼
        elementData[size++] = e;
        return true;
    }

    /**
     * åœ¨æ­¤åˆ—è¡¨ä¸­çš„æŒ‡å®šä½ç½®æ’å…¥æŒ‡å®šçš„å…ƒç´ ã€‚
     *å…ˆè°ƒç”¨ rangeCheckForAdd å¯¹indexè¿›è¡Œç•Œé™æ£€æŸ¥ï¼›ç„¶åè°ƒç”¨ ensureCapacityInternal æ–¹æ³•ä¿è¯capacityè¶³å¤Ÿå¤§ï¼›
     *å†å°†ä»indexå¼€å§‹ä¹‹åçš„æ‰€æœ‰æˆå‘˜åç§»ä¸€ä¸ªä½ç½®ï¼›å°†elementæ’å…¥indexä½ç½®ï¼›æœ€åsizeåŠ 1ã€‚
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //arraycopy()è¿™ä¸ªå®ç°æ•°ç»„ä¹‹é—´å¤åˆ¶çš„æ–¹æ³•ä¸€å®šè¦çœ‹ä¸€ä¸‹ï¼Œä¸‹é¢å°±ç”¨åˆ°äº†arraycopy()æ–¹æ³•å®ç°æ•°ç»„è‡ªå·±å¤åˆ¶è‡ªå·±
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }

    /**
     * åˆ é™¤è¯¥åˆ—è¡¨ä¸­æŒ‡å®šä½ç½®çš„å…ƒç´ ã€‚ å°†ä»»ä½•åç»­å…ƒç´ ç§»åŠ¨åˆ°å·¦ä¾§ï¼ˆä»å…¶ç´¢å¼•ä¸­å‡å»ä¸€ä¸ªå…ƒç´ ï¼‰ã€‚
     */
    public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
      //ä»åˆ—è¡¨ä¸­åˆ é™¤çš„å…ƒç´ 
        return oldValue;
    }

    /**
     * ä»åˆ—è¡¨ä¸­åˆ é™¤æŒ‡å®šå…ƒç´ çš„ç¬¬ä¸€ä¸ªå‡ºç°ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ã€‚ å¦‚æœåˆ—è¡¨ä¸åŒ…å«è¯¥å…ƒç´ ï¼Œåˆ™å®ƒä¸ä¼šæ›´æ”¹ã€‚
     *è¿”å›trueï¼Œå¦‚æœæ­¤åˆ—è¡¨åŒ…å«æŒ‡å®šçš„å…ƒç´ 
     */
    public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }

    /*
     * Private remove method that skips bounds checking and does not
     * return the value removed.
     */
    private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }

    /**
     * ä»åˆ—è¡¨ä¸­åˆ é™¤æ‰€æœ‰å…ƒç´ ã€‚
     */
    public void clear() {
        modCount++;

        // æŠŠæ•°ç»„ä¸­æ‰€æœ‰çš„å…ƒç´ çš„å€¼è®¾ä¸ºnull
        for (int i = 0; i < size; i++)
            elementData[i] = null;

        size = 0;
    }

    /**
     * æŒ‰æŒ‡å®šé›†åˆçš„Iteratorè¿”å›çš„é¡ºåºå°†æŒ‡å®šé›†åˆä¸­çš„æ‰€æœ‰å…ƒç´ è¿½åŠ åˆ°æ­¤åˆ—è¡¨çš„æœ«å°¾ã€‚
     */
    public boolean addAll(Collection<? extends E> c) {
        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    }

    /**
     * å°†æŒ‡å®šé›†åˆä¸­çš„æ‰€æœ‰å…ƒç´ æ’å…¥åˆ°æ­¤åˆ—è¡¨ä¸­ï¼Œä»æŒ‡å®šçš„ä½ç½®å¼€å§‹ã€‚
     */
    public boolean addAll(int index, Collection<? extends E> c) {
        rangeCheckForAdd(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount

        int numMoved = size - index;
        if (numMoved > 0)
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);

        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }

    /**
     * ä»æ­¤åˆ—è¡¨ä¸­åˆ é™¤æ‰€æœ‰ç´¢å¼•ä¸ºfromIndex ï¼ˆå«ï¼‰å’ŒtoIndexä¹‹é—´çš„å…ƒç´ ã€‚
     *å°†ä»»ä½•åç»­å…ƒç´ ç§»åŠ¨åˆ°å·¦ä¾§ï¼ˆå‡å°‘å…¶ç´¢å¼•ï¼‰ã€‚
     */
    protected void removeRange(int fromIndex, int toIndex) {
        modCount++;
        int numMoved = size - toIndex;
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                         numMoved);

        // clear to let GC do its work
        int newSize = size - (toIndex-fromIndex);
        for (int i = newSize; i < size; i++) {
            elementData[i] = null;
        }
        size = newSize;
    }

    /**
     * æ£€æŸ¥ç»™å®šçš„ç´¢å¼•æ˜¯å¦åœ¨èŒƒå›´å†…ã€‚
     */
    private void rangeCheck(int index) {
        if (index >= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * addå’ŒaddAllä½¿ç”¨çš„rangeCheckçš„ä¸€ä¸ªç‰ˆæœ¬
     */
    private void rangeCheckForAdd(int index) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * è¿”å›IndexOutOfBoundsExceptionç»†èŠ‚ä¿¡æ¯
     */
    private String outOfBoundsMsg(int index) {
        return "Index: "+index+", Size: "+size;
    }

    /**
     * ä»æ­¤åˆ—è¡¨ä¸­åˆ é™¤æŒ‡å®šé›†åˆä¸­åŒ…å«çš„æ‰€æœ‰å…ƒç´ ã€‚
     */
    public boolean removeAll(Collection<?> c) {
        Objects.requireNonNull(c);
        //å¦‚æœæ­¤åˆ—è¡¨è¢«ä¿®æ”¹åˆ™è¿”å›true
        return batchRemove(c, false);
    }

    /**
     * ä»…ä¿ç•™æ­¤åˆ—è¡¨ä¸­åŒ…å«åœ¨æŒ‡å®šé›†åˆä¸­çš„å…ƒç´ ã€‚
     *æ¢å¥è¯è¯´ï¼Œä»æ­¤åˆ—è¡¨ä¸­åˆ é™¤å…¶ä¸­ä¸åŒ…å«åœ¨æŒ‡å®šé›†åˆä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚
     */
    public boolean retainAll(Collection<?> c) {
        Objects.requireNonNull(c);
        return batchRemove(c, true);
    }


    /**
     * ä»åˆ—è¡¨ä¸­çš„æŒ‡å®šä½ç½®å¼€å§‹ï¼Œè¿”å›åˆ—è¡¨ä¸­çš„å…ƒç´ ï¼ˆæŒ‰æ­£ç¡®é¡ºåºï¼‰çš„åˆ—è¡¨è¿­ä»£å™¨ã€‚
     *æŒ‡å®šçš„ç´¢å¼•è¡¨ç¤ºåˆå§‹è°ƒç”¨å°†è¿”å›çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºnext ã€‚ åˆå§‹è°ƒç”¨previouså°†è¿”å›æŒ‡å®šç´¢å¼•å‡1çš„å…ƒç´ ã€‚
     *è¿”å›çš„åˆ—è¡¨è¿­ä»£å™¨æ˜¯fail-fast ã€‚
     */
    public ListIterator<E> listIterator(int index) {
        if (index < 0 || index > size)
            throw new IndexOutOfBoundsException("Index: "+index);
        return new ListItr(index);
    }

    /**
     *è¿”å›åˆ—è¡¨ä¸­çš„åˆ—è¡¨è¿­ä»£å™¨ï¼ˆæŒ‰é€‚å½“çš„é¡ºåºï¼‰ã€‚
     *è¿”å›çš„åˆ—è¡¨è¿­ä»£å™¨æ˜¯fail-fast ã€‚
     */
    public ListIterator<E> listIterator() {
        return new ListItr(0);
    }

    /**
     *ä»¥æ­£ç¡®çš„é¡ºåºè¿”å›è¯¥åˆ—è¡¨ä¸­çš„å…ƒç´ çš„è¿­ä»£å™¨ã€‚
     *è¿”å›çš„è¿­ä»£å™¨æ˜¯fail-fast ã€‚
     */
    public Iterator<E> iterator() {
        return new Itr();
    }

```

### ArrayList çš„æ„é€ å‡½æ•°

ï¼ˆJDK8ï¼‰ArrayList æœ‰ä¸‰ç§æ–¹å¼æ¥åˆå§‹åŒ–ï¼Œæ„é€ æ–¹æ³•æºç å¦‚ä¸‹ï¼š

```java

   /**
     * é»˜è®¤åˆå§‹å®¹é‡å¤§å°
     */
    private static final int DEFAULT_CAPACITY = 10;


    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    /**
     *é»˜è®¤æ„é€ å‡½æ•°ï¼Œä½¿ç”¨åˆå§‹å®¹é‡10æ„é€ ä¸€ä¸ªç©ºåˆ—è¡¨(æ— å‚æ•°æ„é€ )
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    /**
     * å¸¦åˆå§‹å®¹é‡å‚æ•°çš„æ„é€ å‡½æ•°ã€‚ï¼ˆç”¨æˆ·è‡ªå·±æŒ‡å®šå®¹é‡ï¼‰
     */
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {//åˆå§‹å®¹é‡å¤§äº0
            //åˆ›å»ºinitialCapacityå¤§å°çš„æ•°ç»„
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {//åˆå§‹å®¹é‡ç­‰äº0
            //åˆ›å»ºç©ºæ•°ç»„
            this.elementData = EMPTY_ELEMENTDATA;
        } else {//åˆå§‹å®¹é‡å°äº0ï¼ŒæŠ›å‡ºå¼‚å¸¸
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }


   /**
    *æ„é€ åŒ…å«æŒ‡å®šcollectionå…ƒç´ çš„åˆ—è¡¨ï¼Œè¿™äº›å…ƒç´ åˆ©ç”¨è¯¥é›†åˆçš„è¿­ä»£å™¨æŒ‰é¡ºåºè¿”å›
    *å¦‚æœæŒ‡å®šçš„é›†åˆä¸ºnullï¼Œthrows NullPointerExceptionã€‚
    */
     public ArrayList(Collection<? extends E> c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
```

- ä»¥æ— å‚æ•°æ„é€ æ–¹æ³•åˆ›å»º ArrayList æ—¶ï¼Œå®é™…ä¸Š**åˆå§‹åŒ–èµ‹å€¼çš„æ˜¯ä¸€ä¸ªç©ºæ•°ç»„**ã€‚å½“çœŸæ­£å¯¹æ•°ç»„è¿›è¡Œæ·»åŠ å…ƒç´ æ“ä½œæ—¶ï¼Œæ‰çœŸæ­£åˆ†é…å®¹é‡ã€‚**å³å‘æ•°ç»„ä¸­æ·»åŠ ç¬¬ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œæ•°ç»„å®¹é‡æ‰©ä¸º 10ã€‚**
- JDK1.6 åˆå§‹åŒ–æ— å‚æ„é€ çš„ ArrayList å¯¹è±¡æ—¶ï¼Œç›´æ¥åˆ›å»ºäº†é•¿åº¦æ˜¯ 10 çš„ Object[] æ•°ç»„ elementData 

### åˆ†æArrayListæ‰©å®¹æœºåˆ¶

#### add æ–¹æ³•

```java
/**
 * æ·»åŠ å…ƒç´ æ–¹æ³•
 * åœ¨æ·»åŠ å…ƒç´ å‰ä¼šå…ˆè°ƒç”¨ ensureCapacityInternal() æ–¹æ³•åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹
 * ç„¶åå†å°†å…ƒç´ æ·»åŠ åˆ°æ•°ç»„çš„å°¾éƒ¨
 */ 
public boolean add(E e) {
    // åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹æ–¹æ³•ï¼Œæ³¨æ„è¿™é‡Œä¼ çš„å‚æ•°æ˜¯ å…ƒç´ ä¸ªæ•° + 1
    // 1 ä»£è¡¨çš„æ˜¯æ–°æ·»åŠ çš„å…ƒç´ 
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    // è¿½åŠ çš„æ•°ç»„çš„å°¾éƒ¨
    elementData[size++] = e;
    return true;
}
```

#### ensureCapacityInternalæ–¹æ³•

```java
/**
 * å…ˆè°ƒç”¨ calculateCapacity åˆ¤æ–­æ˜¯å¦æ˜¯ç©ºæ•°ç»„
 * å†è°ƒç”¨ ensureExplicitCapacity() æ–¹æ³•è¿›è¡Œè¿›ä¸€æ­¥å¤„ç†
 */
private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}

/**
 * åˆ¤æ–­æ˜¯å¦æ˜¯ç©ºæ•°ç»„ï¼Œå¦‚æœæ˜¯ç©ºæ•°ç»„ï¼Œåˆ™æ¯”è¾ƒé»˜è®¤å®¹é‡ 10 å’Œ å…ƒç´ ä¸ªæ•° + 1 çš„å¤§å°
 * äºŒè€…å–æœ€å¤§å€¼ï¼Œç„¶åè¿”å›
 * å¾—åˆ°æœ€å°æ‰©å®¹é‡
 */
private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}
```

å½“ add è¿›ç¬¬ä¸€ä¸ªå…ƒç´ æ—¶ï¼ŒminCapacity ä¸º 1ï¼ŒDEFAULT_CAPACITY ä¸º 10ï¼Œ10 > 1ï¼Œæ‰€ä»¥è¿”å› 10

#### ensureExplicitCapacity æ–¹æ³•

```java
/**
 * åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹
 * çœŸæ­£çš„æ‰©å®¹æ–¹æ³•æ˜¯ grow(minCapacity);
 */
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    // å¦‚æœåŸæ¥çš„ elementData æ•°ç»„é•¿åº¦ å°äºæœ€å°å®¹é‡
    // åˆ™è°ƒç”¨ grow() æ–¹æ³•è¿›è¡Œæ‰©å®¹ï¼Œåä¹‹ä¸åšä»»ä½•æ“ä½œ
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}
```

#### growæ–¹æ³•

```java
/**
 * æ‰©å®¹æ–¹æ³•
 */
private void grow(int minCapacity) {
    // overflow-conscious code
    // è®°å½•åŸæ¥æ•°ç»„çš„é•¿åº¦
    int oldCapacity = elementData.length;
    // æ–°çš„å®¹é‡å°±æ˜¯åŸæ¥æ•°ç»„é•¿åº¦çš„ 1.5 å€ï¼Œè¿™é‡Œä½¿ç”¨å³ç§»æ•ˆç‡æ›´é«˜
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    // å¦‚æœæ–°çš„å®¹é‡æ¯”æœ€å°å®¹é‡å°ï¼Œå°±ç›´æ¥æŠŠæœ€å°å®¹é‡èµ‹å€¼ç»™æ–°çš„å®¹é‡
    // å¦‚æœä¸æ˜¯ï¼Œå°±ä¸ç”¨å˜åŒ–
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    // å¦‚æœè¶…å‡ºä¸´ç•Œå€¼ï¼Œå°±è°ƒç”¨ hugeCapacity æ–¹æ³•
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    // è¿›è¡Œæ‰©å®¹
    elementData = Arrays.copyOf(elementData, newCapacity);
}

// ä¸´ç•Œå€¼
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

```

#### hugeCapacityæ–¹æ³•

```java
/**
 * 1 å¦‚æœ minCapacity ä¸ºè´Ÿæ•°å°±æŠ›å‡ºå¼‚å¸¸
 * 2 å¦‚æœæ¯”ä¸´ç•Œå€¼å¤§ï¼Œå°±ç›´æ¥èµ‹å€¼ Integer.MAX_VALUE
 * 3 å¦‚æœæ¯”ä¸´ç•Œå€¼å°ï¼Œå°±ç›´æ¥èµ‹å€¼ ä¸´ç•Œå€¼
 */
private static int hugeCapacity(int minCapacity) {
    // å› ä¸ºè´Ÿè´Ÿå¾—æ­£ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­ä¸€ä¸‹
    if (minCapacity < 0) // overflow
        throw new OutOfMemoryError();
    return (minCapacity > MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}
```

#### æµç¨‹åˆ†æ

> **åˆ†æå¦‚ä¸‹ä¸¤è¡Œä»£ç **

```java
List list = new ArrayList<>();
list.add("1");
```

> **åˆ†æ**

- 1ã€ç¬¬ä¸€è¡Œè°ƒç”¨ ArrayList çš„æ— å‚æ„é€ å‡½æ•°ï¼Œç›´æ¥èµ‹å€¼ç»™ elementData ä¸€ä¸ªé»˜è®¤çš„ç©ºæ•°ç»„ {}ï¼Œæ•°ç»„é•¿åº¦ä¸º 0ã€‚
- 2ã€ç¬¬äºŒè¡Œæ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼š
  - ï¼ˆ1ï¼‰è¿›å…¥ add æ–¹æ³•å†…ï¼Œé¦–å…ˆè°ƒç”¨ ensureCapacityInternal æ–¹æ³•ã€‚
  - ï¼ˆ2ï¼‰è¿›å…¥ ensureCapacityInternal æ–¹æ³•å†…ï¼Œè°ƒç”¨ calculatCapacity æ–¹æ³•ï¼Œç„¶åå†è°ƒç”¨ ensureExplicitCapacity æ–¹æ³•ã€‚
  - ï¼ˆ3ï¼‰è¿›å…¥ calculatCapacity æ–¹æ³•å†…ï¼Œè¿™ä¸ªæ–¹æ³•ä¸»è¦æ˜¯åˆ¤æ–­æ˜¯å¦æ˜¯ç©ºæ•°ç»„ï¼Œå¦‚æœæ˜¯ç©ºæ•°ç»„ï¼Œå°±æ¯”è¾ƒé»˜è®¤å®¹é‡ 10 å’Œ æœ€å°å®¹é‡ çš„å¤§å°ï¼Œå–äºŒè€…æœ€å¤§å€¼ï¼›å¦‚æœä¸æ˜¯ç©ºæ•°ç»„ï¼Œåˆ™ç›´æ¥è¿”å›æœ€å°å®¹é‡ï¼Œè¿™é‡Œè¿”å› 10ã€‚
  - ï¼ˆ4ï¼‰è¿›å…¥ ensureExplicitCapacity  æ–¹æ³•å†…ï¼Œè¿™ä¸ªæ–¹æ³•çš„ä¸»è¦ä½œç”¨æ˜¯åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹ï¼Œå¦‚æœæœ€å°å®¹é‡ - elementData æ•°ç»„é•¿åº¦ > 0ï¼Œè¯´æ˜æœ€å°å®¹é‡å¤§äºæ•°ç»„é•¿åº¦ï¼Œæ­¤æ—¶è°ƒç”¨ grow æ–¹æ³•è¿›è¡Œæ‰©å®¹ã€‚å¾ˆæ˜æ˜¾ï¼Œè¿™é‡Œçš„ æœ€å°å®¹é‡ä¸º 10ï¼Œæ•°ç»„é•¿åº¦ä¸º 0ï¼Œéœ€è¦è°ƒç”¨ grow æ–¹æ³•è¿›è¡Œæ‰©å®¹ã€‚
  - ï¼ˆ5ï¼‰è¿›å…¥ grow æ–¹æ³•å†…ï¼Œè¿™ä¸ªæ–¹æ³•å°±æ˜¯å®é™…ä¸Šçš„æ‰©å®¹æ–¹æ³•ã€‚æ–°å®šä¹‰ä¸€ä¸ªå˜é‡ oldCapacity å­˜å‚¨åŸæ¥æ•°ç»„çš„é•¿åº¦ï¼Œå†å®šä¹‰ä¸€ä¸ªå˜é‡ newCapacity = oldCapacity + (oldCapacity >> 1)ï¼Œå°±æ˜¯ä¸ºåŸæ¥æ•°ç»„é•¿åº¦çš„ 1.5 å€ï¼Œç„¶åå†åˆ¤æ–­ newCapacity - minCapacity æ˜¯å¦å°äº 0ï¼Œå°äº 0 åˆ™è¯´æ˜ newCapacity ä¸å¤Ÿï¼Œå°±ç›´æ¥æ‰§è¡Œ newCapacity = minCapacityï¼Œç„¶åå†åˆ¤æ–­æ˜¯å¦è¶…è¿‡ä¸´ç•Œå€¼ï¼Œæ²¡è¶…è¿‡å°±ç›´æ¥è°ƒç”¨ elementData = Arrays.copy(elementData, newCapacity)ï¼›è¿›è¡Œå®é™…ä¸Šçš„æ‰©å®¹ï¼ï¼ˆæ³¨ï¼šä¸´ç•Œå€¼è¿™é‡Œå¯ä»¥å»çœ‹ hugeCapacity æ–¹æ³•ï¼‰
  - ï¼ˆ6ï¼‰å›åˆ°æœ€å¼€å§‹çš„ add() æ–¹æ³•ï¼Œæ‰§è¡Œ elementData[size++] = e; return true;
  - ï¼ˆ7ï¼‰æ‰§è¡Œå®Œæˆã€‚

---

# ä¸‰ã€Set

## 3.1 å¸¸è§é¢è¯•é¢˜

### comparable å’Œ Comparator çš„åŒºåˆ«

- `comparable` æ¥å£å®é™…ä¸Šå‡ºè‡ª`java.lang`åŒ…ï¼Œå®ƒæœ‰ä¸€ä¸ªCompareTo(Obejct)æ–¹æ³•ç”¨æ¥æ’åº
- `comparator` æ¥å£å®é™…ä¸Šå‡ºè‡ª`java.util`åŒ…ï¼Œå®ƒæœ‰ä¸€ä¸ªcompare(Object obj1, Obejct obj2)æ–¹æ³•ç”¨æ¥æ’åº

ä¸€èˆ¬æˆ‘ä»¬éœ€è¦å¯¹ä¸€ä¸ªé›†åˆä½¿ç”¨è‡ªå®šä¹‰æ’åºæ—¶ï¼Œæˆ‘ä»¬å°±è¦é‡å†™`compareTo()`æ–¹æ³•æˆ–`compare()`æ–¹æ³•ï¼š

> ğŸ™‹â€â™‚ï¸ğŸŒ° 1

å½“æˆ‘ä»¬éœ€è¦å¯¹æŸä¸€ä¸ªé›†åˆå®ç°ä¸¤ç§æ’åºæ–¹å¼

æ¯”å¦‚ä¸€ä¸ª song å¯¹è±¡ä¸­çš„æ­Œåå’Œæ­Œæ‰‹ååˆ†åˆ«é‡‡ç”¨ä¸€ç§æ’åºæ–¹æ³•

- æ–¹æ³•ä¸€ï¼šå¯ä»¥é‡å†™compareTo()æ–¹æ³•å’Œä½¿ç”¨è‡ªåˆ¶çš„Comparatoræ–¹æ³•
  
- æ–¹æ³•äºŒï¼šä»¥ä¸¤ä¸ª Comparator æ¥å®ç°æ­Œåæ’åºå’Œæ­Œæ˜Ÿåæ’åºï¼Œç¬¬äºŒç§ä»£è¡¨æˆ‘ä»¬åªèƒ½ä½¿ç”¨ä¸¤ä¸ªå‚æ•°ç‰ˆçš„ Collections.sort()

> **Comparatorå®šåˆ¶æ’åº**

```java
ArrayList<Integer> arrayList = new ArrayList<Integer>();
arrayList.add(-1);
arrayList.add(3);
arrayList.add(3);
arrayList.add(-5);
arrayList.add(7);
arrayList.add(4);
arrayList.add(-9);
arrayList.add(-7);

System.out.println("åŸå§‹æ•°ç»„:");
System.out.println(arrayList);

// void reverse(List list)ï¼šåè½¬
Collections.reverse(arrayList);
System.out.println("Collections.reverse(arrayList):");
System.out.println(arrayList);

// void sort(List list),æŒ‰è‡ªç„¶æ’åºçš„å‡åºæ’åº
Collections.sort(arrayList);
System.out.println("Collections.sort(arrayList):");
System.out.println(arrayList);
// å®šåˆ¶æ’åºçš„ç”¨æ³•
Collections.sort(arrayList, new Comparator<Integer>() {

    @Override
    public int compare(Integer o1, Integer o2) {
        return o2.compareTo(o1);
    }
});
System.out.println("å®šåˆ¶æ’åºåï¼š");
System.out.println(arrayList);
```

**Output**

```java
åŸå§‹æ•°ç»„:
[-1, 3, 3, -5, 7, 4, -9, -7]
Collections.reverse(arrayList):
[-7, -9, 4, 7, -5, 3, 3, -1]
Collections.sort(arrayList):
[-9, -7, -5, -1, 3, 3, 4, 7]
å®šåˆ¶æ’åºåï¼š
[7, 4, 3, 3, -1, -5, -7, -9]
```

> **é‡å†™ compareTo æ–¹æ³•å®ç°æŒ‰å¹´é¾„æ¥æ’åº**

```java
// personå¯¹è±¡æ²¡æœ‰å®ç°Comparableæ¥å£ï¼Œæ‰€ä»¥å¿…é¡»å®ç°ï¼Œè¿™æ ·æ‰ä¸ä¼šå‡ºé”™ï¼Œæ‰å¯ä»¥ä½¿treemapä¸­çš„æ•°æ®æŒ‰é¡ºåºæ’åˆ—
// å‰é¢ä¸€ä¸ªä¾‹å­çš„Stringç±»å·²ç»é»˜è®¤å®ç°äº†Comparableæ¥å£ï¼Œè¯¦ç»†å¯ä»¥æŸ¥çœ‹Stringç±»çš„APIæ–‡æ¡£ï¼Œå¦å¤–å…¶ä»–
// åƒIntegerç±»ç­‰éƒ½å·²ç»å®ç°äº†Comparableæ¥å£ï¼Œæ‰€ä»¥ä¸éœ€è¦å¦å¤–å®ç°äº†
public  class Person implements Comparable<Person> {
    private String name;
    private int age;

    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    /**
     * Té‡å†™compareToæ–¹æ³•å®ç°æŒ‰å¹´é¾„æ¥æ’åº
     */
    @Override
    public int compareTo(Person o) {
        if (this.age > o.getAge()) {
            return 1;
        }
        if (this.age < o.getAge()) {
            return -1;
        }
        return 0;
    }
}
```

```java
public static void main(String[] args) {
    TreeMap<Person, String> pdata = new TreeMap<Person, String>();
    pdata.put(new Person("å¼ ä¸‰", 30), "zhangsan");
    pdata.put(new Person("æå››", 20), "lisi");
    pdata.put(new Person("ç‹äº”", 10), "wangwu");
    pdata.put(new Person("å°çº¢", 5), "xiaohong");
    // å¾—åˆ°keyçš„å€¼çš„åŒæ—¶å¾—åˆ°keyæ‰€å¯¹åº”çš„å€¼
    Set<Person> keys = pdata.keySet();
    for (Person key : keys) {
        System.out.println(key.getAge() + "-" + key.getName());

    }
}
```

**Output**

```java
5-å°çº¢
10-ç‹äº”
20-æå››
30-å¼ ä¸‰
```

### æ— åºæ€§å’Œä¸å¯é‡å¤æ€§çš„å«ä¹‰æ˜¯ä»€ä¹ˆ

- æ— åºæ€§ä¸ç­‰äºéšæœºæ€§ ï¼Œæ— åºæ€§æ˜¯æŒ‡å­˜å‚¨çš„æ•°æ®åœ¨åº•å±‚æ•°ç»„ä¸­å¹¶éæŒ‰ç…§æ•°ç»„ç´¢å¼•çš„é¡ºåºæ·»åŠ  ï¼Œè€Œæ˜¯æ ¹æ®æ•°æ®çš„å“ˆå¸Œå€¼å†³å®šçš„ã€‚
- ä¸å¯é‡å¤æ€§æ˜¯æŒ‡æ·»åŠ çš„å…ƒç´ æŒ‰ç…§ equals() åˆ¤æ–­æ—¶ ï¼Œè¿”å› falseï¼Œéœ€è¦åŒæ—¶é‡å†™ equals() æ–¹æ³•å’Œ hashCode() æ–¹æ³•ã€‚

### æ¯”è¾ƒ HashSetã€LinkedHashSet å’Œ TreeSet ä¸‰è€…çš„å¼‚åŒ

> **ç›¸åŒç‚¹**

ä¸‰è€…éƒ½æ˜¯`Set`æ¥å£çš„å®ç°ï¼Œéƒ½èƒ½ä¿è¯å…ƒç´ å”¯ä¸€ï¼Œå¹¶ä¸”éƒ½ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

> **ä¸åŒç‚¹**

- **åº•å±‚æ•°æ®ç»“æ„ä¸åŒ**
  - HashSet çš„åº•å±‚æ•°æ®ç»“æ„æ˜¯å“ˆå¸Œè¡¨ï¼ˆåŸºäº HashMap å®ç°ï¼‰ã€‚
  - LinkedHashSet çš„åº•å±‚æ•°æ®ç»“æ„æ˜¯**é“¾è¡¨å’Œå“ˆå¸Œè¡¨**ï¼Œå…ƒç´ çš„æ’å…¥å’Œå–å‡ºé¡ºåºæ»¡è¶³ FIFOã€‚
  - TreeSet åº•å±‚æ•°æ®ç»“æ„æ˜¯çº¢é»‘æ ‘ï¼Œå…ƒç´ æ˜¯æœ‰åºçš„ï¼Œæ’åºçš„æ–¹å¼æœ‰è‡ªç„¶æ’åºå’Œå®šåˆ¶æ’åºã€‚

- **åº”ç”¨åœºæ™¯ä¸åŒ**
  - Â·HashSet ç”¨äºä¸éœ€è¦ä¿è¯å…ƒç´ æ’å…¥å’Œå–å‡ºé¡ºåºçš„åœºæ™¯
  - LinkedHashSet ç”¨äºä¿è¯å…ƒç´ çš„æ’å…¥å’Œå–å‡ºé¡ºåºæ»¡è¶³ FIFO çš„åœºæ™¯
  - TreeSet ç”¨äºæ”¯æŒå¯¹å…ƒç´ è‡ªå®šä¹‰æ’åºè§„åˆ™çš„åœºæ™¯ã€‚

---

# å››ã€ Queue

## 4.1 Queueå¸¸è§é¢è¯•é¢˜

### Queueå’ŒDequeçš„åŒºåˆ«

> **Queue**

`Queue` æ˜¯**å•ç«¯é˜Ÿåˆ—**ï¼Œåªèƒ½ä»ä¸€ç«¯æ’å…¥å…ƒç´ ï¼Œå¦ä¸€ç«¯åˆ é™¤å…ƒç´ ï¼Œå®ç°ä¸Šä¸€èˆ¬éµå¾ª å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰ è§„åˆ™ã€‚

`Queue` æ‰©å±•äº† `Collection` çš„æ¥å£ï¼Œæ ¹æ® å› ä¸º**å®¹é‡é—®é¢˜è€Œå¯¼è‡´æ“ä½œå¤±è´¥åå¤„ç†æ–¹å¼çš„ä¸åŒ**å¯ä»¥åˆ†ä¸ºä¸¤ç±»æ–¹æ³•:

- ä¸€ç§åœ¨æ“ä½œå¤±è´¥åä¼šæŠ›å‡ºå¼‚å¸¸
- å¦ä¸€ç§åˆ™ä¼šè¿”å›ç‰¹æ®Šå€¼

| Queueæ¥å£    | æŠ›å‡ºå¼‚å¸¸  | è¿”å›ç‰¹æ®Šå€¼ |
| ------------ | --------- | ---------- |
| æ’å…¥é˜Ÿå°¾     | add(E e)  | offer(E e) |
| åˆ é™¤é˜Ÿé¦–     | remove()  | poll()     |
| æŸ¥è¯¢é˜Ÿé¦–å…ƒç´  | element() | peek()     |

> **Deque**

`Deque` æ˜¯**åŒç«¯é˜Ÿåˆ—**ï¼Œ**åœ¨é˜Ÿåˆ—çš„ä¸¤ç«¯å‡å¯ä»¥æ’å…¥æˆ–åˆ é™¤å…ƒç´ **ã€‚

Deque æ‰©å±•äº† Queue çš„æ¥å£, å¢åŠ äº†åœ¨é˜Ÿé¦–å’Œé˜Ÿå°¾è¿›è¡Œæ’å…¥å’Œåˆ é™¤çš„æ–¹æ³•ï¼ŒåŒæ ·æ ¹æ®å¤±è´¥åå¤„ç†æ–¹å¼çš„ä¸åŒåˆ†ä¸ºä¸¤ç±»ï¼š

| Deque æ¥å£   | æŠ›å‡ºå¼‚å¸¸      | è¿”å›ç‰¹æ®Šå€¼      |
| ------------ | ------------- | --------------- |
| æ’å…¥é˜Ÿé¦–     | addFirst(E e) | offerFirst(E e) |
| æ’å…¥é˜Ÿå°¾     | addLast(E e)  | offerLast(E e)  |
| åˆ é™¤é˜Ÿé¦–     | removeFirst() | pollFirst()     |
| åˆ é™¤é˜Ÿå°¾     | removeLast()  | pollLast()      |
| æŸ¥è¯¢é˜Ÿé¦–å…ƒç´  | getFirst()    | peekFirst()     |
| æŸ¥è¯¢é˜Ÿå°¾å…ƒç´  | getLast()     | peekLast()      |

Deque è¿˜æä¾›æœ‰ push() å’Œ pop() ç­‰å…¶ä»–æ–¹æ³•ï¼Œå¯ç”¨äºæ¨¡æ‹Ÿæ ˆã€‚

### ArrayDeque ä¸ LinkedList çš„åŒºåˆ«

`ArrayDeque` å’Œ `LinkedList` éƒ½å®ç°äº† `Deque` æ¥å£ï¼Œä¸¤è€…éƒ½å…·æœ‰é˜Ÿåˆ—çš„åŠŸèƒ½

äºŒè€…åŒºåˆ«å¦‚ä¸‹:

- `ArrayDeque` åŸºäºå¯å˜å­—é•¿çš„æ•°ç»„å’ŒåŒæŒ‡é’ˆæ¥å®ç°ï¼›`LinkedList` é€šè¿‡é“¾è¡¨æ¥å®ç°ã€‚
- `ArrayDeque` ä¸æ”¯æŒå­˜å‚¨ `NULL` æ•°æ®; `LinkedList` æ”¯æŒã€‚
- `ArrayDeque` æ˜¯åœ¨ JDK1.6 æ‰è¢«å¼•å…¥çš„; `LinkedList` æ—©åœ¨ JDK1.2 æ—¶å°±å·²ç»å­˜åœ¨ã€‚
- `ArrayDeque` æ’å…¥æ—¶å¯èƒ½å­˜åœ¨æ‰©å®¹è¿‡ç¨‹, ä¸è¿‡å‡æ‘Šåçš„æ’å…¥æ“ä½œä¾ç„¶ä¸º O(1); è™½ç„¶ LinkedList ä¸éœ€è¦æ‰©å®¹ï¼Œä½†æ˜¯æ¯æ¬¡æ’å…¥æ•°æ®æ—¶å‡éœ€è¦ç”³è¯·æ–°çš„å †ç©ºé—´ï¼Œå‡æ‘Šæ€§èƒ½ç›¸æ¯”æ›´æ…¢ã€‚
- ä»æ€§èƒ½çš„è§’åº¦ä¸Šï¼Œé€‰ç”¨ ArrayDeque æ¥å®ç°é˜Ÿåˆ—è¦æ¯” LinkedList æ›´å¥½ã€‚æ­¤å¤–ï¼ŒArrayDeque ä¹Ÿå¯ä»¥ç”¨äºå®ç°æ ˆã€‚

### PriorityQueue

`PriorityQueue` æ˜¯åœ¨ JDK1.5 ä¸­è¢«å¼•å…¥çš„, å…¶ä¸ Queue çš„åŒºåˆ«åœ¨äºå…ƒç´ å‡ºé˜Ÿé¡ºåºæ˜¯ä¸ä¼˜å…ˆçº§ç›¸å…³çš„ï¼Œå³æ€»æ˜¯**ä¼˜å…ˆçº§æœ€é«˜çš„å…ƒç´ å…ˆå‡ºé˜Ÿ**ã€‚

> **è¦ç‚¹**

- `PriorityQueue` åˆ©ç”¨äº†äºŒå‰å †çš„æ•°æ®ç»“æ„æ¥å®ç°çš„ï¼Œåº•å±‚ä½¿ç”¨å¯å˜é•¿çš„æ•°ç»„æ¥å­˜å‚¨æ•°æ®
- `PriorityQueue` é€šè¿‡å †å…ƒç´ çš„ä¸Šæµ®å’Œä¸‹æ²‰ï¼Œå®ç°äº†åœ¨ `O(logn)` çš„æ—¶é—´å¤æ‚åº¦å†…æ’å…¥å…ƒç´ å’Œåˆ é™¤å †é¡¶å…ƒç´ ã€‚
- `PriorityQueue` æ˜¯éçº¿ç¨‹å®‰å…¨çš„ï¼Œä¸”ä¸æ”¯æŒå­˜å‚¨ `NULL` å’Œ `non-comparable` çš„å¯¹è±¡ã€‚
- `PriorityQueue` é»˜è®¤æ˜¯å°é¡¶å †ï¼Œä½†å¯ä»¥æ¥æ”¶ä¸€ä¸ª `Comparator` ä½œä¸ºæ„é€ å‚æ•°ï¼Œä»è€Œæ¥è‡ªå®šä¹‰å…ƒç´ ä¼˜å…ˆçº§çš„å…ˆåã€‚

---

# äº”ã€Map

## 5.1 å¸¸è§é¢è¯•é¢˜

### HashMap å’Œ Hashtable çš„åŒºåˆ«

- **çº¿ç¨‹æ˜¯å¦å®‰å…¨**
  - `HashMap` æ˜¯éçº¿ç¨‹å®‰å…¨
  - `Hashtable` æ˜¯çº¿ç¨‹å®‰å…¨çš„,å› ä¸º Hashtable å†…éƒ¨çš„æ–¹æ³•åŸºæœ¬éƒ½ç»è¿‡synchronized ä¿®é¥°ã€‚ï¼ˆ**å¦‚æœä½ è¦ä¿è¯çº¿ç¨‹å®‰å…¨çš„è¯å°±ä½¿ç”¨ ConcurrentHashMap å§ï¼**ï¼‰ï¼›
- **æ•ˆç‡**
  - å› ä¸ºçº¿ç¨‹å®‰å…¨çš„é—®é¢˜ï¼ŒHashMap è¦æ¯” Hashtable æ•ˆç‡é«˜ä¸€ç‚¹ã€‚
  - Hashtable åŸºæœ¬è¢«æ·˜æ±°ï¼Œä¸è¦åœ¨ä»£ç ä¸­ä½¿ç”¨å®ƒï¼›
- **å¯¹ Null key å’Œ Null value çš„æ”¯æŒ**
  - HashMap å¯ä»¥å­˜å‚¨ null çš„ key å’Œ valueï¼Œä½† null ä½œä¸ºé”®åªèƒ½æœ‰ä¸€ä¸ªï¼Œnull ä½œä¸ºå€¼å¯ä»¥æœ‰å¤šä¸ªï¼›
  - Hashtable ä¸å…è®¸æœ‰ null é”®å’Œ null å€¼ï¼Œå¦åˆ™ä¼šæŠ›å‡º NullPointerExceptionã€‚
- **åˆå§‹å®¹é‡å¤§å°å’Œæ¯æ¬¡æ‰©å……å®¹é‡å¤§å°çš„ä¸åŒ** 
  - â‘  åˆ›å»ºæ—¶å¦‚æœä¸æŒ‡å®šå®¹é‡åˆå§‹å€¼ï¼ŒHashtable é»˜è®¤çš„åˆå§‹å¤§å°ä¸º 11ï¼Œä¹‹åæ¯æ¬¡æ‰©å……ï¼Œå®¹é‡å˜ä¸ºåŸæ¥çš„ 2n+1ã€‚HashMap é»˜è®¤çš„åˆå§‹åŒ–å¤§å°ä¸º 16ã€‚ä¹‹åæ¯æ¬¡æ‰©å……ï¼Œå®¹é‡å˜ä¸ºåŸæ¥çš„ 2 å€ã€‚
  - â‘¡ åˆ›å»ºæ—¶å¦‚æœç»™å®šäº†å®¹é‡åˆå§‹å€¼ï¼Œé‚£ä¹ˆ Hashtable ä¼šç›´æ¥ä½¿ç”¨ä½ ç»™å®šçš„å¤§å°ï¼Œè€ŒHashMap ä¼šå°†å…¶æ‰©å……ä¸º 2 çš„å¹‚æ¬¡æ–¹å¤§å°ï¼ˆHashMap ä¸­çš„tableSizeFor()æ–¹æ³•ä¿è¯ï¼Œä¸‹é¢ç»™å‡ºäº†æºä»£ç ï¼‰ã€‚ä¹Ÿå°±æ˜¯è¯´ HashMap æ€»æ˜¯ä½¿ç”¨ 2 çš„å¹‚ä½œä¸ºå“ˆå¸Œè¡¨çš„å¤§å°,åé¢ä¼šä»‹ç»åˆ°ä¸ºä»€ä¹ˆæ˜¯ 2 çš„å¹‚æ¬¡æ–¹ã€‚
- **åº•å±‚æ•°æ®ç»“æ„**
  - JDK1.8 ä»¥åçš„ HashMap åœ¨è§£å†³å“ˆå¸Œå†²çªæ—¶æœ‰äº†è¾ƒå¤§çš„å˜åŒ–ï¼Œå½“é“¾è¡¨é•¿åº¦å¤§äºé˜ˆå€¼ï¼ˆé»˜è®¤ä¸º 8ï¼‰æ—¶ï¼Œå°†é“¾è¡¨è½¬åŒ–ä¸ºçº¢é»‘æ ‘ï¼ˆå°†é“¾è¡¨è½¬æ¢æˆçº¢é»‘æ ‘å‰ä¼šåˆ¤æ–­ï¼Œå¦‚æœå½“å‰æ•°ç»„çš„é•¿åº¦å°äº 64ï¼Œé‚£ä¹ˆä¼šé€‰æ‹©å…ˆè¿›è¡Œæ•°ç»„æ‰©å®¹ï¼Œè€Œä¸æ˜¯è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼‰ï¼Œä»¥å‡å°‘æœç´¢æ—¶é—´ï¼ˆ
  - Hashtable æ²¡æœ‰è¿™æ ·çš„æœºåˆ¶ã€‚

### HashMap å’Œ HashSet åŒºåˆ«

`HashSet` åº•å±‚å°±æ˜¯åŸºäº `HashMap` å®ç°çš„ã€‚

ï¼ˆ`HashSet` çš„æºç éå¸¸éå¸¸å°‘ï¼Œå› ä¸ºé™¤äº† `clone()`ã€`writeObject()`ã€`readObject()`æ˜¯ `HashSet` è‡ªå·±ä¸å¾—ä¸å®ç°ä¹‹å¤–ï¼Œå…¶ä»–æ–¹æ³•éƒ½æ˜¯ç›´æ¥è°ƒç”¨ `HashMap` ä¸­çš„æ–¹æ³•ã€‚

|               `HashMap`                |                          `HashSet`                           |
| :------------------------------------: | :----------------------------------------------------------: |
|           å®ç°äº† `Map` æ¥å£            |                       å®ç° `Set` æ¥å£                        |
|               å­˜å‚¨é”®å€¼å¯¹               |                          ä»…å­˜å‚¨å¯¹è±¡                          |
|     è°ƒç”¨ `put()`å‘ map ä¸­æ·»åŠ å…ƒç´       |             è°ƒç”¨ `add()`æ–¹æ³•å‘ `Set` ä¸­æ·»åŠ å…ƒç´               |
| `HashMap` ä½¿ç”¨é”®ï¼ˆKeyï¼‰è®¡ç®— `hashcode` | `HashSet` ä½¿ç”¨æˆå‘˜å¯¹è±¡æ¥è®¡ç®— `hashcode` å€¼ï¼Œå¯¹äºä¸¤ä¸ªå¯¹è±¡æ¥è¯´ `hashcode` å¯èƒ½ç›¸åŒï¼Œæ‰€ä»¥`equals()`æ–¹æ³•ç”¨æ¥åˆ¤æ–­å¯¹è±¡çš„ç›¸ç­‰æ€§ |

### HashMap å’Œ TreeMap åŒºåˆ«

`TreeMap` å’Œ`HashMap` éƒ½ç»§æ‰¿è‡ª`AbstractMap` ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯`TreeMap`å®ƒè¿˜å®ç°äº†`NavigableMap`æ¥å£å’Œ`SortedMap` æ¥å£ã€‚

![TreeMap ç»§æ‰¿å…³ç³»å›¾](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/treemap_hierarchy.png)

- å®ç° `NavigableMap` æ¥å£è®© `TreeMap` æœ‰äº†å¯¹é›†åˆå†…å…ƒç´ çš„æœç´¢çš„èƒ½åŠ›ã€‚

- å®ç°`SortedMap`æ¥å£è®© `TreeMap` æœ‰äº†å¯¹é›†åˆä¸­çš„å…ƒç´ æ ¹æ®é”®æ’åºçš„èƒ½åŠ›ã€‚é»˜è®¤æ˜¯æŒ‰ key çš„å‡åºæ’åºï¼Œä¸è¿‡æˆ‘ä»¬ä¹Ÿå¯ä»¥æŒ‡å®šæ’åºçš„æ¯”è¾ƒå™¨ã€‚ç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š

```java
/**
 * @author shuang.kou
 * @createTime 2020å¹´06æœˆ15æ—¥ 17:02:00
 */
public class Person {
    private Integer age;

    public Person(Integer age) {
        this.age = age;
    }

    public Integer getAge() {
        return age;
    }


    public static void main(String[] args) {
        TreeMap<Person, String> treeMap = new TreeMap<>(new Comparator<Person>() {
            @Override
            public int compare(Person person1, Person person2) {
                int num = person1.getAge() - person2.getAge();
                return Integer.compare(num, 0);
            }
        });
        treeMap.put(new Person(3), "person1");
        treeMap.put(new Person(18), "person2");
        treeMap.put(new Person(35), "person3");
        treeMap.put(new Person(16), "person4");
        treeMap.entrySet().stream().forEach(personStringEntry -> {
            System.out.println(personStringEntry.getValue());
        });
    }
}
```

è¾“å‡º:

```
person1
person4
person2
person3
```

å¯ä»¥çœ‹å‡ºï¼Œ`TreeMap` ä¸­çš„å…ƒç´ å·²ç»æ˜¯æŒ‰ç…§ `Person` çš„ age å­—æ®µçš„å‡åºæ¥æ’åˆ—äº†ã€‚

> ä½¿ç”¨ Lambda è¡¨è¾¾å¼å®ç°

```java
TreeMap<Person, String> treeMap = new TreeMap<>((person1, person2) -> {
  int num = person1.getAge() - person2.getAge();
  return Integer.compare(num, 0);
});
```

**ç»¼ä¸Šï¼Œç›¸æ¯”äº`HashMap`æ¥è¯´ `TreeMap` ä¸»è¦å¤šäº†å¯¹é›†åˆä¸­çš„å…ƒç´ æ ¹æ®é”®æ’åºçš„èƒ½åŠ›ä»¥åŠå¯¹é›†åˆå†…å…ƒç´ çš„æœç´¢çš„èƒ½åŠ›ã€‚**

### HashSet å¦‚ä½•æ£€æŸ¥é‡å¤?

ä»¥ä¸‹å†…å®¹æ‘˜è‡ªã€ŠHead first javaã€‹ç¬¬äºŒç‰ˆï¼š

> å½“ä½ æŠŠå¯¹è±¡åŠ å…¥`HashSet`æ—¶ï¼Œ`HashSet` ä¼šå…ˆè®¡ç®—å¯¹è±¡çš„`hashcode`å€¼æ¥åˆ¤æ–­å¯¹è±¡åŠ å…¥çš„ä½ç½®ï¼ŒåŒæ—¶ä¹Ÿä¼šä¸å…¶ä»–åŠ å…¥çš„å¯¹è±¡çš„ `hashcode` å€¼ä½œæ¯”è¾ƒï¼Œå¦‚æœæ²¡æœ‰ç›¸ç¬¦çš„ `hashcode`ï¼Œ`HashSet` ä¼šå‡è®¾å¯¹è±¡æ²¡æœ‰é‡å¤å‡ºç°ã€‚ä½†æ˜¯å¦‚æœå‘ç°æœ‰ç›¸åŒ `hashcode` å€¼çš„å¯¹è±¡ï¼Œè¿™æ—¶ä¼šè°ƒç”¨`equals()`æ–¹æ³•æ¥æ£€æŸ¥ `hashcode` ç›¸ç­‰çš„å¯¹è±¡æ˜¯å¦çœŸçš„ç›¸åŒã€‚å¦‚æœä¸¤è€…ç›¸åŒï¼Œ`HashSet` å°±ä¸ä¼šè®©åŠ å…¥æ“ä½œæˆåŠŸã€‚

åœ¨ JDK1.8 ä¸­ï¼Œ`HashSet`çš„`add()`æ–¹æ³•åªæ˜¯ç®€å•çš„è°ƒç”¨äº†`HashMap`çš„`put()`æ–¹æ³•ï¼Œå¹¶ä¸”åˆ¤æ–­äº†ä¸€ä¸‹è¿”å›å€¼ä»¥ç¡®ä¿æ˜¯å¦æœ‰é‡å¤å…ƒç´ ã€‚

> `HashSet`ä¸­çš„æºç ï¼š

```java
// Returns: true if this set did not already contain the specified element
// è¿”å›å€¼ï¼šå½“ set ä¸­æ²¡æœ‰åŒ…å« add çš„å…ƒç´ æ—¶è¿”å›çœŸ
public boolean add(E e) {
        return map.put(e, PRESENT)==null;
}
```

è€Œåœ¨`HashMap`çš„`putVal()`æ–¹æ³•ä¸­ä¹Ÿèƒ½çœ‹åˆ°å¦‚ä¸‹è¯´æ˜ï¼š

```java
// Returns : previous value, or null if none
// è¿”å›å€¼ï¼šå¦‚æœæ’å…¥ä½ç½®æ²¡æœ‰å…ƒç´ è¿”å›nullï¼Œå¦åˆ™è¿”å›ä¸Šä¸€ä¸ªå…ƒç´ 
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
...
}
```

ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨ JDK1.8 ä¸­ï¼Œå®é™…ä¸Šæ— è®º`HashSet`ä¸­æ˜¯å¦å·²ç»å­˜åœ¨äº†æŸå…ƒç´ ï¼Œ`HashSet`éƒ½ä¼šç›´æ¥æ’å…¥ï¼Œåªæ˜¯ä¼šåœ¨`add()`æ–¹æ³•çš„è¿”å›å€¼å¤„å‘Šè¯‰æˆ‘ä»¬æ’å…¥å‰æ˜¯å¦å­˜åœ¨ç›¸åŒå…ƒç´ ã€‚

### HashMap çš„åº•å±‚å®ç°

#### JDK1.8 ä¹‹å‰

JDK1.8 ä¹‹å‰ `HashMap` åº•å±‚æ˜¯ **æ•°ç»„å’Œé“¾è¡¨** ç»“åˆåœ¨ä¸€èµ·ä½¿ç”¨ä¹Ÿå°±æ˜¯ **é“¾è¡¨æ•£åˆ—**ã€‚

HashMap é€šè¿‡ key çš„ `hashcode` ç»è¿‡**æ‰°åŠ¨å‡½æ•°**å¤„ç†è¿‡åå¾—åˆ° hash å€¼ï¼Œç„¶åé€šè¿‡ `(n - 1) & hash` åˆ¤æ–­å½“å‰å…ƒç´ å­˜æ”¾çš„ä½ç½®ï¼ˆè¿™é‡Œçš„ n æŒ‡çš„æ˜¯æ•°ç»„çš„é•¿åº¦ï¼‰ï¼Œå¦‚æœå½“å‰ä½ç½®å­˜åœ¨å…ƒç´ çš„è¯ï¼Œå°±åˆ¤æ–­è¯¥å…ƒç´ ä¸è¦å­˜å…¥çš„å…ƒç´ çš„ hash å€¼ä»¥åŠ key æ˜¯å¦ç›¸åŒï¼Œå¦‚æœç›¸åŒçš„è¯ï¼Œç›´æ¥è¦†ç›–ï¼Œä¸ç›¸åŒå°±é€šè¿‡æ‹‰é“¾æ³•è§£å†³å†²çªã€‚

æ‰€è°“æ‰°åŠ¨å‡½æ•°æŒ‡çš„å°±æ˜¯ HashMap çš„ `hash` æ–¹æ³•ã€‚ä½¿ç”¨ `hash` æ–¹æ³•ä¹Ÿå°±æ˜¯æ‰°åŠ¨å‡½æ•°æ˜¯ä¸ºäº†é˜²æ­¢ä¸€äº›å®ç°æ¯”è¾ƒå·®çš„ `hashCode()` æ–¹æ³• æ¢å¥è¯è¯´ä½¿ç”¨æ‰°åŠ¨å‡½æ•°ä¹‹åå¯ä»¥å‡å°‘ç¢°æ’ã€‚

> **JDK 1.8 HashMap çš„ hash æ–¹æ³•æºç :**

JDK 1.8 çš„ hash æ–¹æ³• ç›¸æ¯”äº JDK 1.7 hash æ–¹æ³•æ›´åŠ ç®€åŒ–ï¼Œä½†æ˜¯åŸç†ä¸å˜ã€‚

```java
    static final int hash(Object key) {
      int h;
      // key.hashCode()ï¼šè¿”å›æ•£åˆ—å€¼ä¹Ÿå°±æ˜¯hashcode
      // ^ ï¼šæŒ‰ä½å¼‚æˆ–
      // >>>:æ— ç¬¦å·å³ç§»ï¼Œå¿½ç•¥ç¬¦å·ä½ï¼Œç©ºä½éƒ½ä»¥0è¡¥é½
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
```

> **JDK1.7 çš„ HashMap çš„ hash æ–¹æ³•æºç **

```java
static int hash(int h) {
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).

    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
```

ç›¸æ¯”äº JDK1.8 çš„ hash æ–¹æ³• ï¼ŒJDK 1.7 çš„ hash æ–¹æ³•çš„æ€§èƒ½ä¼šç¨å·®ä¸€ç‚¹ç‚¹ï¼Œå› ä¸ºæ¯•ç«Ÿæ‰°åŠ¨äº† 4 æ¬¡ã€‚

> **æ‹‰é“¾æ³•**

æ‰€è°“ **â€œæ‹‰é“¾æ³•â€** å°±æ˜¯ï¼šå°†é“¾è¡¨å’Œæ•°ç»„ç›¸ç»“åˆã€‚ä¹Ÿå°±æ˜¯è¯´åˆ›å»ºä¸€ä¸ªé“¾è¡¨æ•°ç»„ï¼Œæ•°ç»„ä¸­æ¯ä¸€æ ¼å°±æ˜¯ä¸€ä¸ªé“¾è¡¨ã€‚è‹¥é‡åˆ°å“ˆå¸Œå†²çªï¼Œåˆ™å°†å†²çªçš„å€¼åŠ åˆ°é“¾è¡¨ä¸­å³å¯ã€‚

![jdk1.8 ä¹‹å‰çš„å†…éƒ¨ç»“æ„-HashMap](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/jdk1.7_hashmap.png)

#### JDK1.8 ä¹‹å

ç›¸æ¯”äºä¹‹å‰çš„ç‰ˆæœ¬ï¼Œ JDK1.8 ä¹‹ååœ¨è§£å†³å“ˆå¸Œå†²çªæ—¶æœ‰äº†è¾ƒå¤§çš„å˜åŒ–ï¼Œå½“é“¾è¡¨é•¿åº¦å¤§äºé˜ˆå€¼ï¼ˆé»˜è®¤ä¸º 8ï¼‰ï¼ˆå°†é“¾è¡¨è½¬æ¢æˆçº¢é»‘æ ‘å‰ä¼šåˆ¤æ–­ï¼Œå¦‚æœå½“å‰æ•°ç»„çš„é•¿åº¦å°äº 64ï¼Œé‚£ä¹ˆä¼šé€‰æ‹©å…ˆè¿›è¡Œæ•°ç»„æ‰©å®¹ï¼Œè€Œä¸æ˜¯è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼‰æ—¶ï¼Œå°†é“¾è¡¨è½¬åŒ–ä¸ºçº¢é»‘æ ‘ï¼Œä»¥å‡å°‘æœç´¢æ—¶é—´ã€‚

![jdk1.8ä¹‹åçš„å†…éƒ¨ç»“æ„-HashMap](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/jdk1.8_hashmap.png)

TreeMapã€TreeSet ä»¥åŠ JDK1.8 ä¹‹åçš„ HashMap åº•å±‚éƒ½ç”¨åˆ°äº†çº¢é»‘æ ‘ã€‚

çº¢é»‘æ ‘å°±æ˜¯ä¸ºäº†è§£å†³äºŒå‰æŸ¥æ‰¾æ ‘çš„ç¼ºé™·ï¼Œå› ä¸ºäºŒå‰æŸ¥æ‰¾æ ‘åœ¨æŸäº›æƒ…å†µä¸‹ä¼šé€€åŒ–æˆä¸€ä¸ªçº¿æ€§ç»“æ„ã€‚

> **ç»“åˆæºç åˆ†æä¸€ä¸‹ `HashMap` é“¾è¡¨åˆ°çº¢é»‘æ ‘çš„è½¬æ¢**

**1ã€ `putVal` æ–¹æ³•ä¸­æ‰§è¡Œé“¾è¡¨è½¬çº¢é»‘æ ‘çš„åˆ¤æ–­é€»è¾‘ã€‚**

é“¾è¡¨çš„é•¿åº¦å¤§äº 8 çš„æ—¶å€™ï¼Œå°±æ‰§è¡Œ `treeifyBin` ï¼ˆè½¬æ¢çº¢é»‘æ ‘ï¼‰çš„é€»è¾‘ã€‚

```java
// éå†é“¾è¡¨
for (int binCount = 0; ; ++binCount) {
    // éå†åˆ°é“¾è¡¨æœ€åä¸€ä¸ªèŠ‚ç‚¹
    if ((e = p.next) == null) {
        p.next = newNode(hash, key, value, null);
        // å¦‚æœé“¾è¡¨å…ƒç´ ä¸ªæ•°å¤§äºç­‰äºTREEIFY_THRESHOLDï¼ˆ8ï¼‰
        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
            // çº¢é»‘æ ‘è½¬æ¢ï¼ˆå¹¶ä¸ä¼šç›´æ¥è½¬æ¢æˆçº¢é»‘æ ‘ï¼‰
            treeifyBin(tab, hash);
        break;
    }
    if (e.hash == hash &&
        ((k = e.key) == key || (key != null && key.equals(k))))
        break;
    p = e;
}
```

**2ã€`treeifyBin` æ–¹æ³•ä¸­åˆ¤æ–­æ˜¯å¦çœŸçš„è½¬æ¢ä¸ºçº¢é»‘æ ‘ã€‚**

```java
final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<K,V> e;
    // åˆ¤æ–­å½“å‰æ•°ç»„çš„é•¿åº¦æ˜¯å¦å°äº 64
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        // å¦‚æœå½“å‰æ•°ç»„çš„é•¿åº¦å°äº 64ï¼Œé‚£ä¹ˆä¼šé€‰æ‹©å…ˆè¿›è¡Œæ•°ç»„æ‰©å®¹
        resize();
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        // å¦åˆ™æ‰å°†åˆ—è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘

        TreeNode<K,V> hd = null, tl = null;
        do {
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}
```

å°†é“¾è¡¨è½¬æ¢æˆçº¢é»‘æ ‘å‰ä¼šåˆ¤æ–­ï¼Œå¦‚æœå½“å‰æ•°ç»„çš„é•¿åº¦å°äº 64ï¼Œé‚£ä¹ˆä¼šé€‰æ‹©å…ˆè¿›è¡Œæ•°ç»„æ‰©å®¹ï¼Œè€Œä¸æ˜¯è½¬æ¢ä¸ºçº¢é»‘æ ‘ã€‚

### HashMap çš„é•¿åº¦ä¸ºä»€ä¹ˆæ˜¯ 2 çš„å¹‚æ¬¡æ–¹

> **åŸå› **

**ä¸ºäº†èƒ½è®© HashMap å­˜å–é«˜æ•ˆï¼Œå°½é‡è¾ƒå°‘ç¢°æ’ï¼Œä¹Ÿå°±æ˜¯è¦å°½é‡æŠŠæ•°æ®åˆ†é…å‡åŒ€ã€‚**

æˆ‘ä»¬ä¸Šé¢ä¹Ÿè®²åˆ°äº†è¿‡äº†ï¼ŒHash å€¼çš„èŒƒå›´å€¼-2147483648 åˆ° 2147483647ï¼Œå‰ååŠ èµ·æ¥å¤§æ¦‚ 40 äº¿çš„æ˜ å°„ç©ºé—´ï¼Œåªè¦å“ˆå¸Œå‡½æ•°æ˜ å°„å¾—æ¯”è¾ƒå‡åŒ€æ¾æ•£ï¼Œä¸€èˆ¬åº”ç”¨æ˜¯å¾ˆéš¾å‡ºç°ç¢°æ’çš„ã€‚

é—®é¢˜æ˜¯ä¸€ä¸ª 40 äº¿é•¿åº¦çš„æ•°ç»„ï¼Œå†…å­˜æ˜¯æ”¾ä¸ä¸‹çš„ã€‚

æ‰€ä»¥è¿™ä¸ª **hash å€¼æ˜¯ä¸èƒ½ç›´æ¥æ‹¿æ¥ç”¨**ã€‚ç”¨ä¹‹å‰è¿˜è¦å…ˆåšå¯¹æ•°ç»„çš„é•¿åº¦å–æ¨¡è¿ç®—ï¼Œå¾—åˆ°çš„ä½™æ•°æ‰èƒ½ç”¨æ¥è¦å­˜æ”¾çš„ä½ç½®ä¹Ÿå°±æ˜¯å¯¹åº”çš„æ•°ç»„ä¸‹æ ‡ã€‚è¿™ä¸ªæ•°ç»„ä¸‹æ ‡çš„è®¡ç®—æ–¹æ³•æ˜¯â€œ `(n - 1) & hash`â€ã€‚ï¼ˆn ä»£è¡¨æ•°ç»„é•¿åº¦ï¼‰ã€‚

è¿™ä¹Ÿå°±è§£é‡Šäº† HashMap çš„é•¿åº¦ä¸ºä»€ä¹ˆæ˜¯ 2 çš„å¹‚æ¬¡æ–¹ã€‚

> **ç®—æ³•è®¾è®¡**

æˆ‘ä»¬é¦–å…ˆå¯èƒ½ä¼šæƒ³åˆ°é‡‡ç”¨%å–ä½™çš„æ“ä½œæ¥å®ç°ã€‚

- **â€œå–ä½™(%)æ“ä½œä¸­å¦‚æœé™¤æ•°æ˜¯ 2 çš„å¹‚æ¬¡åˆ™ç­‰ä»·äºä¸å…¶é™¤æ•°å‡ä¸€çš„ä¸(&)æ“ä½œ, `hash%length==hash&(length-1)`çš„å‰ææ˜¯ length æ˜¯ 2 çš„ n æ¬¡æ–¹ï¼›ï¼‰ã€‚â€** 
  
- **é‡‡ç”¨äºŒè¿›åˆ¶ä½æ“ä½œ &ï¼Œç›¸å¯¹äº%èƒ½å¤Ÿæé«˜è¿ç®—æ•ˆç‡ï¼Œè¿™å°±è§£é‡Šäº† HashMap çš„é•¿åº¦ä¸ºä»€ä¹ˆæ˜¯ 2 çš„å¹‚æ¬¡æ–¹ã€‚**

### HashMap å¤šçº¿ç¨‹æ“ä½œå¯¼è‡´æ­»å¾ªç¯é—®é¢˜

ä¸»è¦åŸå› åœ¨äº**å¹¶å‘ä¸‹çš„ Rehash ä¼šé€ æˆå…ƒç´ ä¹‹é—´ä¼šå½¢æˆä¸€ä¸ªå¾ªç¯é“¾è¡¨**ã€‚ä¸è¿‡ï¼Œjdk 1.8 åè§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯è¿˜æ˜¯ä¸å»ºè®®åœ¨å¤šçº¿ç¨‹ä¸‹ä½¿ç”¨ HashMap,å› ä¸ºå¤šçº¿ç¨‹ä¸‹ä½¿ç”¨ HashMap è¿˜æ˜¯ä¼šå­˜åœ¨å…¶ä»–é—®é¢˜æ¯”å¦‚æ•°æ®ä¸¢å¤±ã€‚å¹¶å‘ç¯å¢ƒä¸‹æ¨èä½¿ç”¨ ConcurrentHashMap ã€‚

**å‚è€ƒé˜…è¯»:** [JAVA HASHMAPçš„æ­»å¾ªç¯](https://coolshell.cn/articles/9606.html)

### HashMap æœ‰å“ªå‡ ç§å¸¸è§çš„éå†æ–¹å¼?

**HashMap éå†ä»å¤§çš„æ–¹å‘æ¥è¯´ï¼Œå¯åˆ†ä¸ºä»¥ä¸‹ 4 ç±»ï¼š**

- è¿­ä»£å™¨ï¼ˆIteratorï¼‰æ–¹å¼éå†ï¼›
- For Each æ–¹å¼éå†ï¼›
- Lambda è¡¨è¾¾å¼éå†ï¼ˆJDK 1.8+ï¼‰;
- Streams API éå†ï¼ˆJDK 1.8+ï¼‰ã€‚

**ä½†æ¯ç§ç±»å‹ä¸‹åˆæœ‰ä¸åŒçš„å®ç°æ–¹å¼ï¼Œå› æ­¤å…·ä½“çš„éå†æ–¹å¼åˆå¯ä»¥åˆ†ä¸ºä»¥ä¸‹ 7 ç§ï¼š**

- ä½¿ç”¨è¿­ä»£å™¨ï¼ˆIteratorï¼‰EntrySet çš„æ–¹å¼è¿›è¡Œéå†ï¼›
- ä½¿ç”¨è¿­ä»£å™¨ï¼ˆIteratorï¼‰KeySet çš„æ–¹å¼è¿›è¡Œéå†ï¼›
- ä½¿ç”¨ For Each EntrySet çš„æ–¹å¼è¿›è¡Œéå†ï¼›
- ä½¿ç”¨ For Each KeySet çš„æ–¹å¼è¿›è¡Œéå†ï¼›
- ä½¿ç”¨ Lambda è¡¨è¾¾å¼çš„æ–¹å¼è¿›è¡Œéå†ï¼›
- ä½¿ç”¨ Streams API å•çº¿ç¨‹çš„æ–¹å¼è¿›è¡Œéå†ï¼›
- ä½¿ç”¨ Streams API å¤šçº¿ç¨‹çš„æ–¹å¼è¿›è¡Œéå†ã€‚

**å‚è€ƒé˜…è¯»:** [HashMap çš„ 7 ç§éå†æ–¹å¼ä¸æ€§èƒ½åˆ†æï¼](https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw)

### ConcurrentHashMap å’Œ Hashtable çš„åŒºåˆ«

`ConcurrentHashMap` å’Œ `Hashtable` çš„åŒºåˆ«ä¸»è¦ä½“ç°åœ¨å®ç°çº¿ç¨‹å®‰å…¨çš„æ–¹å¼ä¸Šä¸åŒã€‚

- **åº•å±‚æ•°æ®ç»“æ„**
  - JDK1.7 çš„ `ConcurrentHashMap` åº•å±‚é‡‡ç”¨ **åˆ†æ®µçš„æ•°ç»„+é“¾è¡¨** ,JDK1.8 é‡‡ç”¨çš„æ•°æ®ç»“æ„è·Ÿ `HashMap1.8` çš„ç»“æ„ä¸€æ ·ï¼Œæ•°ç»„+é“¾è¡¨/çº¢é»‘äºŒå‰æ ‘ã€‚
  - `Hashtable` å’Œ JDK1.8 ä¹‹å‰çš„ `HashMap` çš„åº•å±‚æ•°æ®ç»“æ„ç±»ä¼¼éƒ½æ˜¯é‡‡ç”¨ **æ•°ç»„+é“¾è¡¨** çš„å½¢å¼ï¼Œæ•°ç»„æ˜¯ HashMap çš„ä¸»ä½“ï¼Œé“¾è¡¨åˆ™æ˜¯ä¸»è¦ä¸ºäº†è§£å†³å“ˆå¸Œå†²çªè€Œå­˜åœ¨çš„ï¼›
- **å®ç°çº¿ç¨‹å®‰å…¨çš„æ–¹å¼ï¼ˆé‡è¦ï¼‰ï¼š**
  - åœ¨ JDK1.7 çš„æ—¶å€™ï¼Œ`ConcurrentHashMap` å¯¹æ•´ä¸ªæ¡¶æ•°ç»„è¿›è¡Œäº†åˆ†å‰²åˆ†æ®µ(`Segment`ï¼Œåˆ†æ®µé”)ï¼Œæ¯ä¸€æŠŠé”åªé”å®¹å™¨å…¶ä¸­ä¸€éƒ¨åˆ†æ•°æ®ï¼ˆä¸‹é¢æœ‰ç¤ºæ„å›¾ï¼‰ï¼Œå¤šçº¿ç¨‹è®¿é—®å®¹å™¨é‡Œä¸åŒæ•°æ®æ®µçš„æ•°æ®ï¼Œå°±ä¸ä¼šå­˜åœ¨é”ç«äº‰ï¼Œæé«˜å¹¶å‘è®¿é—®ç‡ã€‚
  - åˆ°äº† JDK1.8 çš„æ—¶å€™ï¼Œ`ConcurrentHashMap` å·²ç»æ‘’å¼ƒäº† `Segment` çš„æ¦‚å¿µï¼Œè€Œæ˜¯ç›´æ¥ç”¨ `Node` æ•°ç»„+é“¾è¡¨+çº¢é»‘æ ‘çš„æ•°æ®ç»“æ„æ¥å®ç°ï¼Œå¹¶å‘æ§åˆ¶ä½¿ç”¨ `synchronized` å’Œ CAS æ¥æ“ä½œã€‚ï¼ˆJDK1.6 ä»¥å `synchronized` é”åšäº†å¾ˆå¤šä¼˜åŒ–ï¼‰ æ•´ä¸ªçœ‹èµ·æ¥å°±åƒæ˜¯ä¼˜åŒ–è¿‡ä¸”çº¿ç¨‹å®‰å…¨çš„ `HashMap`ï¼Œè™½ç„¶åœ¨ JDK1.8 ä¸­è¿˜èƒ½çœ‹åˆ° `Segment` çš„æ•°æ®ç»“æ„ï¼Œä½†æ˜¯å·²ç»ç®€åŒ–äº†å±æ€§ï¼Œåªæ˜¯ä¸ºäº†å…¼å®¹æ—§ç‰ˆæœ¬ï¼›
  - **`Hashtable`(åŒä¸€æŠŠé”)** :ä½¿ç”¨ `synchronized` æ¥ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œæ•ˆç‡éå¸¸ä½ä¸‹ã€‚å½“ä¸€ä¸ªçº¿ç¨‹è®¿é—®åŒæ­¥æ–¹æ³•æ—¶ï¼Œå…¶ä»–çº¿ç¨‹ä¹Ÿè®¿é—®åŒæ­¥æ–¹æ³•ï¼Œå¯èƒ½ä¼šè¿›å…¥é˜»å¡æˆ–è½®è¯¢çŠ¶æ€ï¼Œå¦‚ä½¿ç”¨ put æ·»åŠ å…ƒç´ ï¼Œå¦ä¸€ä¸ªçº¿ç¨‹ä¸èƒ½ä½¿ç”¨ put æ·»åŠ å…ƒç´ ï¼Œä¹Ÿä¸èƒ½ä½¿ç”¨ getï¼Œç«äº‰ä¼šè¶Šæ¥è¶Šæ¿€çƒˆæ•ˆç‡è¶Šä½ã€‚

ä¸‹é¢ï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹ä¸¤è€…åº•å±‚æ•°æ®ç»“æ„çš„å¯¹æ¯”å›¾ã€‚

> **Hashtable åº•å±‚æ•°æ®ç»“æ„** 

![Hashtable çš„å†…éƒ¨ç»“æ„](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/jdk1.7_hashmap.png)

<p style="text-align:right;font-size:13px;color:gray">https://www.cnblogs.com/chengxiao/p/6842045.html></p>

> **JDK1.7 çš„ ConcurrentHashMap** 

![Java7 ConcurrentHashMap å­˜å‚¨ç»“æ„](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java7_concurrenthashmap.png)

`ConcurrentHashMap` æ˜¯ç”± `Segment` æ•°ç»„ç»“æ„å’Œ `HashEntry` æ•°ç»„ç»“æ„ç»„æˆã€‚

`Segment` æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ åŒ…å«ä¸€ä¸ª `HashEntry` æ•°ç»„ï¼Œæ¯ä¸ª `HashEntry` æ•°ç»„å±äºé“¾è¡¨ç»“æ„ã€‚

> **JDK1.8 çš„ ConcurrentHashMap** 

![Java8 ConcurrentHashMap å­˜å‚¨ç»“æ„](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java8_concurrenthashmap.png)

JDK1.8 çš„ `ConcurrentHashMap` ä¸å†æ˜¯ **Segment æ•°ç»„ + HashEntry æ•°ç»„ + é“¾è¡¨**ï¼Œè€Œæ˜¯ **Node æ•°ç»„ + é“¾è¡¨ / çº¢é»‘æ ‘**ã€‚ä¸è¿‡ï¼ŒNode åªèƒ½ç”¨äºé“¾è¡¨çš„æƒ…å†µï¼Œçº¢é»‘æ ‘çš„æƒ…å†µéœ€è¦ä½¿ç”¨ **`TreeNode`**ã€‚å½“å†²çªé“¾è¡¨è¾¾åˆ°ä¸€å®šé•¿åº¦æ—¶ï¼Œé“¾è¡¨ä¼šè½¬æ¢æˆçº¢é»‘æ ‘ã€‚

`TreeNode`æ˜¯å­˜å‚¨çº¢é»‘æ ‘èŠ‚ç‚¹ï¼Œè¢«`TreeBin`åŒ…è£…ã€‚`TreeBin`é€šè¿‡`root`å±æ€§ç»´æŠ¤çº¢é»‘æ ‘çš„æ ¹ç»“ç‚¹ï¼Œå› ä¸ºçº¢é»‘æ ‘åœ¨æ—‹è½¬çš„æ—¶å€™ï¼Œæ ¹ç»“ç‚¹å¯èƒ½ä¼šè¢«å®ƒåŸæ¥çš„å­èŠ‚ç‚¹æ›¿æ¢æ‰ï¼Œåœ¨è¿™ä¸ªæ—¶é—´ç‚¹ï¼Œå¦‚æœæœ‰å…¶ä»–çº¿ç¨‹è¦å†™è¿™æ£µçº¢é»‘æ ‘å°±ä¼šå‘ç”Ÿçº¿ç¨‹ä¸å®‰å…¨é—®é¢˜ï¼Œæ‰€ä»¥åœ¨ `ConcurrentHashMap` ä¸­`TreeBin`é€šè¿‡`waiter`å±æ€§ç»´æŠ¤å½“å‰ä½¿ç”¨è¿™æ£µçº¢é»‘æ ‘çš„çº¿ç¨‹ï¼Œæ¥é˜²æ­¢å…¶ä»–çº¿ç¨‹çš„è¿›å…¥ã€‚

```java
static final class TreeBin<K,V> extends Node<K,V> {
        TreeNode<K,V> root;
        volatile TreeNode<K,V> first;
        volatile Thread waiter;
        volatile int lockState;
        // values for lockState
        static final int WRITER = 1; // set while holding write lock
        static final int WAITER = 2; // set when waiting for write lock
        static final int READER = 4; // increment value for setting read lock
...
}
```

### ConcurrentHashMap çº¿ç¨‹å®‰å…¨çš„å…·ä½“å®ç°æ–¹å¼/åº•å±‚å…·ä½“å®ç°

#### JDK 1.8 ä¹‹å‰

![Java7 ConcurrentHashMap å­˜å‚¨ç»“æ„](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java7_concurrenthashmap.png)

é¦–å…ˆå°†æ•°æ®åˆ†ä¸ºä¸€æ®µä¸€æ®µï¼ˆè¿™ä¸ªâ€œæ®µâ€å°±æ˜¯ `Segment`ï¼‰çš„å­˜å‚¨ï¼Œç„¶åç»™æ¯ä¸€æ®µæ•°æ®é…ä¸€æŠŠé”ï¼Œå½“ä¸€ä¸ªçº¿ç¨‹å ç”¨é”è®¿é—®å…¶ä¸­ä¸€ä¸ªæ®µæ•°æ®æ—¶ï¼Œå…¶ä»–æ®µçš„æ•°æ®ä¹Ÿèƒ½è¢«å…¶ä»–çº¿ç¨‹è®¿é—®ã€‚

> **`ConcurrentHashMap` æ˜¯ç”± `Segment` æ•°ç»„ç»“æ„å’Œ `HashEntry` æ•°ç»„ç»“æ„ç»„æˆ**ã€‚


- ä¸€ä¸ª `ConcurrentHashMap` é‡ŒåŒ…å«ä¸€ä¸ª `Segment` æ•°ç»„ï¼Œ`Segment` çš„ä¸ªæ•°ä¸€æ—¦**åˆå§‹åŒ–å°±ä¸èƒ½æ”¹å˜**ã€‚ `Segment` æ•°ç»„çš„å¤§å°é»˜è®¤æ˜¯ 16ï¼Œä¹Ÿå°±æ˜¯è¯´é»˜è®¤å¯ä»¥åŒæ—¶æ”¯æŒ 16 ä¸ªçº¿ç¨‹å¹¶å‘å†™ã€‚

- `Segment` ç»§æ‰¿äº† `ReentrantLock`,æ‰€ä»¥ `Segment` æ˜¯ä¸€ç§å¯é‡å…¥é”ï¼Œæ‰®æ¼”é”çš„è§’è‰²ã€‚`HashEntry` ç”¨äºå­˜å‚¨é”®å€¼å¯¹æ•°æ®ã€‚

```java
static class Segment<K,V> extends ReentrantLock implements Serializable {
}
```

- `Segment` çš„ç»“æ„å’Œ `HashMap` ç±»ä¼¼ï¼Œæ˜¯ä¸€ç§æ•°ç»„å’Œé“¾è¡¨ç»“æ„ï¼Œä¸€ä¸ª `Segment` åŒ…å«ä¸€ä¸ª `HashEntry` æ•°ç»„ï¼Œæ¯ä¸ª `HashEntry` æ˜¯ä¸€ä¸ªé“¾è¡¨ç»“æ„çš„å…ƒç´ ï¼Œæ¯ä¸ª `Segment` å®ˆæŠ¤ç€ä¸€ä¸ª `HashEntry` æ•°ç»„é‡Œçš„å…ƒç´ ï¼Œå½“å¯¹ `HashEntry` æ•°ç»„çš„æ•°æ®è¿›è¡Œä¿®æ”¹æ—¶ï¼Œå¿…é¡»é¦–å…ˆè·å¾—å¯¹åº”çš„ `Segment` çš„é”ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹åŒä¸€ `Segment` çš„å¹¶å‘å†™å…¥ä¼šè¢«é˜»å¡ï¼Œä¸åŒ `Segment` çš„å†™å…¥æ˜¯å¯ä»¥å¹¶å‘æ‰§è¡Œçš„ã€‚

#### JDK 1.8 ä¹‹å

![Java8 ConcurrentHashMap å­˜å‚¨ç»“æ„](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java8_concurrenthashmap.png)

Java 8 å‡ ä¹å®Œå…¨é‡å†™äº† `ConcurrentHashMap`ï¼Œä»£ç é‡ä»åŸæ¥ Java 7 ä¸­çš„ 1000 å¤šè¡Œï¼Œå˜æˆäº†ç°åœ¨çš„ 6000 å¤šè¡Œã€‚

`ConcurrentHashMap` å–æ¶ˆäº† `Segment` åˆ†æ®µé”ï¼Œé‡‡ç”¨ `Node + CAS + synchronized` æ¥ä¿è¯å¹¶å‘å®‰å…¨ã€‚æ•°æ®ç»“æ„è·Ÿ `HashMap` 1.8 çš„ç»“æ„ç±»ä¼¼ï¼Œæ•°ç»„+é“¾è¡¨/çº¢é»‘äºŒå‰æ ‘ã€‚Java 8 åœ¨é“¾è¡¨é•¿åº¦è¶…è¿‡ä¸€å®šé˜ˆå€¼ï¼ˆ8ï¼‰æ—¶å°†é“¾è¡¨ï¼ˆå¯»å€æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼‰è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼ˆå¯»å€æ—¶é—´å¤æ‚åº¦ä¸º O(log(N))ï¼‰ã€‚

Java 8 ä¸­ï¼Œé”ç²’åº¦æ›´ç»†ï¼Œ`synchronized` åªé”å®šå½“å‰é“¾è¡¨æˆ–çº¢é»‘äºŒå‰æ ‘çš„é¦–èŠ‚ç‚¹ï¼Œè¿™æ ·åªè¦ hash ä¸å†²çªï¼Œå°±ä¸ä¼šäº§ç”Ÿå¹¶å‘ï¼Œå°±ä¸ä¼šå½±å“å…¶ä»– Node çš„è¯»å†™ï¼Œæ•ˆç‡å¤§å¹…æå‡ã€‚

### JDK 1.7 å’Œ JDK 1.8 çš„ ConcurrentHashMap å®ç°æœ‰ä»€ä¹ˆä¸åŒï¼Ÿ

- **çº¿ç¨‹å®‰å…¨å®ç°æ–¹å¼** ï¼šJDK 1.7 é‡‡ç”¨ `Segment` åˆ†æ®µé”æ¥ä¿è¯å®‰å…¨ï¼Œ `Segment` æ˜¯ç»§æ‰¿è‡ª `ReentrantLock`ã€‚JDK1.8 æ”¾å¼ƒäº† `Segment` åˆ†æ®µé”çš„è®¾è®¡ï¼Œé‡‡ç”¨ `Node + CAS + synchronized` ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œé”ç²’åº¦æ›´ç»†ï¼Œ`synchronized` åªé”å®šå½“å‰é“¾è¡¨æˆ–çº¢é»‘äºŒå‰æ ‘çš„é¦–èŠ‚ç‚¹ã€‚
- **Hash ç¢°æ’è§£å†³æ–¹æ³•** : JDK 1.7 é‡‡ç”¨æ‹‰é“¾æ³•ï¼ŒJDK1.8 é‡‡ç”¨æ‹‰é“¾æ³•ç»“åˆçº¢é»‘æ ‘ï¼ˆé“¾è¡¨é•¿åº¦è¶…è¿‡ä¸€å®šé˜ˆå€¼æ—¶ï¼Œå°†é“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼‰ã€‚
- **å¹¶å‘åº¦** ï¼šJDK 1.7 æœ€å¤§å¹¶å‘åº¦æ˜¯ Segment çš„ä¸ªæ•°ï¼Œé»˜è®¤æ˜¯ 16ã€‚JDK 1.8 æœ€å¤§å¹¶å‘åº¦æ˜¯ Node æ•°ç»„çš„å¤§å°ï¼Œå¹¶å‘åº¦æ›´å¤§ã€‚
  
---

## 5.2 HashMap åº•å±‚æ•°æ®ç»“æ„ä¸æºç åˆ†æ

### 5.2.1 åº•å±‚æ•°æ®ç»“æ„åˆ†æ

#### 5.2.1.1 JDK1.8 ä¹‹å‰

JDK1.8 ä¹‹å‰ HashMap åº•å±‚æ˜¯ **æ•°ç»„å’Œé“¾è¡¨** ç»“åˆåœ¨ä¸€èµ·ä½¿ç”¨ä¹Ÿå°±æ˜¯ **é“¾è¡¨æ•£åˆ—**ã€‚

HashMap é€šè¿‡ key çš„ hashCode ç»è¿‡æ‰°åŠ¨å‡½æ•°å¤„ç†è¿‡åå¾—åˆ° hash å€¼ï¼Œç„¶åé€šè¿‡ `(n - 1) & hash` åˆ¤æ–­å½“å‰å…ƒç´ å­˜æ”¾çš„ä½ç½®ï¼ˆè¿™é‡Œçš„ n æŒ‡çš„æ˜¯æ•°ç»„çš„é•¿åº¦ï¼‰ï¼Œå¦‚æœå½“å‰ä½ç½®å­˜åœ¨å…ƒç´ çš„è¯ï¼Œå°±åˆ¤æ–­è¯¥å…ƒç´ ä¸è¦å­˜å…¥çš„å…ƒç´ çš„ hash å€¼ä»¥åŠ key æ˜¯å¦ç›¸åŒï¼Œå¦‚æœç›¸åŒçš„è¯ï¼Œç›´æ¥è¦†ç›–ï¼Œä¸ç›¸åŒå°±é€šè¿‡æ‹‰é“¾æ³•è§£å†³å†²çªã€‚

æ‰€è°“æ‰°åŠ¨å‡½æ•°æŒ‡çš„å°±æ˜¯ HashMap çš„ hash æ–¹æ³•ã€‚ä½¿ç”¨ hash æ–¹æ³•ä¹Ÿå°±æ˜¯æ‰°åŠ¨å‡½æ•°æ˜¯ä¸ºäº†é˜²æ­¢ä¸€äº›å®ç°æ¯”è¾ƒå·®çš„ hashCode() æ–¹æ³• æ¢å¥è¯è¯´ä½¿ç”¨æ‰°åŠ¨å‡½æ•°ä¹‹åå¯ä»¥å‡å°‘ç¢°æ’ã€‚

> **JDK 1.8 HashMap çš„ hash æ–¹æ³•æºç :**

JDK 1.8 çš„ hash æ–¹æ³• ç›¸æ¯”äº JDK 1.7 hash æ–¹æ³•æ›´åŠ ç®€åŒ–ï¼Œä½†æ˜¯åŸç†ä¸å˜ã€‚

```java
    static final int hash(Object key) {
      int h;
      // key.hashCode()ï¼šè¿”å›æ•£åˆ—å€¼ä¹Ÿå°±æ˜¯hashcode
      // ^ ï¼šæŒ‰ä½å¼‚æˆ–
      // >>>:æ— ç¬¦å·å³ç§»ï¼Œå¿½ç•¥ç¬¦å·ä½ï¼Œç©ºä½éƒ½ä»¥0è¡¥é½
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
```

> **JDK1.7 çš„ HashMap çš„ hash æ–¹æ³•æºç **

```java
static int hash(int h) {
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).

    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
```

ç›¸æ¯”äº JDK1.8 çš„ hash æ–¹æ³• ï¼ŒJDK 1.7 çš„ hash æ–¹æ³•çš„æ€§èƒ½ä¼šç¨å·®ä¸€ç‚¹ç‚¹ï¼Œå› ä¸ºæ¯•ç«Ÿæ‰°åŠ¨äº† 4 æ¬¡ã€‚

> **æ‹‰é“¾æ³•**

æ‰€è°“ **â€œæ‹‰é“¾æ³•â€** å°±æ˜¯ï¼šå°†é“¾è¡¨å’Œæ•°ç»„ç›¸ç»“åˆã€‚ä¹Ÿå°±æ˜¯è¯´åˆ›å»ºä¸€ä¸ªé“¾è¡¨æ•°ç»„ï¼Œæ•°ç»„ä¸­æ¯ä¸€æ ¼å°±æ˜¯ä¸€ä¸ªé“¾è¡¨ã€‚è‹¥é‡åˆ°å“ˆå¸Œå†²çªï¼Œåˆ™å°†å†²çªçš„å€¼åŠ åˆ°é“¾è¡¨ä¸­å³å¯ã€‚

![jdk1.8ä¹‹å‰çš„å†…éƒ¨ç»“æ„](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/jdk1.8ä¹‹å‰çš„å†…éƒ¨ç»“æ„.png)

#### 5.2.1.2 JDK1.8 ä¹‹å

ç›¸æ¯”äºä¹‹å‰çš„ç‰ˆæœ¬ï¼ŒJDK1.8 ä»¥ååœ¨è§£å†³å“ˆå¸Œå†²çªæ—¶æœ‰äº†è¾ƒå¤§çš„å˜åŒ–ã€‚

å½“é“¾è¡¨é•¿åº¦å¤§äºé˜ˆå€¼ï¼ˆé»˜è®¤ä¸º 8ï¼‰æ—¶ï¼Œä¼šé¦–å…ˆè°ƒç”¨ `treeifyBin()`æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•ä¼šæ ¹æ® HashMap æ•°ç»„æ¥å†³å®šæ˜¯å¦è½¬æ¢ä¸ºçº¢é»‘æ ‘ã€‚åªæœ‰å½“æ•°ç»„é•¿åº¦å¤§äºæˆ–è€…ç­‰äº 64 çš„æƒ…å†µä¸‹ï¼Œæ‰ä¼šæ‰§è¡Œè½¬æ¢çº¢é»‘æ ‘æ“ä½œï¼Œä»¥å‡å°‘æœç´¢æ—¶é—´ã€‚å¦åˆ™ï¼Œå°±æ˜¯åªæ˜¯æ‰§è¡Œ `resize()` æ–¹æ³•å¯¹æ•°ç»„æ‰©å®¹ã€‚ç›¸å…³æºç è¿™é‡Œå°±ä¸è´´äº†ï¼Œé‡ç‚¹å…³æ³¨ `treeifyBin()`æ–¹æ³•å³å¯ï¼

![](https://oscimg.oschina.net/oscnet/up-bba283228693dae74e78da1ef7a9a04c684.png)

> **ç±»çš„å±æ€§ï¼š**

```java
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {
    // åºåˆ—å·
    private static final long serialVersionUID = 362498820763181265L;
    // é»˜è®¤çš„åˆå§‹å®¹é‡æ˜¯16
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;
    // æœ€å¤§å®¹é‡
    static final int MAXIMUM_CAPACITY = 1 << 30;
    // é»˜è®¤çš„å¡«å……å› å­
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    // å½“æ¡¶(bucket)ä¸Šçš„ç»“ç‚¹æ•°å¤§äºè¿™ä¸ªå€¼æ—¶ä¼šè½¬æˆçº¢é»‘æ ‘
    static final int TREEIFY_THRESHOLD = 8;
    // å½“æ¡¶(bucket)ä¸Šçš„ç»“ç‚¹æ•°å°äºè¿™ä¸ªå€¼æ—¶æ ‘è½¬é“¾è¡¨
    static final int UNTREEIFY_THRESHOLD = 6;
    // æ¡¶ä¸­ç»“æ„è½¬åŒ–ä¸ºçº¢é»‘æ ‘å¯¹åº”çš„tableçš„æœ€å°å®¹é‡
    static final int MIN_TREEIFY_CAPACITY = 64;
    // å­˜å‚¨å…ƒç´ çš„æ•°ç»„ï¼Œæ€»æ˜¯2çš„å¹‚æ¬¡å€
    transient Node<k,v>[] table;
    // å­˜æ”¾å…·ä½“å…ƒç´ çš„é›†
    transient Set<map.entry<k,v>> entrySet;
    // å­˜æ”¾å…ƒç´ çš„ä¸ªæ•°ï¼Œæ³¨æ„è¿™ä¸ªä¸ç­‰äºæ•°ç»„çš„é•¿åº¦ã€‚
    transient int size;
    // æ¯æ¬¡æ‰©å®¹å’Œæ›´æ”¹mapç»“æ„çš„è®¡æ•°å™¨
    transient int modCount;
    // ä¸´ç•Œå€¼(å®¹é‡*å¡«å……å› å­) å½“å®é™…å¤§å°è¶…è¿‡ä¸´ç•Œå€¼æ—¶ï¼Œä¼šè¿›è¡Œæ‰©å®¹
    int threshold;
    // åŠ è½½å› å­
    final float loadFactor;
}
```

- **loadFactor åŠ è½½å› å­**

  loadFactor åŠ è½½å› å­æ˜¯æ§åˆ¶æ•°ç»„å­˜æ”¾æ•°æ®çš„ç–å¯†ç¨‹åº¦ï¼ŒloadFactor è¶Šè¶‹è¿‘äº 1ï¼Œé‚£ä¹ˆ æ•°ç»„ä¸­å­˜æ”¾çš„æ•°æ®(entry)ä¹Ÿå°±è¶Šå¤šï¼Œä¹Ÿå°±è¶Šå¯†ï¼Œä¹Ÿå°±æ˜¯ä¼šè®©é“¾è¡¨çš„é•¿åº¦å¢åŠ ï¼ŒloadFactor è¶Šå°ï¼Œä¹Ÿå°±æ˜¯è¶‹è¿‘äº 0ï¼Œæ•°ç»„ä¸­å­˜æ”¾çš„æ•°æ®(entry)ä¹Ÿå°±è¶Šå°‘ï¼Œä¹Ÿå°±è¶Šç¨€ç–ã€‚

  **loadFactor å¤ªå¤§å¯¼è‡´æŸ¥æ‰¾å…ƒç´ æ•ˆç‡ä½ï¼Œå¤ªå°å¯¼è‡´æ•°ç»„çš„åˆ©ç”¨ç‡ä½ï¼Œå­˜æ”¾çš„æ•°æ®ä¼šå¾ˆåˆ†æ•£ã€‚loadFactor çš„é»˜è®¤å€¼ä¸º 0.75f æ˜¯å®˜æ–¹ç»™å‡ºçš„ä¸€ä¸ªæ¯”è¾ƒå¥½çš„ä¸´ç•Œå€¼**ã€‚

  ç»™å®šçš„é»˜è®¤å®¹é‡ä¸º 16ï¼Œè´Ÿè½½å› å­ä¸º 0.75ã€‚Map åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­ä¸æ–­çš„å¾€é‡Œé¢å­˜æ”¾æ•°æ®ï¼Œå½“æ•°é‡è¾¾åˆ°äº† 16 \* 0.75 = 12 å°±éœ€è¦å°†å½“å‰ 16 çš„å®¹é‡è¿›è¡Œæ‰©å®¹ï¼Œè€Œæ‰©å®¹è¿™ä¸ªè¿‡ç¨‹æ¶‰åŠåˆ° rehashã€å¤åˆ¶æ•°æ®ç­‰æ“ä½œï¼Œæ‰€ä»¥éå¸¸æ¶ˆè€—æ€§èƒ½ã€‚

- **threshold**

  **threshold = capacity \* loadFactor**ï¼Œ**å½“ Size>=threshold**çš„æ—¶å€™ï¼Œé‚£ä¹ˆå°±è¦è€ƒè™‘å¯¹æ•°ç»„çš„æ‰©å¢äº†ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸ªçš„æ„æ€å°±æ˜¯ **è¡¡é‡æ•°ç»„æ˜¯å¦éœ€è¦æ‰©å¢çš„ä¸€ä¸ªæ ‡å‡†**ã€‚

> **Node èŠ‚ç‚¹ç±»æºç :**

```java
// ç»§æ‰¿è‡ª Map.Entry<K,V>
static class Node<K,V> implements Map.Entry<K,V> {
       final int hash;// å“ˆå¸Œå€¼ï¼Œå­˜æ”¾å…ƒç´ åˆ°hashmapä¸­æ—¶ç”¨æ¥ä¸å…¶ä»–å…ƒç´ hashå€¼æ¯”è¾ƒ
       final K key;//é”®
       V value;//å€¼
       // æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
       Node<K,V> next;
       Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }
        // é‡å†™hashCode()æ–¹æ³•
        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }
        // é‡å†™ equals() æ–¹æ³•
        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>)o;
                if (Objects.equals(key, e.getKey()) &&
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
}
```

> **æ ‘èŠ‚ç‚¹ç±»æºç :**

```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
        TreeNode<K,V> parent;  // çˆ¶
        TreeNode<K,V> left;    // å·¦
        TreeNode<K,V> right;   // å³
        TreeNode<K,V> prev;    // needed to unlink next upon deletion
        boolean red;           // åˆ¤æ–­é¢œè‰²
        TreeNode(int hash, K key, V val, Node<K,V> next) {
            super(hash, key, val, next);
        }
        // è¿”å›æ ¹èŠ‚ç‚¹
        final TreeNode<K,V> root() {
            for (TreeNode<K,V> r = this, p;;) {
                if ((p = r.parent) == null)
                    return r;
                r = p;
       }
```

### 5.2.2 HashMap æºç åˆ†æ

> **æ„é€ æ–¹æ³•**

HashMap ä¸­æœ‰å››ä¸ªæ„é€ æ–¹æ³•ï¼Œå®ƒä»¬åˆ†åˆ«å¦‚ä¸‹ï¼š

```java
    // é»˜è®¤æ„é€ å‡½æ•°ã€‚
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted
     }

     // åŒ…å«å¦ä¸€ä¸ªâ€œMapâ€çš„æ„é€ å‡½æ•°
     public HashMap(Map<? extends K, ? extends V> m) {
         this.loadFactor = DEFAULT_LOAD_FACTOR;
         putMapEntries(m, false);//ä¸‹é¢ä¼šåˆ†æåˆ°è¿™ä¸ªæ–¹æ³•
     }

     // æŒ‡å®šâ€œå®¹é‡å¤§å°â€çš„æ„é€ å‡½æ•°
     public HashMap(int initialCapacity) {
         this(initialCapacity, DEFAULT_LOAD_FACTOR);
     }

     // æŒ‡å®šâ€œå®¹é‡å¤§å°â€å’Œâ€œåŠ è½½å› å­â€çš„æ„é€ å‡½æ•°
     public HashMap(int initialCapacity, float loadFactor) {
         if (initialCapacity < 0)
             throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);
         if (initialCapacity > MAXIMUM_CAPACITY)
             initialCapacity = MAXIMUM_CAPACITY;
         if (loadFactor <= 0 || Float.isNaN(loadFactor))
             throw new IllegalArgumentException("Illegal load factor: " + loadFactor);
         this.loadFactor = loadFactor;
         this.threshold = tableSizeFor(initialCapacity);
     }
```

**putMapEntries æ–¹æ³•ï¼š**

```java
final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {
    int s = m.size();
    if (s > 0) {
        // åˆ¤æ–­tableæ˜¯å¦å·²ç»åˆå§‹åŒ–
        if (table == null) { // pre-size
            // æœªåˆå§‹åŒ–ï¼Œsä¸ºmçš„å®é™…å…ƒç´ ä¸ªæ•°
            float ft = ((float)s / loadFactor) + 1.0F;
            int t = ((ft < (float)MAXIMUM_CAPACITY) ?
                    (int)ft : MAXIMUM_CAPACITY);
            // è®¡ç®—å¾—åˆ°çš„tå¤§äºé˜ˆå€¼ï¼Œåˆ™åˆå§‹åŒ–é˜ˆå€¼
            if (t > threshold)
                threshold = tableSizeFor(t);
        }
        // å·²åˆå§‹åŒ–ï¼Œå¹¶ä¸”må…ƒç´ ä¸ªæ•°å¤§äºé˜ˆå€¼ï¼Œè¿›è¡Œæ‰©å®¹å¤„ç†
        else if (s > threshold)
            resize();
        // å°†mä¸­çš„æ‰€æœ‰å…ƒç´ æ·»åŠ è‡³HashMapä¸­
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        }
    }
}
```

> **put æ–¹æ³•**

HashMap åªæä¾›äº† put ç”¨äºæ·»åŠ å…ƒç´ ï¼ŒputVal æ–¹æ³•åªæ˜¯ç»™ put æ–¹æ³•è°ƒç”¨çš„ä¸€ä¸ªæ–¹æ³•ï¼Œå¹¶æ²¡æœ‰æä¾›ç»™ç”¨æˆ·ä½¿ç”¨ã€‚

**å¯¹ putVal æ–¹æ³•æ·»åŠ å…ƒç´ çš„åˆ†æå¦‚ä¸‹ï¼š**

1. å¦‚æœå®šä½åˆ°çš„æ•°ç»„ä½ç½®æ²¡æœ‰å…ƒç´  å°±ç›´æ¥æ’å…¥ã€‚
2. å¦‚æœå®šä½åˆ°çš„æ•°ç»„ä½ç½®æœ‰å…ƒç´ å°±å’Œè¦æ’å…¥çš„ key æ¯”è¾ƒï¼Œå¦‚æœ key ç›¸åŒå°±ç›´æ¥è¦†ç›–ï¼Œå¦‚æœ key ä¸ç›¸åŒï¼Œå°±åˆ¤æ–­ p æ˜¯å¦æ˜¯ä¸€ä¸ªæ ‘èŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯å°±è°ƒç”¨`e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value)`å°†å…ƒç´ æ·»åŠ è¿›å…¥ã€‚å¦‚æœä¸æ˜¯å°±éå†é“¾è¡¨æ’å…¥(æ’å…¥çš„æ˜¯é“¾è¡¨å°¾éƒ¨)ã€‚

![ ](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/putæ–¹æ³•.png)

è¯´æ˜:ä¸Šå›¾æœ‰ä¸¤ä¸ªå°é—®é¢˜ï¼š

- ç›´æ¥è¦†ç›–ä¹‹ååº”è¯¥å°±ä¼š returnï¼Œä¸ä¼šæœ‰åç»­æ“ä½œã€‚å‚è€ƒ JDK8 HashMap.java 658 è¡Œï¼ˆ[issue#608](https://github.com/Snailclimb/JavaGuide/issues/608)ï¼‰ã€‚
- å½“é“¾è¡¨é•¿åº¦å¤§äºé˜ˆå€¼ï¼ˆé»˜è®¤ä¸º 8ï¼‰å¹¶ä¸” HashMap æ•°ç»„é•¿åº¦è¶…è¿‡ 64 çš„æ—¶å€™æ‰ä¼šæ‰§è¡Œé“¾è¡¨è½¬çº¢é»‘æ ‘çš„æ“ä½œï¼Œå¦åˆ™å°±åªæ˜¯å¯¹æ•°ç»„æ‰©å®¹ã€‚å‚è€ƒ HashMap çš„ `treeifyBin()` æ–¹æ³•ï¼ˆ[issue#1087](https://github.com/Snailclimb/JavaGuide/issues/1087)ï¼‰ã€‚

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    // tableæœªåˆå§‹åŒ–æˆ–è€…é•¿åº¦ä¸º0ï¼Œè¿›è¡Œæ‰©å®¹
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // (n - 1) & hash ç¡®å®šå…ƒç´ å­˜æ”¾åœ¨å“ªä¸ªæ¡¶ä¸­ï¼Œæ¡¶ä¸ºç©ºï¼Œæ–°ç”Ÿæˆç»“ç‚¹æ”¾å…¥æ¡¶ä¸­(æ­¤æ—¶ï¼Œè¿™ä¸ªç»“ç‚¹æ˜¯æ”¾åœ¨æ•°ç»„ä¸­)
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // æ¡¶ä¸­å·²ç»å­˜åœ¨å…ƒç´ ï¼ˆå¤„ç†hashå†²çªï¼‰
    else {
        Node<K,V> e; K k;
        // åˆ¤æ–­table[i]ä¸­çš„å…ƒç´ æ˜¯å¦ä¸æ’å…¥çš„keyä¸€æ ·ï¼Œè‹¥ç›¸åŒé‚£å°±ç›´æ¥ä½¿ç”¨æ’å…¥çš„å€¼pæ›¿æ¢æ‰æ—§çš„å€¼eã€‚
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
        // åˆ¤æ–­æ’å…¥çš„æ˜¯å¦æ˜¯çº¢é»‘æ ‘èŠ‚ç‚¹
        else if (p instanceof TreeNode)
            // æ”¾å…¥æ ‘ä¸­
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        // ä¸æ˜¯çº¢é»‘æ ‘èŠ‚ç‚¹åˆ™è¯´æ˜ä¸ºé“¾è¡¨ç»“ç‚¹
        else {
            // åœ¨é“¾è¡¨æœ€æœ«æ’å…¥ç»“ç‚¹
            for (int binCount = 0; ; ++binCount) {
                // åˆ°è¾¾é“¾è¡¨çš„å°¾éƒ¨
                if ((e = p.next) == null) {
                    // åœ¨å°¾éƒ¨æ’å…¥æ–°ç»“ç‚¹
                    p.next = newNode(hash, key, value, null);
                    // ç»“ç‚¹æ•°é‡è¾¾åˆ°é˜ˆå€¼(é»˜è®¤ä¸º 8 )ï¼Œæ‰§è¡Œ treeifyBin æ–¹æ³•
                    // è¿™ä¸ªæ–¹æ³•ä¼šæ ¹æ® HashMap æ•°ç»„æ¥å†³å®šæ˜¯å¦è½¬æ¢ä¸ºçº¢é»‘æ ‘ã€‚
                    // åªæœ‰å½“æ•°ç»„é•¿åº¦å¤§äºæˆ–è€…ç­‰äº 64 çš„æƒ…å†µä¸‹ï¼Œæ‰ä¼šæ‰§è¡Œè½¬æ¢çº¢é»‘æ ‘æ“ä½œï¼Œä»¥å‡å°‘æœç´¢æ—¶é—´ã€‚å¦åˆ™ï¼Œå°±æ˜¯åªæ˜¯å¯¹æ•°ç»„æ‰©å®¹ã€‚
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    // è·³å‡ºå¾ªç¯
                    break;
                }
                // åˆ¤æ–­é“¾è¡¨ä¸­ç»“ç‚¹çš„keyå€¼ä¸æ’å…¥çš„å…ƒç´ çš„keyå€¼æ˜¯å¦ç›¸ç­‰
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    // ç›¸ç­‰ï¼Œè·³å‡ºå¾ªç¯
                    break;
                // ç”¨äºéå†æ¡¶ä¸­çš„é“¾è¡¨ï¼Œä¸å‰é¢çš„e = p.nextç»„åˆï¼Œå¯ä»¥éå†é“¾è¡¨
                p = e;
            }
        }
        // è¡¨ç¤ºåœ¨æ¡¶ä¸­æ‰¾åˆ°keyå€¼ã€hashå€¼ä¸æ’å…¥å…ƒç´ ç›¸ç­‰çš„ç»“ç‚¹
        if (e != null) {
            // è®°å½•eçš„value
            V oldValue = e.value;
            // onlyIfAbsentä¸ºfalseæˆ–è€…æ—§å€¼ä¸ºnull
            if (!onlyIfAbsent || oldValue == null)
                //ç”¨æ–°å€¼æ›¿æ¢æ—§å€¼
                e.value = value;
            // è®¿é—®åå›è°ƒ
            afterNodeAccess(e);
            // è¿”å›æ—§å€¼
            return oldValue;
        }
    }
    // ç»“æ„æ€§ä¿®æ”¹
    ++modCount;
    // å®é™…å¤§å°å¤§äºé˜ˆå€¼åˆ™æ‰©å®¹
    if (++size > threshold)
        resize();
    // æ’å…¥åå›è°ƒ
    afterNodeInsertion(evict);
    return null;
}
```

**å¯¹æ¯”ä¸€ä¸‹ JDK1.7 put æ–¹æ³•çš„ä»£ç **

**å¯¹äº put æ–¹æ³•çš„åˆ†æå¦‚ä¸‹ï¼š**

- â‘  å¦‚æœå®šä½åˆ°çš„æ•°ç»„ä½ç½®æ²¡æœ‰å…ƒç´  å°±ç›´æ¥æ’å…¥ã€‚
- â‘¡ å¦‚æœå®šä½åˆ°çš„æ•°ç»„ä½ç½®æœ‰å…ƒç´ ï¼Œéå†ä»¥è¿™ä¸ªå…ƒç´ ä¸ºå¤´ç»“ç‚¹çš„é“¾è¡¨ï¼Œä¾æ¬¡å’Œæ’å…¥çš„ key æ¯”è¾ƒï¼Œå¦‚æœ key ç›¸åŒå°±ç›´æ¥è¦†ç›–ï¼Œä¸åŒå°±é‡‡ç”¨å¤´æ’æ³•æ’å…¥å…ƒç´ ã€‚

```java
public V put(K key, V value)
    if (table == EMPTY_TABLE) {
    inflateTable(threshold);
}
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    int i = indexFor(hash, table.length);
    for (Entry<K,V> e = table[i]; e != null; e = e.next) { // å…ˆéå†
        Object k;
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    addEntry(hash, key, value, i);  // å†æ’å…¥
    return null;
}
```

> **get æ–¹æ³•**

```java
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        // æ•°ç»„å…ƒç´ ç›¸ç­‰
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        // æ¡¶ä¸­ä¸æ­¢ä¸€ä¸ªèŠ‚ç‚¹
        if ((e = first.next) != null) {
            // åœ¨æ ‘ä¸­get
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            // åœ¨é“¾è¡¨ä¸­get
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

> **resize æ–¹æ³•**

è¿›è¡Œæ‰©å®¹ï¼Œä¼šä¼´éšç€ä¸€æ¬¡é‡æ–° hash åˆ†é…ï¼Œå¹¶ä¸”ä¼šéå† hash è¡¨ä¸­æ‰€æœ‰çš„å…ƒç´ ï¼Œæ˜¯éå¸¸è€—æ—¶çš„ã€‚åœ¨ç¼–å†™ç¨‹åºä¸­ï¼Œè¦å°½é‡é¿å… resizeã€‚

```java
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap > 0) {
        // è¶…è¿‡æœ€å¤§å€¼å°±ä¸å†æ‰©å……äº†ï¼Œå°±åªå¥½éšä½ ç¢°æ’å»å§
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // æ²¡è¶…è¿‡æœ€å¤§å€¼ï¼Œå°±æ‰©å……ä¸ºåŸæ¥çš„2å€
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {
        // signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // è®¡ç®—æ–°çš„resizeä¸Šé™
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        // æŠŠæ¯ä¸ªbucketéƒ½ç§»åŠ¨åˆ°æ–°çš„bucketsä¸­
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else {
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        // åŸç´¢å¼•
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // åŸç´¢å¼•+oldCap
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // åŸç´¢å¼•æ”¾åˆ°bucketé‡Œ
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // åŸç´¢å¼•+oldCapæ”¾åˆ°bucketé‡Œ
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
```

## 5.3 HashMap å¸¸ç”¨æ–¹æ³•æµ‹è¯•

```java
package map;

import java.util.Collection;
import java.util.HashMap;
import java.util.Set;

public class HashMapDemo {

    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<String, String>();
        // é”®ä¸èƒ½é‡å¤ï¼Œå€¼å¯ä»¥é‡å¤
        map.put("san", "å¼ ä¸‰");
        map.put("si", "æå››");
        map.put("wu", "ç‹äº”");
        map.put("wang", "è€ç‹");
        map.put("wang", "è€ç‹2");// è€ç‹è¢«è¦†ç›–
        map.put("lao", "è€ç‹");
        System.out.println("-------ç›´æ¥è¾“å‡ºhashmap:-------");
        System.out.println(map);
        /**
         * éå†HashMap
         */
        // 1.è·å–Mapä¸­çš„æ‰€æœ‰é”®
        System.out.println("-------foreachè·å–Mapä¸­æ‰€æœ‰çš„é”®:------");
        Set<String> keys = map.keySet();
        for (String key : keys) {
            System.out.print(key+"  ");
        }
        System.out.println();//æ¢è¡Œ
        // 2.è·å–Mapä¸­æ‰€æœ‰å€¼
        System.out.println("-------foreachè·å–Mapä¸­æ‰€æœ‰çš„å€¼:------");
        Collection<String> values = map.values();
        for (String value : values) {
            System.out.print(value+"  ");
        }
        System.out.println();//æ¢è¡Œ
        // 3.å¾—åˆ°keyçš„å€¼çš„åŒæ—¶å¾—åˆ°keyæ‰€å¯¹åº”çš„å€¼
        System.out.println("-------å¾—åˆ°keyçš„å€¼çš„åŒæ—¶å¾—åˆ°keyæ‰€å¯¹åº”çš„å€¼:-------");
        Set<String> keys2 = map.keySet();
        for (String key : keys2) {
            System.out.print(key + "ï¼š" + map.get(key)+"   ");

        }
        /**
         * å¦‚æœæ—¢è¦éå†keyåˆè¦valueï¼Œé‚£ä¹ˆå»ºè®®è¿™ç§æ–¹å¼ï¼Œå› ä¸ºå¦‚æœå…ˆè·å–keySetç„¶åå†æ‰§è¡Œmap.get(key)ï¼Œmapå†…éƒ¨ä¼šæ‰§è¡Œä¸¤æ¬¡éå†ã€‚
         * ä¸€æ¬¡æ˜¯åœ¨è·å–keySetçš„æ—¶å€™ï¼Œä¸€æ¬¡æ˜¯åœ¨éå†æ‰€æœ‰keyçš„æ—¶å€™ã€‚
         */
        // å½“æˆ‘è°ƒç”¨put(key,value)æ–¹æ³•çš„æ—¶å€™ï¼Œé¦–å…ˆä¼šæŠŠkeyå’Œvalueå°è£…åˆ°
        // Entryè¿™ä¸ªé™æ€å†…éƒ¨ç±»å¯¹è±¡ä¸­ï¼ŒæŠŠEntryå¯¹è±¡å†æ·»åŠ åˆ°æ•°ç»„ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬æƒ³è·å–
        // mapä¸­çš„æ‰€æœ‰é”®å€¼å¯¹ï¼Œæˆ‘ä»¬åªè¦è·å–æ•°ç»„ä¸­çš„æ‰€æœ‰Entryå¯¹è±¡ï¼Œæ¥ä¸‹æ¥
        // è°ƒç”¨Entryå¯¹è±¡ä¸­çš„getKey()å’ŒgetValue()æ–¹æ³•å°±èƒ½è·å–é”®å€¼å¯¹äº†
        Set<java.util.Map.Entry<String, String>> entrys = map.entrySet();
        for (java.util.Map.Entry<String, String> entry : entrys) {
            System.out.println(entry.getKey() + "--" + entry.getValue());
        }

        /**
         * HashMapå…¶ä»–å¸¸ç”¨æ–¹æ³•
         */
        System.out.println("after map.size()ï¼š"+map.size());
        System.out.println("after map.isEmpty()ï¼š"+map.isEmpty());
        System.out.println(map.remove("san"));
        System.out.println("after map.remove()ï¼š"+map);
        System.out.println("after map.get(si)ï¼š"+map.get("si"));
        System.out.println("after map.containsKey(si)ï¼š"+map.containsKey("si"));
        System.out.println("after containsValue(æå››)ï¼š"+map.containsValue("æå››"));
        System.out.println(map.replace("si", "æå››2"));
        System.out.println("after map.replace(si, æå››2):"+map);
    }

}
```

## 5.4 ConcurrentHashMapåº•å±‚æ•°æ®ç»“æ„ä¸æºç åˆ†æ

### 5.4.1 ConcurrentHashMap 1.7

> **å­˜å‚¨ç»“æ„**

![Java 7 ConcurrentHashMap å­˜å‚¨ç»“æ„](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java7_concurrenthashmap.png)

Java 7 ä¸­ `ConcurrentHashMap` çš„å­˜å‚¨ç»“æ„å¦‚ä¸Šå›¾ï¼Œ`ConcurrnetHashMap` ç”±å¾ˆå¤šä¸ª `Segment`  ç»„åˆï¼Œè€Œæ¯ä¸€ä¸ª `Segment` æ˜¯ä¸€ä¸ªç±»ä¼¼äº `HashMap` çš„ç»“æ„ï¼Œæ‰€ä»¥æ¯ä¸€ä¸ª `HashMap` çš„å†…éƒ¨å¯ä»¥è¿›è¡Œæ‰©å®¹ã€‚ä½†æ˜¯ `Segment` çš„ä¸ªæ•°ä¸€æ—¦**åˆå§‹åŒ–å°±ä¸èƒ½æ”¹å˜**ï¼Œé»˜è®¤ `Segment` çš„ä¸ªæ•°æ˜¯ 16 ä¸ªï¼Œä½ ä¹Ÿå¯ä»¥è®¤ä¸º `ConcurrentHashMap` é»˜è®¤æ”¯æŒæœ€å¤š 16 ä¸ªçº¿ç¨‹å¹¶å‘ã€‚

> **åˆå§‹åŒ–**

**é€šè¿‡ `ConcurrentHashMap` çš„æ— å‚æ„é€ æ¢å¯» `ConcurrentHashMap` çš„åˆå§‹åŒ–æµç¨‹**

```java
    /**
     * Creates a new, empty map with a default initial capacity (16),
     * load factor (0.75) and concurrencyLevel (16).
     */
    public ConcurrentHashMap() {
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
    }

    //æ— å‚æ„é€ ä¸­è°ƒç”¨äº†æœ‰å‚æ„é€ ï¼Œä¼ å…¥äº†ä¸‰ä¸ªå‚æ•°çš„é»˜è®¤å€¼ï¼Œä»–ä»¬çš„å€¼æ˜¯ã€‚

    /**
     * é»˜è®¤åˆå§‹åŒ–å®¹é‡
     */
    static final int DEFAULT_INITIAL_CAPACITY = 16;

    /**
     * é»˜è®¤è´Ÿè½½å› å­
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * é»˜è®¤å¹¶å‘çº§åˆ«
     */
    static final int DEFAULT_CONCURRENCY_LEVEL = 16;
```

**æ¥ç€çœ‹ä¸‹è¿™ä¸ªæœ‰å‚æ„é€ å‡½æ•°çš„å†…éƒ¨å®ç°é€»è¾‘**ã€‚

```java
@SuppressWarnings("unchecked")
public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) {
    // å‚æ•°æ ¡éªŒ
    if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    // æ ¡éªŒå¹¶å‘çº§åˆ«å¤§å°ï¼Œå¤§äº 1<<16ï¼Œé‡ç½®ä¸º 65536
    if (concurrencyLevel > MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // Find power-of-two sizes best matching arguments
    // 2çš„å¤šå°‘æ¬¡æ–¹
    int sshift = 0;
    int ssize = 1;
    // è¿™ä¸ªå¾ªç¯å¯ä»¥æ‰¾åˆ° concurrencyLevel ä¹‹ä¸Šæœ€è¿‘çš„ 2çš„æ¬¡æ–¹å€¼
    while (ssize < concurrencyLevel) {
        ++sshift;
        ssize <<= 1;
    }
    // è®°å½•æ®µåç§»é‡
    this.segmentShift = 32 - sshift;
    // è®°å½•æ®µæ©ç 
    this.segmentMask = ssize - 1;
    // è®¾ç½®å®¹é‡
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    // c = å®¹é‡ / ssize ï¼Œé»˜è®¤ 16 / 16 = 1ï¼Œè¿™é‡Œæ˜¯è®¡ç®—æ¯ä¸ª Segment ä¸­çš„ç±»ä¼¼äº HashMap çš„å®¹é‡
    int c = initialCapacity / ssize;
    if (c * ssize < initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    //Segment ä¸­çš„ç±»ä¼¼äº HashMap çš„å®¹é‡è‡³å°‘æ˜¯2æˆ–è€…2çš„å€æ•°
    while (cap < c)
        cap <<= 1;
    // create segments and segments[0]
    // åˆ›å»º Segment æ•°ç»„ï¼Œè®¾ç½® segments[0]
    Segment<K,V> s0 = new Segment<K,V>(loadFactor, (int)(cap * loadFactor),
                         (HashEntry<K,V>[])new HashEntry[cap]);
    Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
```

**æ€»ç»“ä¸€ä¸‹åœ¨ Java 7 ä¸­ ConcurrnetHashMap çš„åˆå§‹åŒ–é€»è¾‘ã€‚**

1. å¿…è¦å‚æ•°æ ¡éªŒã€‚
2. æ ¡éªŒå¹¶å‘çº§åˆ« `concurrencyLevel` å¤§å°ï¼Œå¦‚æœå¤§äºæœ€å¤§å€¼ï¼Œé‡ç½®ä¸ºæœ€å¤§å€¼ã€‚æ— å‚æ„é€ **é»˜è®¤å€¼æ˜¯ 16.**
3. å¯»æ‰¾å¹¶å‘çº§åˆ« `concurrencyLevel` ä¹‹ä¸Šæœ€è¿‘çš„ **2 çš„å¹‚æ¬¡æ–¹**å€¼ï¼Œä½œä¸ºåˆå§‹åŒ–å®¹é‡å¤§å°ï¼Œ**é»˜è®¤æ˜¯ 16**ã€‚
4. è®°å½• `segmentShift` åç§»é‡ï¼Œè¿™ä¸ªå€¼ä¸ºã€å®¹é‡ =  2 çš„Næ¬¡æ–¹ã€‘ä¸­çš„ Nï¼Œåœ¨åé¢ Put æ—¶è®¡ç®—ä½ç½®æ—¶ä¼šç”¨åˆ°ã€‚**é»˜è®¤æ˜¯ 32 - sshift = 28**.
5. è®°å½• `segmentMask`ï¼Œé»˜è®¤æ˜¯ ssize - 1 = 16 -1 = 15.
6. **åˆå§‹åŒ– `segments[0]`**ï¼Œ**é»˜è®¤å¤§å°ä¸º 2**ï¼Œ**è´Ÿè½½å› å­ 0.75**ï¼Œ**æ‰©å®¹é˜€å€¼æ˜¯ 2*0.75=1.5**ï¼Œæ’å…¥ç¬¬äºŒä¸ªå€¼æ—¶æ‰ä¼šè¿›è¡Œæ‰©å®¹ã€‚

> **putæ–¹æ³•**

æ¥ç€ä¸Šé¢çš„åˆå§‹åŒ–å‚æ•°ç»§ç»­æŸ¥çœ‹ put æ–¹æ³•æºç ã€‚

```java
/**
 * Maps the specified key to the specified value in this table.
 * Neither the key nor the value can be null.
 *
 * <p> The value can be retrieved by calling the <tt>get</tt> method
 * with a key that is equal to the original key.
 *
 * @param key key with which the specified value is to be associated
 * @param value value to be associated with the specified key
 * @return the previous value associated with <tt>key</tt>, or
 *         <tt>null</tt> if there was no mapping for <tt>key</tt>
 * @throws NullPointerException if the specified key or value is null
 */
public V put(K key, V value) {
    Segment<K,V> s;
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    // hash å€¼æ— ç¬¦å·å³ç§» 28ä½ï¼ˆåˆå§‹åŒ–æ—¶è·å¾—ï¼‰ï¼Œç„¶åä¸ segmentMask=15 åšä¸è¿ç®—
    // å…¶å®ä¹Ÿå°±æ˜¯æŠŠé«˜4ä½ä¸segmentMaskï¼ˆ1111ï¼‰åšä¸è¿ç®—
    int j = (hash >>> segmentShift) & segmentMask;
    if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment
        // å¦‚æœæŸ¥æ‰¾åˆ°çš„ Segment ä¸ºç©ºï¼Œåˆå§‹åŒ–
        s = ensureSegment(j);
    return s.put(key, hash, value, false);
}

/**
 * Returns the segment for the given index, creating it and
 * recording in segment table (via CAS) if not already present.
 *
 * @param k the index
 * @return the segment
 */
@SuppressWarnings("unchecked")
private Segment<K,V> ensureSegment(int k) {
    final Segment<K,V>[] ss = this.segments;
    long u = (k << SSHIFT) + SBASE; // raw offset
    Segment<K,V> seg;
    // åˆ¤æ–­ u ä½ç½®çš„ Segment æ˜¯å¦ä¸ºnull
    if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {
        Segment<K,V> proto = ss[0]; // use segment 0 as prototype
        // è·å–0å· segment é‡Œçš„ HashEntry<K,V> åˆå§‹åŒ–é•¿åº¦
        int cap = proto.table.length;
        // è·å–0å· segment é‡Œçš„ hash è¡¨é‡Œçš„æ‰©å®¹è´Ÿè½½å› å­ï¼Œæ‰€æœ‰çš„ segment çš„ loadFactor æ˜¯ç›¸åŒçš„
        float lf = proto.loadFactor;
        // è®¡ç®—æ‰©å®¹é˜€å€¼
        int threshold = (int)(cap * lf);
        // åˆ›å»ºä¸€ä¸ª cap å®¹é‡çš„ HashEntry æ•°ç»„
        HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];
        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) { // recheck
            // å†æ¬¡æ£€æŸ¥ u ä½ç½®çš„ Segment æ˜¯å¦ä¸ºnullï¼Œå› ä¸ºè¿™æ—¶å¯èƒ½æœ‰å…¶ä»–çº¿ç¨‹è¿›è¡Œäº†æ“ä½œ
            Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);
            // è‡ªæ—‹æ£€æŸ¥ u ä½ç½®çš„ Segment æ˜¯å¦ä¸ºnull
            while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))
                   == null) {
                // ä½¿ç”¨CAS èµ‹å€¼ï¼Œåªä¼šæˆåŠŸä¸€æ¬¡
                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
                    break;
            }
        }
    }
    return seg;
}
```

ä¸Šé¢çš„æºç åˆ†æäº† `ConcurrentHashMap` åœ¨ put ä¸€ä¸ªæ•°æ®æ—¶çš„å¤„ç†æµç¨‹ï¼Œä¸‹é¢æ¢³ç†ä¸‹å…·ä½“æµç¨‹ã€‚

1. è®¡ç®—è¦ put çš„ key çš„ä½ç½®ï¼Œè·å–æŒ‡å®šä½ç½®çš„ `Segment`ã€‚

2. å¦‚æœæŒ‡å®šä½ç½®çš„ `Segment` ä¸ºç©ºï¼Œåˆ™åˆå§‹åŒ–è¿™ä¸ª `Segment`.

   **åˆå§‹åŒ– Segment æµç¨‹ï¼š**

   1. æ£€æŸ¥è®¡ç®—å¾—åˆ°çš„ä½ç½®çš„ `Segment` æ˜¯å¦ä¸ºnull.
   2. ä¸º null ç»§ç»­åˆå§‹åŒ–ï¼Œä½¿ç”¨ `Segment[0]` çš„å®¹é‡å’Œè´Ÿè½½å› å­åˆ›å»ºä¸€ä¸ª `HashEntry` æ•°ç»„ã€‚
   3. å†æ¬¡æ£€æŸ¥è®¡ç®—å¾—åˆ°çš„æŒ‡å®šä½ç½®çš„ `Segment` æ˜¯å¦ä¸ºnull.
   4. ä½¿ç”¨åˆ›å»ºçš„ `HashEntry` æ•°ç»„åˆå§‹åŒ–è¿™ä¸ª Segment.
   5. è‡ªæ—‹åˆ¤æ–­è®¡ç®—å¾—åˆ°çš„æŒ‡å®šä½ç½®çš„ `Segment` æ˜¯å¦ä¸ºnullï¼Œä½¿ç”¨ CAS åœ¨è¿™ä¸ªä½ç½®èµ‹å€¼ä¸º `Segment`.

3. `Segment.put` æ’å…¥ key,value å€¼ã€‚

ä¸Šé¢æ¢ç©¶äº†è·å– `Segment` æ®µå’Œåˆå§‹åŒ– `Segment` æ®µçš„æ“ä½œã€‚æœ€åä¸€è¡Œçš„ `Segment` çš„ put æ–¹æ³•è¿˜æ²¡æœ‰æŸ¥çœ‹ï¼Œç»§ç»­åˆ†æã€‚

```java
final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    // è·å– ReentrantLock ç‹¬å é”ï¼Œè·å–ä¸åˆ°ï¼ŒscanAndLockForPut è·å–ã€‚
    HashEntry<K,V> node = tryLock() ? null : scanAndLockForPut(key, hash, value);
    V oldValue;
    try {
        HashEntry<K,V>[] tab = table;
        // è®¡ç®—è¦putçš„æ•°æ®ä½ç½®
        int index = (tab.length - 1) & hash;
        // CAS è·å– index åæ ‡çš„å€¼
        HashEntry<K,V> first = entryAt(tab, index);
        for (HashEntry<K,V> e = first;;) {
            if (e != null) {
                // æ£€æŸ¥æ˜¯å¦ key å·²ç»å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨ï¼Œåˆ™éå†é“¾è¡¨å¯»æ‰¾ä½ç½®ï¼Œæ‰¾åˆ°åæ›¿æ¢ value
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash && key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {
                // first æœ‰å€¼æ²¡è¯´æ˜ index ä½ç½®å·²ç»æœ‰å€¼äº†ï¼Œæœ‰å†²çªï¼Œé“¾è¡¨å¤´æ’æ³•ã€‚
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry<K,V>(hash, key, value, first);
                int c = count + 1;
                // å®¹é‡å¤§äºæ‰©å®¹é˜€å€¼ï¼Œå°äºæœ€å¤§å®¹é‡ï¼Œè¿›è¡Œæ‰©å®¹
                if (c > threshold && tab.length < MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    // index ä½ç½®èµ‹å€¼ nodeï¼Œnode å¯èƒ½æ˜¯ä¸€ä¸ªå…ƒç´ ï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ªé“¾è¡¨çš„è¡¨å¤´
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        unlock();
    }
    return oldValue;
}
```

ç”±äº `Segment` ç»§æ‰¿äº† `ReentrantLock`ï¼Œæ‰€ä»¥ `Segment` å†…éƒ¨å¯ä»¥å¾ˆæ–¹ä¾¿çš„è·å–é”ï¼Œput æµç¨‹å°±ç”¨åˆ°äº†è¿™ä¸ªåŠŸèƒ½ã€‚

1. `tryLock()` è·å–é”ï¼Œè·å–ä¸åˆ°ä½¿ç”¨  **`scanAndLockForPut`** æ–¹æ³•ç»§ç»­è·å–ã€‚

2. è®¡ç®— put çš„æ•°æ®è¦æ”¾å…¥çš„ index ä½ç½®ï¼Œç„¶åè·å–è¿™ä¸ªä½ç½®ä¸Šçš„ `HashEntry` ã€‚

3. éå† put æ–°å…ƒç´ ï¼Œä¸ºä»€ä¹ˆè¦éå†ï¼Ÿå› ä¸ºè¿™é‡Œè·å–çš„ `HashEntry` å¯èƒ½æ˜¯ä¸€ä¸ªç©ºå…ƒç´ ï¼Œä¹Ÿå¯èƒ½æ˜¯é“¾è¡¨å·²å­˜åœ¨ï¼Œæ‰€ä»¥è¦åŒºåˆ«å¯¹å¾…ã€‚

   å¦‚æœè¿™ä¸ªä½ç½®ä¸Šçš„ **`HashEntry` ä¸å­˜åœ¨**ï¼š

   1. å¦‚æœå½“å‰å®¹é‡å¤§äºæ‰©å®¹é˜€å€¼ï¼Œå°äºæœ€å¤§å®¹é‡ï¼Œ**è¿›è¡Œæ‰©å®¹**ã€‚
   2. ç›´æ¥å¤´æ’æ³•æ’å…¥ã€‚

   å¦‚æœè¿™ä¸ªä½ç½®ä¸Šçš„ **`HashEntry` å­˜åœ¨**ï¼š

   1. åˆ¤æ–­é“¾è¡¨å½“å‰å…ƒç´  key å’Œ hash å€¼æ˜¯å¦å’Œè¦ put çš„ key å’Œ hash å€¼ä¸€è‡´ã€‚ä¸€è‡´åˆ™æ›¿æ¢å€¼
   2. ä¸ä¸€è‡´ï¼Œè·å–é“¾è¡¨ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç›´åˆ°å‘ç°ç›¸åŒè¿›è¡Œå€¼æ›¿æ¢ï¼Œæˆ–è€…é“¾è¡¨è¡¨é‡Œå®Œæ¯•æ²¡æœ‰ç›¸åŒçš„ã€‚
      1. å¦‚æœå½“å‰å®¹é‡å¤§äºæ‰©å®¹é˜€å€¼ï¼Œå°äºæœ€å¤§å®¹é‡ï¼Œ**è¿›è¡Œæ‰©å®¹**ã€‚
      2. ç›´æ¥é“¾è¡¨å¤´æ’æ³•æ’å…¥ã€‚

4. å¦‚æœè¦æ’å…¥çš„ä½ç½®ä¹‹å‰å·²ç»å­˜åœ¨ï¼Œæ›¿æ¢åè¿”å›æ—§å€¼ï¼Œå¦åˆ™è¿”å› null.

è¿™é‡Œé¢çš„ç¬¬ä¸€æ­¥ä¸­çš„ `scanAndLockForPut` æ“ä½œè¿™é‡Œæ²¡æœ‰ä»‹ç»ï¼Œè¿™ä¸ªæ–¹æ³•åšçš„æ“ä½œå°±æ˜¯ä¸æ–­çš„è‡ªæ—‹ `tryLock()` è·å–é”ã€‚å½“è‡ªæ—‹æ¬¡æ•°å¤§äºæŒ‡å®šæ¬¡æ•°æ—¶ï¼Œä½¿ç”¨ `lock()` é˜»å¡è·å–é”ã€‚åœ¨è‡ªæ—‹æ—¶é¡ºè¡¨è·å–ä¸‹ hash ä½ç½®çš„ `HashEntry`ã€‚

```java
private HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {
    HashEntry<K,V> first = entryForHash(this, hash);
    HashEntry<K,V> e = first;
    HashEntry<K,V> node = null;
    int retries = -1; // negative while locating node
    // è‡ªæ—‹è·å–é”
    while (!tryLock()) {
        HashEntry<K,V> f; // to recheck first below
        if (retries < 0) {
            if (e == null) {
                if (node == null) // speculatively create node
                    node = new HashEntry<K,V>(hash, key, value, null);
                retries = 0;
            }
            else if (key.equals(e.key))
                retries = 0;
            else
                e = e.next;
        }
        else if (++retries > MAX_SCAN_RETRIES) {
            // è‡ªæ—‹è¾¾åˆ°æŒ‡å®šæ¬¡æ•°åï¼Œé˜»å¡ç­‰åˆ°åªåˆ°è·å–åˆ°é”
            lock();
            break;
        }
        else if ((retries & 1) == 0 &&
                 (f = entryForHash(this, hash)) != first) {
            e = first = f; // re-traverse if entry changed
            retries = -1;
        }
    }
    return node;
}

```

> **æ‰©å®¹ rehash**

`ConcurrentHashMap` çš„æ‰©å®¹åªä¼šæ‰©å®¹åˆ°åŸæ¥çš„ä¸¤å€ã€‚è€æ•°ç»„é‡Œçš„æ•°æ®ç§»åŠ¨åˆ°æ–°çš„æ•°ç»„æ—¶ï¼Œä½ç½®è¦ä¹ˆä¸å˜ï¼Œè¦ä¹ˆå˜ä¸º `index+ oldSize`ï¼Œå‚æ•°é‡Œçš„ node ä¼šåœ¨æ‰©å®¹ä¹‹åä½¿ç”¨é“¾è¡¨**å¤´æ’æ³•**æ’å…¥åˆ°æŒ‡å®šä½ç½®ã€‚

```java
private void rehash(HashEntry<K,V> node) {
    HashEntry<K,V>[] oldTable = table;
    // è€å®¹é‡
    int oldCapacity = oldTable.length;
    // æ–°å®¹é‡ï¼Œæ‰©å¤§ä¸¤å€
    int newCapacity = oldCapacity << 1;
    // æ–°çš„æ‰©å®¹é˜€å€¼ 
    threshold = (int)(newCapacity * loadFactor);
    // åˆ›å»ºæ–°çš„æ•°ç»„
    HashEntry<K,V>[] newTable = (HashEntry<K,V>[]) new HashEntry[newCapacity];
    // æ–°çš„æ©ç ï¼Œé»˜è®¤2æ‰©å®¹åæ˜¯4ï¼Œ-1æ˜¯3ï¼ŒäºŒè¿›åˆ¶å°±æ˜¯11ã€‚
    int sizeMask = newCapacity - 1;
    for (int i = 0; i < oldCapacity ; i++) {
        // éå†è€æ•°ç»„
        HashEntry<K,V> e = oldTable[i];
        if (e != null) {
            HashEntry<K,V> next = e.next;
            // è®¡ç®—æ–°çš„ä½ç½®ï¼Œæ–°çš„ä½ç½®åªå¯èƒ½æ˜¯ä¸ä¾¿æˆ–è€…æ˜¯è€çš„ä½ç½®+è€çš„å®¹é‡ã€‚
            int idx = e.hash & sizeMask;
            if (next == null)   //  Single node on list
                // å¦‚æœå½“å‰ä½ç½®è¿˜ä¸æ˜¯é“¾è¡¨ï¼Œåªæ˜¯ä¸€ä¸ªå…ƒç´ ï¼Œç›´æ¥èµ‹å€¼
                newTable[idx] = e;
            else { // Reuse consecutive sequence at same slot
                // å¦‚æœæ˜¯é“¾è¡¨äº†
                HashEntry<K,V> lastRun = e;
                int lastIdx = idx;
                // æ–°çš„ä½ç½®åªå¯èƒ½æ˜¯ä¸ä¾¿æˆ–è€…æ˜¯è€çš„ä½ç½®+è€çš„å®¹é‡ã€‚
                // éå†ç»“æŸåï¼ŒlastRun åé¢çš„å…ƒç´ ä½ç½®éƒ½æ˜¯ç›¸åŒçš„
                for (HashEntry<K,V> last = next; last != null; last = last.next) {
                    int k = last.hash & sizeMask;
                    if (k != lastIdx) {
                        lastIdx = k;
                        lastRun = last;
                    }
                }
                // ï¼ŒlastRun åé¢çš„å…ƒç´ ä½ç½®éƒ½æ˜¯ç›¸åŒçš„ï¼Œç›´æ¥ä½œä¸ºé“¾è¡¨èµ‹å€¼åˆ°æ–°ä½ç½®ã€‚
                newTable[lastIdx] = lastRun;
                // Clone remaining nodes
                for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {
                    // éå†å‰©ä½™å…ƒç´ ï¼Œå¤´æ’æ³•åˆ°æŒ‡å®š k ä½ç½®ã€‚
                    V v = p.value;
                    int h = p.hash;
                    int k = h & sizeMask;
                    HashEntry<K,V> n = newTable[k];
                    newTable[k] = new HashEntry<K,V>(h, p.key, v, n);
                }
            }
        }
    }
    // å¤´æ’æ³•æ’å…¥æ–°çš„èŠ‚ç‚¹
    int nodeIndex = node.hash & sizeMask; // add the new node
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] = node;
    table = newTable;
}
```

æœ‰äº›åŒå­¦å¯èƒ½ä¼šå¯¹æœ€åçš„ä¸¤ä¸ª for å¾ªç¯æœ‰ç–‘æƒ‘ï¼Œè¿™é‡Œç¬¬ä¸€ä¸ª for æ˜¯ä¸ºäº†å¯»æ‰¾è¿™æ ·ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™ä¸ªèŠ‚ç‚¹åé¢çš„æ‰€æœ‰ next èŠ‚ç‚¹çš„æ–°ä½ç½®éƒ½æ˜¯ç›¸åŒçš„ã€‚ç„¶åæŠŠè¿™ä¸ªä½œä¸ºä¸€ä¸ªé“¾è¡¨èµ‹å€¼åˆ°æ–°ä½ç½®ã€‚ç¬¬äºŒä¸ª for å¾ªç¯æ˜¯ä¸ºäº†æŠŠå‰©ä½™çš„å…ƒç´ é€šè¿‡å¤´æ’æ³•æ’å…¥åˆ°æŒ‡å®šä½ç½®é“¾è¡¨ã€‚è¿™æ ·å®ç°çš„åŸå› å¯èƒ½æ˜¯åŸºäºæ¦‚ç‡ç»Ÿè®¡ï¼Œæœ‰æ·±å…¥ç ”ç©¶çš„åŒå­¦å¯ä»¥å‘è¡¨ä¸‹æ„è§ã€‚

> **getæ–¹æ³•**

åˆ°è¿™é‡Œå°±å¾ˆç®€å•äº†ï¼Œget æ–¹æ³•åªéœ€è¦ä¸¤æ­¥å³å¯ã€‚

1. è®¡ç®—å¾—åˆ° key çš„å­˜æ”¾ä½ç½®ã€‚
2. éå†æŒ‡å®šä½ç½®æŸ¥æ‰¾ç›¸åŒ key çš„ value å€¼ã€‚

```java
public V get(Object key) {
    Segment<K,V> s; // manually integrate access methods to reduce overhead
    HashEntry<K,V>[] tab;
    int h = hash(key);
    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
    // è®¡ç®—å¾—åˆ° key çš„å­˜æ”¾ä½ç½®
    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
        (tab = s.table) != null) {
        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
             e != null; e = e.next) {
            // å¦‚æœæ˜¯é“¾è¡¨ï¼Œéå†æŸ¥æ‰¾åˆ°ç›¸åŒ key çš„ valueã€‚
            K k;
            if ((k = e.key) == key || (e.hash == h && key.equals(k)))
                return e.value;
        }
    }
    return null;
}
```

### 5.4.2 ConcurrentHashMap 1.8

> **å­˜å‚¨ç»“æ„**

![Java8 ConcurrentHashMap å­˜å‚¨ç»“æ„ï¼ˆå›¾ç‰‡æ¥è‡ª javadoopï¼‰](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java8_concurrenthashmap.png)

å¯ä»¥å‘ç° Java8 çš„ ConcurrentHashMap  ç›¸å¯¹äº Java7 æ¥è¯´å˜åŒ–æ¯”è¾ƒå¤§ï¼Œä¸å†æ˜¯ä¹‹å‰çš„ **Segment æ•°ç»„ + HashEntry æ•°ç»„ + é“¾è¡¨**ï¼Œè€Œæ˜¯ **Node æ•°ç»„ + é“¾è¡¨ / çº¢é»‘æ ‘**ã€‚å½“å†²çªé“¾è¡¨è¾¾åˆ°ä¸€å®šé•¿åº¦æ—¶ï¼Œé“¾è¡¨ä¼šè½¬æ¢æˆçº¢é»‘æ ‘ã€‚

> **åˆå§‹åŒ– initTable**

```java
/**
 * Initializes table, using the size recorded in sizeCtl.
 */
private final Node<K,V>[] initTable() {
    Node<K,V>[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        //ã€€å¦‚æœ sizeCtl < 0 ,è¯´æ˜å¦å¤–çš„çº¿ç¨‹æ‰§è¡ŒCAS æˆåŠŸï¼Œæ­£åœ¨è¿›è¡Œåˆå§‹åŒ–ã€‚
        if ((sc = sizeCtl) < 0)
            // è®©å‡º CPU ä½¿ç”¨æƒ
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings("unchecked")
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    sc = n - (n >>> 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
```

ä»æºç ä¸­å¯ä»¥å‘ç° `ConcurrentHashMap` çš„åˆå§‹åŒ–æ˜¯é€šè¿‡**è‡ªæ—‹å’Œ CAS** æ“ä½œå®Œæˆçš„ã€‚é‡Œé¢éœ€è¦æ³¨æ„çš„æ˜¯å˜é‡ `sizeCtl` ï¼Œå®ƒçš„å€¼å†³å®šç€å½“å‰çš„åˆå§‹åŒ–çŠ¶æ€ã€‚

1. -1  è¯´æ˜æ­£åœ¨åˆå§‹åŒ–
2. -N è¯´æ˜æœ‰N-1ä¸ªçº¿ç¨‹æ­£åœ¨è¿›è¡Œæ‰©å®¹
3. è¡¨ç¤º table åˆå§‹åŒ–å¤§å°ï¼Œå¦‚æœ table æ²¡æœ‰åˆå§‹åŒ–
4. è¡¨ç¤º table å®¹é‡ï¼Œå¦‚æœ tableã€€å·²ç»åˆå§‹åŒ–ã€‚

> **putæ–¹æ³•**

ç›´æ¥è¿‡ä¸€é put æºç ã€‚

```java
public V put(K key, V value) {
    return putVal(key, value, false);
}

/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
    // key å’Œ value ä¸èƒ½ä¸ºç©º
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node<K,V>[] tab = table;;) {
        // f = ç›®æ ‡ä½ç½®å…ƒç´ 
        Node<K,V> f; int n, i, fh;// fh åé¢å­˜æ”¾ç›®æ ‡ä½ç½®çš„å…ƒç´  hash å€¼
        if (tab == null || (n = tab.length) == 0)
            // æ•°ç»„æ¡¶ä¸ºç©ºï¼Œåˆå§‹åŒ–æ•°ç»„æ¡¶ï¼ˆè‡ªæ—‹+CAS)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            // æ¡¶å†…ä¸ºç©ºï¼ŒCAS æ”¾å…¥ï¼Œä¸åŠ é”ï¼ŒæˆåŠŸäº†å°±ç›´æ¥ break è·³å‡º
            if (casTabAt(tab, i, null,new Node<K,V>(hash, key, value, null)))
                break;  // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            // ä½¿ç”¨ synchronized åŠ é”åŠ å…¥èŠ‚ç‚¹
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    // è¯´æ˜æ˜¯é“¾è¡¨
                    if (fh >= 0) {
                        binCount = 1;
                        // å¾ªç¯åŠ å…¥æ–°çš„æˆ–è€…è¦†ç›–èŠ‚ç‚¹
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        // çº¢é»‘æ ‘
                        Node<K,V> p;
                        binCount = 2;
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
```

1. æ ¹æ® key è®¡ç®—å‡º hashcode ã€‚

2. åˆ¤æ–­æ˜¯å¦éœ€è¦è¿›è¡Œåˆå§‹åŒ–ã€‚

3. å³ä¸ºå½“å‰ key å®šä½å‡ºçš„ Nodeï¼Œå¦‚æœä¸ºç©ºè¡¨ç¤ºå½“å‰ä½ç½®å¯ä»¥å†™å…¥æ•°æ®ï¼Œåˆ©ç”¨ CAS å°è¯•å†™å…¥ï¼Œå¤±è´¥åˆ™è‡ªæ—‹ä¿è¯æˆåŠŸã€‚

4. å¦‚æœå½“å‰ä½ç½®çš„ `hashcode == MOVED == -1`,åˆ™éœ€è¦è¿›è¡Œæ‰©å®¹ã€‚

5. å¦‚æœéƒ½ä¸æ»¡è¶³ï¼Œåˆ™åˆ©ç”¨ synchronized é”å†™å…¥æ•°æ®ã€‚

6. å¦‚æœæ•°é‡å¤§äº `TREEIFY_THRESHOLD` åˆ™è¦æ‰§è¡Œæ ‘åŒ–æ–¹æ³•ï¼Œåœ¨ `treeifyBin` ä¸­ä¼šé¦–å…ˆåˆ¤æ–­å½“å‰æ•°ç»„é•¿åº¦â‰¥64æ—¶æ‰ä¼šå°†é“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘ã€‚

> **getæ–¹æ³•**

get æµç¨‹æ¯”è¾ƒç®€å•ï¼Œç›´æ¥è¿‡ä¸€éæºç ã€‚

```java
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    // key æ‰€åœ¨çš„ hash ä½ç½®
    int h = spread(key.hashCode());
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (e = tabAt(tab, (n - 1) & h)) != null) {
        // å¦‚æœæŒ‡å®šä½ç½®å…ƒç´ å­˜åœ¨ï¼Œå¤´ç»“ç‚¹hashå€¼ç›¸åŒ
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                // key hash å€¼ç›¸ç­‰ï¼Œkeyå€¼ç›¸åŒï¼Œç›´æ¥è¿”å›å…ƒç´  value
                return e.val;
        }
        else if (eh < 0)
            // å¤´ç»“ç‚¹hashå€¼å°äº0ï¼Œè¯´æ˜æ­£åœ¨æ‰©å®¹æˆ–è€…æ˜¯çº¢é»‘æ ‘ï¼ŒfindæŸ¥æ‰¾
            return (p = e.find(h, key)) != null ? p.val : null;
        while ((e = e.next) != null) {
            // æ˜¯é“¾è¡¨ï¼Œéå†æŸ¥æ‰¾
            if (e.hash == h &&
                ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
```

æ€»ç»“ä¸€ä¸‹ get è¿‡ç¨‹ï¼š

1. æ ¹æ® hash å€¼è®¡ç®—ä½ç½®ã€‚
2. æŸ¥æ‰¾åˆ°æŒ‡å®šä½ç½®ï¼Œå¦‚æœå¤´èŠ‚ç‚¹å°±æ˜¯è¦æ‰¾çš„ï¼Œç›´æ¥è¿”å›å®ƒçš„ value.
3. å¦‚æœå¤´èŠ‚ç‚¹ hash å€¼å°äº 0 ï¼Œè¯´æ˜æ­£åœ¨æ‰©å®¹æˆ–è€…æ˜¯çº¢é»‘æ ‘ï¼ŒæŸ¥æ‰¾ä¹‹ã€‚
4. å¦‚æœæ˜¯é“¾è¡¨ï¼Œéå†æŸ¥æ‰¾ä¹‹ã€‚

æ€»ç»“ï¼š

æ€»çš„æ¥è¯´ `ConcurrentHashMap` åœ¨ Java8 ä¸­ç›¸å¯¹äº Java7 æ¥è¯´å˜åŒ–è¿˜æ˜¯æŒºå¤§çš„ï¼Œ

### 5.4.3 æ€»ç»“

Java7 ä¸­ `ConcurrentHashMap` ä½¿ç”¨çš„åˆ†æ®µé”ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸€ä¸ª Segment ä¸ŠåŒæ—¶åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥æ“ä½œï¼Œæ¯ä¸€ä¸ª `Segment` éƒ½æ˜¯ä¸€ä¸ªç±»ä¼¼ `HashMap` æ•°ç»„çš„ç»“æ„ï¼Œå®ƒå¯ä»¥æ‰©å®¹ï¼Œå®ƒçš„å†²çªä¼šè½¬åŒ–ä¸ºé“¾è¡¨ã€‚ä½†æ˜¯ `Segment` çš„ä¸ªæ•°ä¸€ä½†åˆå§‹åŒ–å°±ä¸èƒ½æ”¹å˜ã€‚

Java8 ä¸­çš„ `ConcurrentHashMap`  ä½¿ç”¨çš„ `Synchronized` é”åŠ  CAS çš„æœºåˆ¶ã€‚ç»“æ„ä¹Ÿç”± Java7 ä¸­çš„ **`Segment` æ•°ç»„ + `HashEntry` æ•°ç»„ + é“¾è¡¨** è¿›åŒ–æˆäº†  **Node æ•°ç»„ + é“¾è¡¨ / çº¢é»‘æ ‘**ï¼ŒNode æ˜¯ç±»ä¼¼äºä¸€ä¸ª HashEntry çš„ç»“æ„ã€‚å®ƒçš„å†²çªå†è¾¾åˆ°ä¸€å®šå¤§å°æ—¶ä¼šè½¬åŒ–æˆçº¢é»‘æ ‘ï¼Œåœ¨å†²çªå°äºä¸€å®šæ•°é‡æ—¶åˆé€€å›é“¾è¡¨ã€‚

æœ‰äº›åŒå­¦å¯èƒ½å¯¹ `Synchronized` çš„æ€§èƒ½å­˜åœ¨ç–‘é—®ï¼Œå…¶å® `Synchronized` é”è‡ªä»å¼•å…¥é”å‡çº§ç­–ç•¥åï¼Œæ€§èƒ½ä¸å†æ˜¯é—®é¢˜ï¼Œæœ‰å…´è¶£çš„åŒå­¦å¯ä»¥è‡ªå·±äº†è§£ä¸‹ `Synchronized` çš„**é”å‡çº§**ã€‚

# å…­ã€Collectionså·¥å…·ç±»

## 6.1 æ’åºæ“ä½œ

```java
void reverse(List list)//åè½¬
void shuffle(List list)//éšæœºæ’åº
void sort(List list)//æŒ‰è‡ªç„¶æ’åºçš„å‡åºæ’åº
void sort(List list, Comparator c)//å®šåˆ¶æ’åºï¼Œç”±Comparatoræ§åˆ¶æ’åºé€»è¾‘
void swap(List list, int i , int j)//äº¤æ¢ä¸¤ä¸ªç´¢å¼•ä½ç½®çš„å…ƒç´ 
void rotate(List list, int distance)//æ—‹è½¬ã€‚å½“distanceä¸ºæ­£æ•°æ—¶ï¼Œå°†listådistanceä¸ªå…ƒç´ æ•´ä½“ç§»åˆ°å‰é¢ã€‚å½“distanceä¸ºè´Ÿæ•°æ—¶ï¼Œå°† listçš„å‰distanceä¸ªå…ƒç´ æ•´ä½“ç§»åˆ°åé¢
```

## 6.2 æŸ¥æ‰¾,æ›¿æ¢æ“ä½œ

```java
int binarySearch(List list, Object key)//å¯¹Listè¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ï¼Œè¿”å›ç´¢å¼•ï¼Œæ³¨æ„Listå¿…é¡»æ˜¯æœ‰åºçš„
int max(Collection coll)//æ ¹æ®å…ƒç´ çš„è‡ªç„¶é¡ºåºï¼Œè¿”å›æœ€å¤§çš„å…ƒç´ ã€‚ ç±»æ¯”int min(Collection coll)
int max(Collection coll, Comparator c)//æ ¹æ®å®šåˆ¶æ’åºï¼Œè¿”å›æœ€å¤§å…ƒç´ ï¼Œæ’åºè§„åˆ™ç”±Comparatatorç±»æ§åˆ¶ã€‚ç±»æ¯”int min(Collection coll, Comparator c)
void fill(List list, Object obj)//ç”¨æŒ‡å®šçš„å…ƒç´ ä»£æ›¿æŒ‡å®šlistä¸­çš„æ‰€æœ‰å…ƒç´ 
int frequency(Collection c, Object o)//ç»Ÿè®¡å…ƒç´ å‡ºç°æ¬¡æ•°
int indexOfSubList(List list, List target)//ç»Ÿè®¡targetåœ¨listä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ç´¢å¼•ï¼Œæ‰¾ä¸åˆ°åˆ™è¿”å›-1ï¼Œç±»æ¯”int lastIndexOfSubList(List source, list target)
boolean replaceAll(List list, Object oldVal, Object newVal)//ç”¨æ–°å…ƒç´ æ›¿æ¢æ—§å…ƒç´ 
```

## 6.3 åŒæ­¥æ§åˆ¶

`Collections` æä¾›äº†å¤šä¸ª`synchronizedXxx()`æ–¹æ³•Â·ï¼Œè¯¥æ–¹æ³•å¯ä»¥å°†æŒ‡å®šé›†åˆåŒ…è£…æˆçº¿ç¨‹åŒæ­¥çš„é›†åˆï¼Œä»è€Œè§£å†³å¤šçº¿ç¨‹å¹¶å‘è®¿é—®é›†åˆæ—¶çš„çº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚

æˆ‘ä»¬çŸ¥é“ `HashSet`ï¼Œ`TreeSet`ï¼Œ`ArrayList`,`LinkedList`,`HashMap`,`TreeMap` éƒ½æ˜¯çº¿ç¨‹ä¸å®‰å…¨çš„ã€‚`Collections` æä¾›äº†å¤šä¸ªé™æ€æ–¹æ³•å¯ä»¥æŠŠä»–ä»¬åŒ…è£…æˆçº¿ç¨‹åŒæ­¥çš„é›†åˆã€‚

**æœ€å¥½ä¸è¦ç”¨ä¸‹é¢è¿™äº›æ–¹æ³•ï¼Œæ•ˆç‡éå¸¸ä½ï¼Œéœ€è¦çº¿ç¨‹å®‰å…¨çš„é›†åˆç±»å‹æ—¶è¯·è€ƒè™‘ä½¿ç”¨ JUC åŒ…ä¸‹çš„å¹¶å‘é›†åˆã€‚**

æ–¹æ³•å¦‚ä¸‹ï¼š

```java
synchronizedCollection(Collection<T>  c) //è¿”å›æŒ‡å®š collection æ”¯æŒçš„åŒæ­¥ï¼ˆçº¿ç¨‹å®‰å…¨çš„ï¼‰collectionã€‚
synchronizedList(List<T> list)//è¿”å›æŒ‡å®šåˆ—è¡¨æ”¯æŒçš„åŒæ­¥ï¼ˆçº¿ç¨‹å®‰å…¨çš„ï¼‰Listã€‚
synchronizedMap(Map<K,V> m) //è¿”å›ç”±æŒ‡å®šæ˜ å°„æ”¯æŒçš„åŒæ­¥ï¼ˆçº¿ç¨‹å®‰å…¨çš„ï¼‰Mapã€‚
synchronizedSet(Set<T> s) //è¿”å›æŒ‡å®š set æ”¯æŒçš„åŒæ­¥ï¼ˆçº¿ç¨‹å®‰å…¨çš„ï¼‰setã€‚
```