# 三、虚拟内存

## 3.1 虚拟内存

操作系统为了保证每个进程之间独立运行，互补干涉，因此操作系统为每个进程分配一条独立的「虚拟地址」。

操作系统将提供一种机制将不同地址的虚拟地址与不同内存的物理地址映射起来。

> **虚拟内存与物理内存**
- 虚拟内存：程序中所使用的内存地址称之为虚拟内存地址(Virtual Memory Address)
- 物理内存地址:实际硬件中的空间地址称之为物理内存地址(Physical Memory Address)

> **操作系统如何管理虚拟地址与物理地址之间的映射**

为了将虚拟地址映射为物理地址，CPU会通过内存管理单元(MMU)来实现虚拟地址到物理地址的映射
![MMU](https://camo.githubusercontent.com/cc1e9e6fe08c9ba9bc9a1f8f1a4fe17c2ab0fac798f3afdc4419c43f9a333165/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f352d4d4d552545382539392539412545362538422539462545352539432542302545352539442538302545382542442541432545362538442541322545372538392541392545372539302538362545352539432542302545352539442538302e6a7067)

**实现方式主要有两种：**
- 内存分段
- 内存分页

## 3.2 内存分段

程序是由若干个逻辑分段组成的，如可由**代码分段、数据分段、栈段、堆段**组成。不同的段是有不同的属性的，所以**就用分段（Segmentation）的形式把这些段分离出来。**

## 3.2.1 分段机制下虚拟地址与物理地址实现映射

分段机制下，虚拟内存由两部分组成：
- 段选择因子：由段号和特权等标志位组成，段选择因子保存在段寄存器中。其中最重要的是段号，段号用作段表的索引，可以从段表中获取段的基地址、段界限与特权等级等信息。


- 段内偏移量： 位于0与段界限之间，如果段内偏移量是合法的，就将**段基址+段内偏移量=物理地址的内存地址**

![内存分段中虚拟地址与物理地址的映射](https://camo.githubusercontent.com/aeb8acea4ca35fb50597d41cda3a59320e8518ec2ca3b3a0595e25389ae29f69/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f362d2545352538382538362545362541452542352545352541462542422545352539442538302e6a7067)

> **虚拟地址到物理地址的映射**

分段机制会将虚拟地址分为四个段，每个段在段表中有一项，通过该项可以确定段基址，段基址+段偏移量便可确定物理地址
![](https://camo.githubusercontent.com/1eff7799c6ba1351c384d43bfe2827e0922af8298f353b22032978353a8b0832/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f372d2545352538382538362545362541452542352545352541462542422545352539442538302d2545342542452538422545352541442539302e6a7067)

### 3.2.2 内存分段存在的问题

> **内存分段存在的问题**

- 内存碎片
- 内存交换效率低下

#### 3.2.2.1 内存碎片

> **内存碎片产生的原因**

假设有1G内存，用户执行如下程序
- 游戏占内存512MB
- 浏览器占内存128MB
- 音乐占用内存256MB
- 空闲内存 128MB
如果此时关闭浏览器，那么空闲内存为256MB， 但二者不连续，因此需要打开200MB的内存会失败

![内存碎片举例](https://camo.githubusercontent.com/1c4a8bec805fa30161cf3f3bedee5f667e09109a3e91b3ebebee93bd1ef06467/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f382d2545352538382538362545362541452542352d2545352538362538352545352541442539382545372541322538452545372538392538372e6a7067)

> **内存碎片分类**
- 外部内存碎片:即产生多个不连续的小物理内存，导致新的程序无法被加载
- 内部内存碎片:加载后的内存，可能存在使用频率低的内存，因此导致内存浪费

> **解决方案**

解决外部内存碎片问题的方案就是**内存交换**

可以将音乐占用的256MB内存写到硬盘上，然后从硬盘上读回内存中，读回时需要将音乐程序装载到连续的512MB内存空间后面，这样就能空缺连续的256MB空间。

Linux 系统里的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。

#### 3.2.2.2 内存交换效率低

对多进程系统而言，分段的方式会产生很多内存碎片，需要用`swap`内存区域，因为硬盘的访问速度比内存慢，每一次交换内存，需要将大量数据写到硬盘上，该过程会产生性能瓶颈。

如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。

为了解决内存分段的内存碎片问题与内存交换效率低的问题，出现了内存分页。

## 3.3 内存分页

### 3.3.1 分页机制

分页:是将整个虚拟内存和物理内存切割为一段固定尺寸大小，这样连续并固定尺寸的内存空间，我们称之为也(page)。Linux下，每一页的大小为`4KB`。

虚拟地址与物理地址之间通过**页表**来映射，如下图:
![页表](https://camo.githubusercontent.com/39d938538e3914d45e5a60ef18cb4efd81db6d2c50ce9a3161034afda135830c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f392d2545352538382538362545392541312542352e6a7067)

页表存储在内存里，内存管理单元MMU负责将虚拟地址转换为物理地址

当进程访问的虚拟地址在页表中查询不到的时，就会产生缺页异常，进入系统内核空间分配物理内存，更新进程页表，最后再返回用户态，恢复进程运行。

### 3.3.2 分页如何解决内存碎片与内存交换效率低的问题

- 内存碎片: 因为采用了分页内存管理，释放的内存均是通过页来释放的，因此不会产生无法给进程使用的小内存。

- 内存交换效率低
  - 如果内存空间不够，操作系统会将进程中「最近没被使用」的内存页面暂存到硬盘上，称之为换出(Swap out)。需要时则将其加载进来，称之为换入(Swap in)。所以一次性写入磁盘的也只有少数的页面，花费时间较少，内存交换效率低。
  - 其次运行程序时，我们可以只将用到的对应虚拟内存页面里的指令和数据时，将对应页面加载到物理内存中去。

### 3.3.3 分页机制下，虚拟地址与物理地址的映射

分页机制下虚拟地址分为两部分
- 页号:页号作为页表的索引，页表包含页在物理内存中的基地址
- 页内偏移量
- **基地址 + 页内偏移量 = 物理内存地址**

![分页机制下虚拟地址与物理地址的映射](https://camo.githubusercontent.com/98caacae26133d9b6717ef71993ed84768dd97faf4db1f539f2e4700ffdd45f2/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f31312d2545352538382538362545392541312542352545352541462542422545352539442538302e6a7067)

> **简单分页的缺陷**

![简单分页](https://camo.githubusercontent.com/b018fd59323f2683416bc2e8b91c90f90133e6ccd658b5b6652d50ad9df7fe37/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f31322d2545352538382538362545392541312542352545352541462542422545352539442538302d2545342542452538422545352541442539302e6a7067)

使用简单分页会导致页表非常庞大，页表会占用很大的内存空间！

### 3.3.4 多级页表

为了解决单页表占用内存空间大的问题，采用一种叫作多级页表（Multi-Level Page Table）的解决方案。

对于单页表的实现方式，在 32 位和页大小 4KB 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于页表需占用 4MB 大小的空间。

将 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。如下图所示：

![二级页表](https://camo.githubusercontent.com/896e00c00fe043020e5fc32f8a00a8b683074075ad94f4313c2f9b4af5f9d18e/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f31332d2545342542412538432545372542412541372545392541312542352545382541312541382e6a7067)

> **为什么二级页表会节约存储空间**

计算机组成原理里面无处不在的局部性原理

- 对于单页表：即使进程没有使用物理内存，页表就需要有 100 多万个页表项来映射，整个页表占用4MB的内存空间

- 对于多级页表:使用一级页表覆盖整个物理空间需要1024个页表项，而二级页表在需要时创建，如果此时仅需要20%的页表，此时页表占用内存空间为:4KB（一级页表） + 20% * 4MB（二级页表）= `0.804MB`


> **64位系统的四级目录**

- 全局页目录项 PGD (Page Global Directory)
- 上层页目录项 PUD (Page Upper Directory)
- 中间页目录项 PMD (Page Middle Directory)
- 页表项 PTE (Page Table Entry)

![四级目录](https://camo.githubusercontent.com/16897e0f95b4d2e4b60393e5150d0679475c437e60a4192d184d9cbad6cd2f8c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f31342d2545352541342539412545372542412541372545392541312542352545382541312541382e6a7067)

> **TLB (Translation Lookaside Buffer)**

多级页表可以有效缓解空间上的问题，但是存在地址转换的速度，带来时间上的开销。

由于**程序的局部性**，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。

![访问频率与内存地址](https://camo.githubusercontent.com/ca1d942c33b51d3a1953181775e81ae4bb4a7e3a0cd6d85315126f70de4f8b7f/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f31352d2545352542312538302545392538332541382545362538302541372545352538452539462545372539302538362e6a7067)

基于上述特性，将经常访问的页表项存储到速度更快的硬件中，因此在CPU中引入了存放程序经常访问的页表项cache，即TLB 通常称为页表缓存、转址旁路缓存、快表等。

![TLB](https://camo.githubusercontent.com/57d60a47a28376b97eb0e62fadddb8e9da00b5328980c9cefe92bd187c5a52a4/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f31362d544c422e6a7067)
 
引入TLB后，CPU寻址时，首先会查TLB，如果没找到则继续查找常规的页表。

## 3.4 段页式内存管理

> **段页式内存管理的实现方式**

- 先将程序划分为多个逻辑段，即之前的分段机制
- 再将每个段划分为多个段，即对分段分出来的连续空间再划分为固定大小的页

> **段页式内存管理**

段页式内存管理的虚拟地址构成：
- 段号
- 段内页号
- 页内偏移地址



> **段页式内存变换**

段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号

![段页式地址](https://camo.githubusercontent.com/299379fd562a050c8c16e380db151ef3d18f2202594288f0deea6cf223f71183/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352538362538352545352541442539382545372541452541312545372539302538362f31382d2545362541452542352545392541312542352545352542432538462545352541462542422545352539442538302e6a7067)

段页式地址变换得到物理地址必须经过三次内存访问:
- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号
- 第三次将`物理页号 + 页内偏移地址 = 物理地址`

## 3.5 Linux内存管理

> **Intel 处理器的发展历史**

> **Linux系统的内存管理**

> **Linux虚拟地址空间如何分布**
