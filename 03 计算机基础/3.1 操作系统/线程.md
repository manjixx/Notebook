# 2.2 线程

在传统操作系统中，每个进程有一个地址空间和一个控制线程。事实上，这几乎就是进程的定义。

不过，经常存在在同一个地址空间中准井行运行多个控制线程的情形，这些线程就像（差不多）分离的进程（共享地址空间除外）。

## 2.2.1 线程的使用

> **为什么使用线程**

需要使用多线程的原因主要有：
- 将应用程序分解成可以准并行运行的多顺序线程，程序设计校型会变得更简单。
- 由于线程比进程更轻量级，所以它们比进程更容易（即更快）创建，也更容易撤销。**创建一个线程较创建一个进程要快10 ~ 100倍**
- 若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的的计算和I/0处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。

> **为什么使用线程举例**

假设需要编写一个视频播放器软件，那么该软件功能的核心模块有三个：

- 从视频文件当中读取数据；
- 对读取的数据进行解压缩；
- 把解压缩后的视频数据播放出来；

**单进程的实现方式**

![单进程实现方式](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/14-单线程mp4代码实例.jpg)

对于单进程的实现方式，存在以下问题：

- 播放出来的画面和声音会不连贯，因为当 CPU 能力不够强的时候，`Read`  的时候可能进程就等在这了，这样就会导致等半天才进行数据解压和播放；
- 各个函数之间不是并发执行，影响资源的使用效率；

**多进程实现方式**

![多进程实现方式](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/15-多进程mp4-代码实例.jpg)

多进程的实现方式，依然会存在问题：

- 进程之间如何通信，共享数据？
- 维护进程的系统开销较大，如创建进程时，分配资源、建立 PCB；终止进程时，回收资源、撤销 PCB；进程切换时，保存当前进程的状态信息；

那到底如何解决呢？需要有一种新的实体，满足以下特性：

- 实体之间可以并发运行；
- 实体之间共享相同的地址空间；

这个新的实体，就是**线程( *Thread* )**，线程之间可以并发运行且共享相同的地址空间。

## 2.2.2 经典的线程模型

进程模型基于两种独立的概念：**资源分组处理与执行**。有时，将这两种概念分开会更好，这就引入了"线程"这一概念。下面先介绍经典的线程模型，之后我们会来研究“模糊进程与线程分界线”的**Linux 线程模型**。

### 经典的线程模型

> **线程是进程当中的一条执行流程**
- 同一个进程内**多个线程之间可以共享代码段、数据段、打开的文件等资源**
- 每个线程各自都有一套独立的寄存器和栈，这样可以确保**线程的控制流是相对独立的**。

![多线程](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/16-多线程内存结构.jpg)

> **线程的优缺点？**

**线程的优点**

- 一个进程中可以同时存在多个线程；
- 各个线程之间可以并发执行；
- 各个线程之间可以共享地址空间和文件等资源；

**线程的缺点**

- 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃）。

### 线程与进程的比较

> **线程与进程的区别：**

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；

线程与进程最大的区别在于：**线程是调度的基本单位，而进程则是资源拥有的基本单位**。

> **线程相比进程能减少开销，体现在：**

- 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
- 线程的终止时间比进程快，因为线程释放的资源相比进程少很多；
- 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
- 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；

所以，不管是时间效率，还是空间效率线程比进程都要高。

### 线程的上下文切换

> **线程的上下文**

所谓操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。

对于线程和进程，我们可以这么理解：

- 当进程只有一个线程时，可以认为进程就等于线程；
- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；

另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

> **线程的上下文切换**

这还得看线程是不是属于同一个进程：

- **当两个线程不是属于同一个进程**，则切换的过程就跟进程上下文切换一样；
- **当两个线程是属于同一个进程**，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；

所以，线程的上下文切换相比进程，开销要小很多。

## 2.2.3 POSIX线程
为实现可移植的线程程序， IEEE在 IEEE标准 1003.lc 中定义了线程的标准。它定义的线程包叫作pthread。大部分UNIX系统都支持该标准.

## 2.2.4 线程的实现

主要有三种线程的实现方式：

- **用户线程（*User Thread*）**：**在用户空间实现的线程**，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；
- **内核线程（*Kernel Thread*）**：**在内核中实现的线程**，是由内核管理的线程；
- **轻量级进程（*LightWeight Process*）**：在内核中来支持用户线程；

还需要考虑一个问题，**用户线程和内核线程的对应关系。**

**首先**，第一种关系是**多对一**的关系，也就是多个用户线程对应同一个内核线程：

![多对一](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/17-内核线程与用户线程-一对多关系.jpg)


第二种是**一对一**的关系，也就是一个用户线程对应一个内核线程：

![一对一](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/18-内核线程与用户线程-一对一关系.jpg)

第三种是**多对多**的关系，也就是多个用户线程对应到多个内核线程：

![多对多](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/19-内核线程与用户线程-多对多关系.jpg)


### 用户线程

> **用户线程**

用户线程是基于用户态的线程管理库来实现的，那么**线程控制块（*Thread Control Block, TCB*）** 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。

所以，**用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。**

用户级线程的模型，也就类似前面提到的**多对一**的关系，即多个用户线程对应同一个内核线程，如下图所示：

![用户级线程模型](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/20-线程PCB-一对多关系.jpg)


> **用户线程的优点：**

- 每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；
- 用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，**速度快**；

> **用户线程的缺点**

- 由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。
- 当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，**因为用户态的线程没法打断当前运行中的线程**，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。
- 由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；


### 内核线程

> **内核线程**

**内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。**

内核线程的模型，也就类似前面提到的**一对一**的关系，即一个用户线程对应一个内核线程，如下图所示：

![内核线程模型](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/21-线程PCB-一对一关系.jpg)

> **内核线程的优点**

- 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；
- 分配给线程，多线程的进程获得更多的 CPU 运行时间；

> **内核线程的缺点**

- 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；
- 线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；

以上，就是内核线程的优缺点了。

### 轻量级进程(混合实现？)
> 轻量级进程

**轻量级进程（*Light-weight process，LWP*）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持。**

另外，LWP 只能由内核管理并像普通进程一样被调度，Linux 内核是支持 LWP 的典型例子。

在大多数系统中，**LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息**。一般来说，一个进程代表程序的一个实例，而 LWP 代表程序的执行线程，因为一个执行线程不像进程那样需要那么多状态信息，所以 LWP 也不带有这样的信息。

> **轻量级进程与用户线程**

在 LWP 之上也是可以使用用户线程的，那么 LWP 与用户线程的对应关系就有三种：

- `1 : 1`，即一个 LWP 对应 一个用户线程；
- `N : 1`，即一个 LWP 对应多个用户线程；
- `M : N`，即多个 LMP 对应多个用户线程；

接下来针对上面这三种对应关系说明它们优缺点。先看下图的 LWP 模型：

![LWP 模型](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/22-LWP.jpg)

**1 : 1 模式**

一个线程对应到一个 LWP 再对应到一个内核线程，如上图的进程 4，属于此模型。

- 优点：实现并行，当一个 LWP 阻塞，不会影响其他 LWP；
- 缺点：每一个用户线程，就产生一个内核线程，创建线程的开销较大。

**N : 1 模式**

多个用户线程对应一个 LWP 再对应一个内核线程，如上图的进程 2，线程管理是在用户空间完成的，此模式中用户的线程对操作系统不可见。

- 优点：用户线程要开几个都没问题，且上下文切换发生用户空间，切换的效率较高；
- 缺点：一个用户线程如果阻塞了，则整个进程都将会阻塞，另外在多核 CPU  中，是没办法充分利用 CPU 的。

**M : N 模式**

根据前面的两个模型混搭一起，就形成 `M:N` 模型，该模型提供了两级控制，首先多个用户线程对应到多个 LWP，LWP 再一一对应到内核线程，如上图的进程 3。

- 优点：综合了前两种优点，大部分的线程上下文发生在用户空间，且多个线程又可以充分利用多核 CPU 的资源。

**组合模式**

如上图的进程 5，此进程结合 `1:1` 模型和 `M:N` 模型。开发人员可以针对不同的应用特点调节内核线程的数目来达到物理并行性和逻辑并行性的最佳方案。


## 2.2.5 调度程序激活机制

尽管内核级线程在一些关键点上优于用户级线程，但无可争议的是内核级线程的速度慢。


调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。



## 2.2.6 弹出式线程

在传统方法处理服务请求时，是将进程或线程阻塞在一个receive 系统调用上，等待消息到来。当消息到达时，该系统调用接收消息，井打开消息检查其内容，然后进行处理。

另一种完全不同的处理方式为，一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程。

![弹出式线程](https://img-blog.csdnimg.cn/163d914b8f9148e7a81eddc36a6d9501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTc0NDg3,size_16,color_FFFFFF,t_70)
弹出式线程的优点：
- 由于线程为全新创建的线程，没有必须存储的寄存器、堆和栈。因此可以快速创建该类线程。

弹出式线程的缺点：
- 在使用弹出式线程之前，需要提前进行计划。例如，哪个进程中的线程先运行？如果系统支持在内核上 下文中运行线程，线程就有可能在那里运行（这是图中没有画出内核的原因）。在内核空间中运行弹出 式线程通常比在用户空间中容易且快捷，而且内核空间中的弹出式线程可以很容易访问所有的表格和I/O设 备，这些也许在中断处理时有用。而另一方面，出错的内核线程会比出错的用户线程造成更大的损害。例如，如果某个线程运行时间太长，又没有办法抢占它，就可能造成进来的信息丢失。
  
## 2.2.7 使单线程代码多线程化

> **单线程代码多线程化遇到的问题**

**问题1：线程使用全局变量可能会导致错误**
  ![线程使用全局变朵所引起的错误]()

- 解决方案1：全面禁止全局变量，不一定合适，因为它同许多已有的软件冲突
- 解决方案2：为每个线程赋予其私有的全局变量，如下图所示：
    ![线程可拥有私有的全局变量](https://img-blog.csdn.net/20170617114013767?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanl4bXVzdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- 解决方案3：引入新的库过程，以便创建、设置和读取这些线程范围的全局变址。

**问题2：许多库过程并不是可重入的**

- **不可重入的意思**就是对于任何给定的过程，当前的调用尚未结束之前，进行第二次调用，例如两个线程通过该库过程都要往内核的一个缓冲区写入，此时缓冲区里第一个线程写入的值，被第二个线程写入的值覆盖，出现信息丢失

- **解决方案：**为每个过程提供一个包装器，为该包装器设置一个二进制位从而标识某个库处于处于使用中，在先前的调用还没有完成之前，任何试图使用该库的其他线程都会被阻塞。该方案虽然可行，但极大的降低系统潜在的并行性。

**问题3：信号相关问题**

有些信号逻辑上是线程专用的，但一些却不是。当线程在用户空间实现时，内核不知道有线程的存在，因此很难将信号发送给正确的线程。有些不是线程专用的信号，如键盘中断，谁应该捕捉他们？若一个线程修改了信号处理程序，而没有通知其他程序，又会出现什么情况？

**问题4：堆栈的管理**
若原来是单线程的系统，当一个进程的堆栈溢出时，内核只是自动为该进程提供更多的堆栈。当一个进程有多个线程时，就必须有多个堆栈，如果内核不了解所有的堆栈，就不能使他们自动增长，知道造成堆栈出错。事实上，内核有可能还没有意识到内存错是和某个线程栈的增长有关系的。
