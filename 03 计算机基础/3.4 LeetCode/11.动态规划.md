- [一、动态规划基础](#一动态规划基础)
  - [1.1 动态规划](#11-动态规划)
- [二、基础题目](#二基础题目)
  - [2.1 斐波那契数列](#21-斐波那契数列)
    - [思路一:动态规划](#思路一动态规划)
    - [思路二：递归](#思路二递归)
  - [2.2 爬楼梯](#22-爬楼梯)
    - [2.2.1 动态规划-斐波那契数](#221-动态规划-斐波那契数)
    - [2.2.2 递归](#222-递归)
    - [2.2.3 动态规划-完全背包](#223-动态规划-完全背包)
  - [2.3 最小花费爬楼梯](#23-最小花费爬楼梯)
  - [2.4 不同路径](#24-不同路径)
    - [思路一:动态规划](#思路一动态规划-1)
    - [思路二:DFS](#思路二dfs)
    - [思路三:数论](#思路三数论)
  - [2.5 不同路径II](#25-不同路径ii)
    - [思路一：动态规划](#思路一动态规划-2)
  - [2.6 整数拆分](#26-整数拆分)
  - [2.7 不同的二叉搜索树](#27-不同的二叉搜索树)
    - [思路一:动态规划](#思路一动态规划-3)
- [三、 背包问题](#三-背包问题)
  - [3.1 0-1 背包基础](#31-0-1-背包基础)
    - [3.1.1 背包问题](#311-背包问题)
    - [3.1.2 二维数组0-1背包](#312-二维数组0-1背包)
    - [3.1.3 一维0-1背包](#313-一维0-1背包)
  - [3.2 分割等和子集](#32-分割等和子集)
    - [3.2.1 思路一: 0-1背包](#321-思路一-0-1背包)
  - [3.3 最后一块石头重量II](#33-最后一块石头重量ii)
    - [思路一:动态规划](#思路一动态规划-4)
  - [3.4 494. 目标和](#34-494-目标和)
    - [3.4.1 思路一](#341-思路一)
  - [3.5 一和零](#35-一和零)
    - [3.5.1 动态规划](#351-动态规划)
  - [3.6 完全背包理论](#36-完全背包理论)
  - [3.7 零钱兑换II](#37-零钱兑换ii)
    - [3.7.1 动态规划](#371-动态规划)
  - [3.8 组合总和 Ⅳ](#38-组合总和-ⅳ)
    - [3.8.1 动态规划（完全背包）](#381-动态规划完全背包)
  - [3.9 零钱兑换](#39-零钱兑换)
  - [3.10 完全平方数](#310-完全平方数)
    - [3.10.1 动态规划](#3101-动态规划)
  - [3.11 单词拆分](#311-单词拆分)
  - [3.12 多重背包](#312-多重背包)
  - [3.13 背包问题总结](#313-背包问题总结)
- [四、打家劫舍](#四打家劫舍)
  - [4.1 打家劫舍](#41-打家劫舍)
  - [4.2打家劫舍II](#42打家劫舍ii)
  - [4.3打家劫舍III](#43打家劫舍iii)
- [五、股票问题](#五股票问题)
  - [5.1 买卖股票的最佳时机](#51-买卖股票的最佳时机)
  - [5.2 买卖股票的最佳时机II](#52-买卖股票的最佳时机ii)
  - [5.4 买卖股票的最佳时机IV](#54-买卖股票的最佳时机iv)
- [六、子序列问题](#六子序列问题)
  - [6.1 最长递增子序列](#61-最长递增子序列)
    - [6.1.1 动态规划](#611-动态规划)
    - [6.1.2 动态规划 + 二分查找](#612-动态规划--二分查找)
  - [6.2 最长连续递增序列](#62-最长连续递增序列)
    - [6.2.1 动态规划](#621-动态规划)
    - [6.2.2 贪心算法](#622-贪心算法)
  - [6.3 最长重复子数组](#63-最长重复子数组)
  - [6.4 最长公共子序列](#64-最长公共子序列)
  
***

# 一、动态规划基础

![动态规划刷题大纲](https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg)

## 1.1 动态规划

> **动态规划**

动态规划(Dynamic Programming)，简称DP，如果**某一问题有很多重叠子问题**，使用动态规划是最有效的。

> **动态规划与贪心的区别**

态规划中每一个状态一定是由上一个状态推导出来

贪心没有状态推导，而是从局部直接选最优。

> **动态规划的解题步骤**

- 确定dp数组（dp table）以及下标的含义
- 确定递推公式
- dp数组如何初始化
- 确定遍历顺序
- 举例推导dp数组

> **动态规划DEBUG**

- 这道题目是否举例推导了状态转移公式
- 是否打印dp数组的日志
- 打印出来了dp数组与预想的是否一致
  
***

# 二、基础题目

## 2.1 [斐波那契数列](https://leetcode.cn/problems/fibonacci-number/)

### 思路一:动态规划

> **思路**

**五步走**

- 确定dp数组及其下标含义：dp[i]表示第i个斐波那契数
- 确定递推公式
  
```java
dp[i] = dp[i - 1] + dp[i - 2]
```

- dp数组的初始化
  
```java
dp[0] = 0;
dp[1] = 1;
```

- 确定遍历顺序：从前到后遍历

- 举例推导dp数组

> **代码**

```java
class Solution {
    public int fib(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2;i <= n;i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}

/**空间优化 */
 public int fib(int n) {
    if(n == 0 || n == 1){
        return n;
    }
    int dp0 = 0;
    int dp1 = 1;
    int ans = 0;
    for(int i = 2;i <= n;i++){
        ans = dp0 + dp1;
        dp0 = dp1;
        dp1 = ans;
    }
    return ans;
}
```

> **复杂度分析**

- 时间复杂度:O(n)
- 空间复杂度:未优化前O(n),优化后O(1)

### 思路二：递归

**代码实现**

```java
 public int fib(int n) {
        if(n == 0 || n == 1){
            return n;
        }
        return fib(n - 1) + fib(n - 2);
    }

```

**复杂度分析**

- 时间复杂度:O(2^n)
- 空间复杂度：O(n)，算上了编程语言中实现递归的系统栈所占空间

## 2.2 [爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

### 2.2.1 动态规划-斐波那契数

> **思路**

- 确定dp数组及其下标含义：dp[i] 表示有多少种方法可以爬到当前位置i
- 确定递推公式：

```java
dp[i] = dp[i - 1] + dp[i - 2];
```

- 初始化dp数组
  
```java
dp[0] = 0;
dp[1] = 1;
dp[2] = 2;
```

- 确定遍历顺序:从前到后遍历

- 举例推导dp数组

> **代码**

```java
public int climbStairs(int n) {
        if(n == 1 || n == 2){
            return n;
        }
        int dp1 = 1;
        int dp2 = 2;
        int ans = 0;
        for(int i = 3;i <= n;i++){
            ans = dp1 + dp2;
            dp1 = dp2;
            dp2 = ans;
        }
        return ans;
    }
```

**复杂度分析**

- 时间复杂度:O(n)
- 空间复杂度:O(1)

### 2.2.2 递归

此处略去

### 2.2.3 动态规划-完全背包

> **分析**

本题目可以将目标台阶数视为背包容量，物品数量为{1,2}，台阶可以重复爬，物品可以重复用，因此本题变为一个完全背包问题。

> **动态规划五步曲**

- 确定dp数组及其下标含义
dp[j]:表示爬到j级台阶有dp[j]种方法

- 确定递推公式
装满背包的递推公式为 dp[j] += dp[j - nums[i]];

- 初始化dp数组
dp[0] = 1

- 确定遍历方向与顺序
  - 遍历顺序:先遍历书包承重再遍历物品
  - 遍历方向:从小到大遍历

- 举例推导dp数组

> **代码**

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for(int i = 0;i <= n;i++){
            for(int j = 0;j <= 2;j++){
                if(i - j >= 0){
                    dp[i] = dp[i] + dp[i - j];
                }
            }
        }
        return dp[n];
    }
}
```

> **复杂度分析**

- 时间复杂度:${O(mn)}$
- 空间复杂度:${O(m)}$

***

## 2.3 [最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

> **思路**

本题思路可参考[链接中思路二](https://leetcode.cn/problems/min-cost-climbing-stairs/solution/yi-bu-yi-bu-tui-dao-dong-tai-gui-hua-de-duo-chong-/)

- 确定dp数组及其下标含义：dp[i] 为到达当前位置所需的最小花费

- 确定递推公式
  
```java
dp[i] = min(dp[i - 1],dp[i - 2]) + cost[i];
```

- 初始化dp数组
  
```java
dp[0] = cost[0];
dp[1] = cost[1];
```

- 确定遍历顺序:从前到后遍历

- 举例推导dp数组

- 注意此题的返回值

> **代码**

```java
public int minCostClimbingStairs(int[] cost) {
    int len = cost.length;
    int dp0 = cost[0];
    int dp1 = cost[1];
    int ans = 0;

    for(int i = 2; i < len;i++){
        ans = Math.min(dp0,dp1) + cost[i];
        dp0 = dp1;
        dp1 = ans;
    }
    return Math.min(dp0,dp1);
}
```

> **复杂度分析**

- 时间复杂度:O(n);
- 空间复杂度:O(1);

## 2.4 [不同路径](https://leetcode.cn/problems/unique-paths/)

### 思路一:动态规划

> **思路**

- 确定dp数组及其下标含义：dp[i][j] 表示到达当前位置(i,j)的路径数

- 确定递推公式/转移方程

```java
dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
```

- 初始化dp数组

```java
for(int j = 0; j < n;j++){
    dp[0][j] = 1;
}

for(int i = 0;i < m;i++){
    dp[i][0] = 1;
}
```

- 确定遍历顺序：从前到后，从左到右遍历

```java
for(int i = 1;i < m;i++){
    for(int j = 1;j < n;j++){
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
}
```

- 举例推导dp数组
  
> **代码**

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];

        for(int j = 0; j < n;j++){
            dp[0][j] = 1;
        }

        for(int i = 0;i < m;i++){
            dp[i][0] = 1;
        }

        for(int i = 1;i < m;i++){
            for(int j = 1;j < n;j++){
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];

    }
}
```

> **复杂度分析**

- 时间复杂度:O(m * n)
- 空间复杂度:O(m * n)

### 思路二:DFS

### 思路三:数论

## 2.5 [不同路径II](https://leetcode.cn/problems/unique-paths-ii/)

### 思路一：动态规划

> **思路**

dp数组的定义、初始化与遍历方向与 不同路径 相同，需要特别注意的是对于**障碍物的处理**

> **代码**

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;

        int[][] dp = new int[m][n];

        for(int j = 0; j < n;j++){
            if(obstacleGrid[0][j] == 1){
                break;
            }
            dp[0][j] = 1;
        }

        for(int i = 0;i < m;i++){
            if(obstacleGrid[i][0] == 1){
                break;
            }
            dp[i][0] = 1;
        }

        for(int i = 1;i < m;i++){
            for(int j = 1;j < n;j++){
                if(obstacleGrid[i][j] == 1){
                    dp[i][j] = 0;
                    continue;
                }
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];

    }
}
```

> **复杂度分析**

- 时间复杂度:O(m * n)
- 空间复杂度:O(m * n)

## 2.6 [整数拆分](https://leetcode.cn/problems/integer-break/)

> **思路**

- 确定dp数组及其下标含义：dp[i]定义为拆分数字i时可以得到的最大值
- 确定递推公式：
  
```java
dp[i] = max((i - j) * j,(i - j) * dp[j],dp[i])
```

- 初始化dp数组

```java
dp[2] = 1
```

- 确定遍历顺序:由递推公式可得到，遍历方向为从前到后

> **代码**

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];

        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 1;

        for(int i = 3;i <= n;i++){
            for(int j = 1;j < i;j++){
                int temp = Math.max(dp[j] * (i - j),(i - j) * j);
                dp[i] = Math.max(dp[i],temp);
            }
        }
        return dp[n];
    }
}
```

> **复杂度分析**

- 空间复杂度:O(n);
- 时间复杂度:${O(n^2)}$

## 2.7 [不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

### 思路一:动态规划

> **思路**

- 确定dp数组及其下标含义:定义dp[i]为根节点为i时，二叉搜索树的数量

- 确定递推公式:
  
    ![递推公式思路图](https://assets.leetcode-cn.com/solution-static/96/96_fig1.png)

    由上图可以看出，dp[i] = dp[i] + dp[i - j] *dp[j - 1], 即以 j - 1 为头节点的左子树数量* 以 i- j为根接节点的二叉搜索树数量

- dp数组初始化

```java
dp[0] = 1;
```

- 确定遍历方向:从前往后遍历

- 举例推导dp数组
  
> **代码**

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for(int i = 1;i <= n; i++){
            for(int j = 1; j <= i;j++){
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
```

> **复杂度分析**

- 时间复杂度:${o(n^2)}$
- 空间复杂度:${o(n)}$

***

# 三、 背包问题


求装满背包有几种方法，递推公式一般都是dp[i] += dp[i - nums[j]]

## 3.1 0-1 背包基础

### 3.1.1 背包问题

> **常见背包问题**

![常见背包问题](https://img-blog.csdnimg.cn/20210117171307407.png)

对于面试的话，其实掌握**01背包，和完全背包**，就够用了，最多可以再来一个多重背包。

> **0-1背包经典例子**

有 **n件物品** ，每件 **物品重量为w[i]**,每件 **物品价值为value[i]**，有一个**背包承重为w**。每件物品**只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

![0-1背包](https://img-blog.csdnimg.cn/20210117175428387.jpg)

每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。

所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！

### 3.1.2 二维数组0-1背包

> **例题**

背包最大重量为4，物品如下表所示，问背包能背的物品最大价值是多少？
|       | 重量  | 价值 |
| :--:  | :--: | :--: |
|  物品0 |  1   |  15  |
|  物品1 |  3   |  20  |
|  物品2 |  4   |  30  |

> **动态规划五步曲**

- **确定dp数组及其下标含义**

dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，最大的价值总和

![dp数组](https://img-blog.csdnimg.cn/20210110103003361.png)

- **确定递推公式**
  
  - **明确dp数组的含义：** dp[i][j]的含义为：从下标为[0-i]的物品里任意取，放进容量为j的背包，最大价值总和，因此可以分为放物品和不放物品两个方向来确定：
  
  - **不放物品进背包**:dp[i][j] = dp[i - 1][j]
  
  - **放物品进背包**:dp[i][j] = dp[i - 1][j - weight[i]] + value[i]
  
  - 综上可得:dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i])

- 初始化dp数组(**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。**)
  
  - **从定义出发:** 当j=0时，无论取哪些物品，背包价值价值一定为0；
  - **从状态转移方程出发:** 因为状态转移方程为`dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i])`可知i= 0，一定需要初始化。即将物品0放入背包，此时可得dp[0][j] = 15,因此初始化之后的dp数组如下图所示:
  ![初始化后的dp数组](https://img-blog.csdnimg.cn/20210110103109140.png)
  
  - **初始化代码**
  
  ```java
  for(int j = 0;j < bagweight;j++){
    dp[0][j] = 15;
  }
  ```

- 确定遍历方向:**由dp数组的定义可知有两个遍历维度**
  
  - **注意此处表达的内层循环的遍历顺序可能有问题**
  
  - 先遍历物品再遍历背包承重
  
  ![先遍历物品再遍历背包承重](https://img-blog.csdnimg.cn/202101101032124.png)
  
  ![先遍历书包承重再遍历物品](https://img-blog.csdnimg.cn/20210110103244701.png)

- 举例推导dp数组

> **完整测试代码**

```java
public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagsize = 4;
        testweightbagproblem(weight, value, bagsize);
    }

    public static void testweightbagproblem(int[] weight, int[] value, int bagsize){
        int wlen = weight.length, value0 = 0;
        //定义dp数组：dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值
        int[][] dp = new int[wlen + 1][bagsize + 1];
        //初始化：背包容量为0时，能获得的价值都为0
        for (int i = 0; i <= wlen; i++){
            dp[i][0] = value0;
        }
        //遍历顺序：先遍历物品，再遍历背包容量
        for (int i = 1; i <= wlen; i++){
            for (int j = 1; j <= bagsize; j++){
                if (j < weight[i - 1]){
                    dp[i][j] = dp[i - 1][j];
                }else{
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]);
                }
            }
        }
        //打印dp数组
        for (int i = 0; i <= wlen; i++){
            for (int j = 0; j <= bagsize; j++){
                System.out.print(dp[i][j] + " ");
            }
            System.out.print("\n");
        }
    }
```

### 3.1.3 一维0-1背包

> **分析**

使用二维数组时，递推公式为：```dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - weight[i] + value[i]]```

其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);

与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

> **动态规划五步曲**

- 确定dp数组定义及下标含义：在一维dp数组中，dp[j]表示从下标[0-j]的物品中任意取，放进容量为j的背包，价值总和最大

- 确定递推公式：

```java
/**
dp[j]表示未放入物品i
dp[j - weight[i]]表示放入物品i后的价值
 */
dp[j] = max(dp[j],dp[j - weight[i]] + value[j])
```

- 一维数组的初始化

关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

- 一维数组的遍历顺序

这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。

如果正序遍历

dp[1] = dp[1 - weight[0]] + value[0] = 15

dp[2] = dp[2 - weight[0]] + value[0] = 30

此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

为什么倒序遍历，就可以保证物品只放入一次呢？

倒序就是先算dp[2]

dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）

dp[1] = dp[1 - weight[0]] + value[0] = 15

所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？

不可以！

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。

倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。

- 举例推导dp数组

![](https://img-blog.csdnimg.cn/20210110103614769.png)

> **代码**

```java
    public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagWight = 4;
        testWeightBagProblem(weight, value, bagWight);
    }

    public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight){
        int wLen = weight.length;
        //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值
        int[] dp = new int[bagWeight + 1];
        //遍历顺序：先遍历物品，再遍历背包容量
        for (int i = 0; i < wLen; i++){
            for (int j = bagWeight; j >= weight[i]; j--){
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
            }
        }
        //打印dp数组
        for (int j = 0; j <= bagWeight; j++){
            System.out.print(dp[j] + " ");
        }
    }
```

***

## 3.2 [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

### 3.2.1 思路一: 0-1背包

> **思路**

想要用0-1背包解决一个问题，首先需要明确如下问题：

- 背包容量

- 背包中放入物品的重量以及物品的价值

- 背包中的元素是否可以重复入包，如果可以重复入包则为完全背包，否则为0-1背包

> **针对本题的分析**

- 背包的体积为sum / 2
- 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
- 背包如果正好装满，说明找到了总和为 sum / 2 的子集。
- 背包中每一个元素是不可重复放入。

> **动态规划五步曲**

- 1.确定dp数组及其下标含义

    01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值可以最大为dp[j]。

    套到本题，dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]。

- 2.确定递推公式

    01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。

    所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);

- 3. dp数组如何初始化

本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。

- 4. 确定遍历顺序

    如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放入内层，且**内层for循环倒序遍历**

- 5. 举例推导dp数组

> **代码**

```java
class Solution {
    public boolean canPartition(int[] nums) {

        int sum = 0;

        for(int i = 0;i < nums.length;i++){
            sum = sum + nums[i];
        }

        if(sum % 2 == 1){
            return false;
        }

        int target = sum / 2;

        int[] dp = new int[target + 1];

        for(int i = 0;i < nums.length;i++){
            for(int j = target;j >= nums[i];j--){
                dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i]);
            }
        }
        return dp[target] == target;
    }
}
```

## 3.3 [最后一块石头重量II](https://leetcode.cn/problems/last-stone-weight-ii/)

### 思路一:动态规划

> **分析**

本题目可以将石头装入承重为总重量一半的背包中，**那么剩余的石头减去背包中的石头**，那么所求得结果即为最小可能重量。

同上一题一样需要分析几个问题

- 背包容量
  
- 物品重量与物品价值

- 背包中元素是否可以重复入包

本题题目中

- 背包的容量最大值为所有物品的重量

- 物品的重量为stones[i]，价值也为stones[i]

- 背包中元素不可以重复入包，因此为0-1背包解决一个问题

> **动态规划五步曲**

- 1. 确定dp数组及其下标含义

    dp[j]表示背包容量为j时，可以装入的石头的重量

- 2. 确定递推公式

    0-1背包的递推公式为：dp[j] = max(dp[j],dp[j - stones[i]] + stones[i])

- 3. 初始化dp数组

  - dp数组的大小：dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。因为提示中给出1 <= stones.length <= 30，1 <= stones[i] <= 1000，所以最大重量就是30 * 1000 。而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。当然也可以把石头遍历一遍，计算出石头总重量 然后除2，得到dp数组的大小。我这里就直接用15000了。

  - dp数组初始化:全部初始化为0

- 4. 确定遍历方向
    先遍历石头然后遍历背包容量，其中背包容量从大到小遍历。

- 5. 举例推导dp数组

    最后dp[target]里是容量为target的背包所能背的最大重量。

    那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。

    在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的。

    那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。

> **代码**

```java
class Solution {
    /**
        该题目为0-1背包问题，定义
            背包承重为sum / 2
            物品重量为stones[i],物品价值为stones[i]
            那么最终结果即位：
            sum - dp[target] - dp[target]
     */
    public int lastStoneWeightII(int[] stones) {

        int sum = 0;

        for(int i = 0;i < stones.length;i++){
            sum = sum + stones[i];
        }

        int target = sum / 2;

        int[] dp = new int[target + 1];

        for(int i = 0;i < stones.length;i++){
            for(int j = target;j >= stones[i];j--){
                dp[j] = Math.max(dp[j],dp[j - stones[i]]+ stones[i]);
            }
        }
        return sum - dp[target] - dp[target];
    }
}
```

> **复杂度分析**

- 时间复杂度:$O(n * sum)$
  
- 空间复杂度:$O{sum}$

## 3.4 [494. 目标和](https://leetcode.cn/problems/target-sum/)

### 3.4.1 思路一

> **分析**

既然目标为target，那么就一定有 left组合 - right组合 = target。

又因为 left + right = sum，sum是固定的；

那么${left - (sum - left) = target}$,${left = (target + sum) / 2}$

target是固定的，sum是固定的，left就可以求出来。

此时问题就是在集合nums中找出和为left的组合。

> **如何转化为动态规划问题**

假设数组中加法的总和为x，那么减法的总和为sum - x

我们所要求得的是${x - (sum - x) = target}$

整理得:${x = (sum + target) / 2}$

**那么问题转化为装满容量为X的背包有多少种方法**

> **动态规划五步曲**

- 确定dp数组及其下标含义
    dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法

- 确定递推公式
    不考虑nums[i]的情况下，填满容量为j的背包，有dp[j]种方法。

    那么考虑nums[i]的话（只要搞到nums[i]），凑成dp[j]就有dp[j - nums[i]] 种方法。

    所以求组合类问题的公式，都是类似这种：

    ```java
        dp[j] = dp[j] + dp[j - nums[j]]; 
    ```

- dp数组的初始化
    dp[0] = 1:装满容量为1的背包，只有一种方法；
    其他dp[j]均初始化为0；

- 确定遍历方向
  - 先遍历nums，再遍历target，且内层循环从大到小；

- 举例推导dp数组

> **代码**

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;

        for(int i = 0;i < nums.length;i++){
            sum = sum + nums[i];
        }

        int x = Math.abs((sum + target) / 2);

        if(x % 2 == 1){
            return 0;
        }

        int[] dp = new int[x + 1];

        for(int i = 0;i < nums.length;i++){
            for(int j = x;i >= nums[i];j--){
                dp[j] = dp[j] + dp[j - nums[i]];
            }
        }
    }

    return dp[x];
}
```

> **复杂度分析**

- 时间复杂度:$O(n * x)$
- 空间复杂度:${O(x)}$

## 3.5 [一和零](https://leetcode.cn/problems/ones-and-zeroes/)

### 3.5.1 动态规划

> **思路：动态规划5步曲**

- 1. **确定dp数组及其下标含义**

dp[i][j]:表示有i个0，j个1，strs 的最大子集的长度

- 2. **确定递推公式**

dp[i][j]可以由前一个str里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。

那么dp[i][j] = dp[i - zeroNum][j - oneNum] + 1

然后我们在遍历的过程中，取dp[i][j]的最大值。

所以递推公式：dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);

相比一维dp递推公式 dp[j] = max(dp[j],dp[j - nums[i]]),可以看出本题的是一个典型的01背包！ 只不过物品的重量有了两个维度而已。

- 3. **初始化dp数组**

dp[0][0] = 0;

- 4. **确定遍历顺序**

先遍历物品，此处即为字符串中0和1的数目，其次遍历背包容量，而且为从右到左遍历

- 5. **举例推导dp数组**

> **代码**

```java
class Solution {
    /**
        本题目为一个二维的0-1背包问题，
        定义dp[i][j],为当有i个0，j个1时，strs 的最大子集的长度
        最值问题，因此
        dp[i][j] = max(dp[i][j],dp[i - zeroNum][j - oneNum]),其中zeroNum，oneNum表示为上一个字符中0和1的个数
     */
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];

        for(String str : strs){
            int zeroNum  = 0;
            int oneNum = 0;

            for(int i = 0;i < str.length();i++){
                if(str.charAt(i) - '0' == 0){
                    zeroNum++;
                }else{
                    oneNum++;
                }
            }

            for(int j = m;j >= zeroNum;j--){
                for(int k = n;k >= oneNum;k--){
                    dp[j][k] = Math.max(dp[j][k],dp[j - zeroNum][k - oneNum] + 1);
                }
            }
        }

        return dp[m][n];

    }
}
```

> **复杂度分析**

- 时间复杂度:${o(m *n* l + l)}$,其中l为数组长度
- 空间复杂度:${O(m * n)}$

## 3.6 完全背包理论

> **例题**

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

背包最大重量为4，物品如下表所示，问背包能背的物品最大价值是多少？
|       | 重量  | 价值 |
| :--:  | :--: | :--: |
|  物品0 |  1   |  15  |
|  物品1 |  3   |  20  |
|  物品2 |  4   |  30  |

> **动态规划五步曲**

- 确定dp数组及其下标含义

    **二维数组** dp[i][j] ： 从下标为[0-i]的物品里任意取，放进容量为j的背包，最大的价值总和

    **一维数组 dp[j]** : 表示容量为j的背包，所装物品最大的价值总和

- 确定递推公式
  
```java
dp[j] = max(dp[j],dp[j - value[i]] + value[i])
```

- 初始化dp数组
  
```java
dp[0][0] = 0
```

- 确定遍历方向与顺序
  
  - 遍历方向：01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。**完全背包的物品是可以添加多次的，所以要从小到大去遍历**，即：
  
  ```java
    for(int i = 0;i < m;i++){
        for(int j = 0;j < n;j++){
            dp[j] = max(dp[j],dp[j - weight[i]] + value[i]);
        }
    }
  ```
  
  - 遍历顺序：
    - 0**1背包中二维dp数组**的两个for遍历的先后循序是可以颠倒了，**一维dp数组**的两个for循环先后循序一定是先遍历物品，再遍历背包容量。
    - 在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！

    - 全文我说的都是对于纯完全背包问题，其for循环的先后循环是可以颠倒的！但如果题目稍稍有点变化，就会体现在遍历顺序上。如果问装满背包有几种方式的话？ 那么两个for循环的先后顺序就有很大区别了，而leetcode上的题目都是这种稍有变化的类型。

    - 在求装满背包有几种方案的时候，认清遍历顺序是非常关键的。
      - 如果求组合数就是外层for循环遍历物品，内层for遍历背包。
      - 如果求排列数就是外层for遍历背包，内层for循环遍历物品

> **代码**

```java
//先遍历物品，再遍历背包
private static void testCompletePack(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 0; i < weight.length; i++){ // 遍历物品
        for (int j = weight[i]; j <= bagWeight; j++){ // 遍历背包容量
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}

//先遍历背包，再遍历物品
private static void testCompletePackAnotherWay(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 1; i <= bagWeight; i++){ // 遍历背包容量
        for (int j = 0; j < weight.length; j++){ // 遍历物品
            if (i - weight[j] >= 0){
                dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]);
            }
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}
```

## 3.7 [零钱兑换II](https://leetcode.cn/problems/coin-change-2/)

### 3.7.1 动态规划

> **动态规划五步曲**

- 确定dp数组及其下标含义
    dp[j]:表示凑够金额j的方法数，与顺序无关，因此为组合数

- 确定递推公式：dp[j] = dp[j] + dp[j - coins[i]]
  - 表示如果一个硬币都没有则，有dp[j]种方法可以凑够j
  - 如果有一个硬币coins[i],则有dp[j - coins[i]]种方法可以凑够j

- 初始化dp数组
   dp[0] = 1,表示凑个0元的方法只有一种，不凑

- 确定遍历方向与顺序
  - 遍历方向：从小到大
  - 遍历顺序：该题在求组合数，因此先遍历物品再遍历背包
- 举例推导dp数组

> **代码**

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];

        dp[0] = 1;

        for(int i = 0;i < coins.length;i++){
            for(int j = coins[i];j <= amount;j++){
                dp[j] = dp[j] + dp[j - coins[i]];
            }
        }

        return dp[amount];
    }
}
```

> **复杂度分析**

- 时间复杂度:${O(mn),其中m为硬币数组长度，n为目标金额}$
- 空间复杂度:${O(n)}$

## 3.8 [组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

### 3.8.1 动态规划（完全背包）

> **分析**

原题目可以转化为容量为target的背包，物品的排列数

> **动态规划五步曲**

- 确定dp数组及其下标含义
dp[j]:表示正整数目标j的排列数为dp[j]

- 确定递推公式
求装满背包的递推公式一般为:dp[j] = dp[j] + dp[j - nums[i]]

- 初始化dp数组
dp[0] = 1,为求整个dp数组的基础

- 确定遍历方向与顺序
  - 遍历顺序:求排列数，先背包后物品
  - 遍历方向：从大到小

- 举例推导dp数组

> **代码**

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];

        dp[0] = 1;

        for(int j = 0;j <= target;j++){
            for(int i = 0;i < nums.length();i++){
                if(j - nums[i] >= 0){
                    dp[j] = dp[j] + dp[j - nums[i]];
                }
            }
        }   

        return dp[target]; 
    }
}
```

> **复杂度分析**

- 时间复杂度:${O(mn)}$
- 空间复杂度:${O(n)}$

## 3.9 [零钱兑换](https://leetcode.cn/problems/coin-change/)

## 3.10 [完全平方数](https://leetcode.cn/problems/perfect-squares/)

### 3.10.1 动态规划

> **分析**

该题可以理解为装满背包n，最少需要多少种物品

> **动态规划五步曲**

- 确定d p
dp[j]和为j的完全平方数的最少数量为dp[j]

- 确定递推公式
dp[j] = min(dp[j],dp[j -i * i] + 1)

- 初始化dp数组
dp[0] = 0,
其余变量初始为n

- 确定遍历方向与顺序
  - 遍历顺序:此时先遍历物品先遍历背包均可
  - 遍历方向:从小到大

- 举例推导dp数组

> **代码**

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp,n);
        dp[0] = 0;
        for(int i = 0;i < n;i++){
            for(int j = i * i;j <= n;j++){
                dp[j] = Math.min(dp[j],dp[j - i*i] + 1);
            }
        }
        return dp[n];

    }
}
```

> **复杂度分析**

- 时间复杂度:${O(n\sqrt{n})}$
- 空间负载的:${O(n)}$

## 3.11 [单词拆分](https://leetcode.cn/problems/word-break/)

> **题目分析**
字典就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。

拆分时可以重复使用字典中的单词，说明就是一个完全背包！

> **动态规划五步曲**

- 确定dp数组及其下标含义
dp[i]:表示字符串s下标i之前的字符串能否有单词组成，即容量为i时背包能否被装满

- 确定递推公式

```java
if(dp[j] == true,s.wordDict.contains(substr(j,i))){
    dp[i] = true;
}

```

- 确定遍历方向与顺序
  - 遍历方向：从小到达
  - 遍历顺序:排列数先背包后物品，组合数先物品后背包，本题先后顺序均可

- 举例推导dp数组

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length();

        boolean[] dp = new boolean[n + 1];

        dp[0] = true;

        for(int i = 0;i <= n;i++){      // 遍历背包
            for(int j = 0;j < i;j++){   // 遍历物品
                String sub = s.substring(j,i);
                if(dp[j] && wordDict.contains(sub)){
                    dp[i] = true;
                }
            }
        }

        return dp[n];
    }
}
```

## 3.12 多重背包

> **题目描述**

已知：

- 有n种物品，第i种物品最多有${M_i}$j件可用，每件耗费空间为${C_i}$,价值是${W_i}$

- 容量为v的背包

- 求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

分析：多重背包和01背包是非常像的，每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。

如下两表所示：

｜       ｜  重量     ｜  价值     ｜  数量    ｜
｜  ---- ｜  ----    ｜  ----    ｜  ----   ｜
｜   物品0    ｜  1    ｜  15    ｜  2    ｜
｜   物品1    ｜  3    ｜  20    ｜  3    ｜
｜   物品2    ｜  4    ｜  30    ｜  2    ｜


｜       ｜  重量     ｜  价值     ｜  数量    ｜
｜  ---- ｜  ----    ｜  ----    ｜  ----   ｜
｜   物品0    ｜  1    ｜  15    ｜  1    ｜
｜   物品0    ｜  1    ｜  15    ｜  1    ｜
｜   物品1    ｜  3    ｜  20    ｜  1    ｜
｜   物品1    ｜  3    ｜  20    ｜  1    ｜
｜   物品1    ｜  3    ｜  20    ｜  1    ｜
｜   物品2    ｜  4    ｜  30    ｜  1    ｜
｜   物品2    ｜  4    ｜  30    ｜  1    ｜


通过上述拆分方式即可将上述问题转化为0-1背包问题

> **代码**
```java
/**
    版本一：改变物品数量为01背包格式
 */

public void testMultiPack(){
    List<Integer> weight = new ArrayList<>(Arrays.asList(1, 3, 4));
    List<Integer> value = new ArrayList<>(Arrays.asList(15, 20, 30));
    List<Integer> nums = new ArrayList<>(Arrays.asList(2, 3, 2));
    int bagWeight = 10;

    for(int i = 0;i < nums.size();i++){
        while(nums.get(i) > 1){
            weight.add(weight.get(i));
            value.add(value.get(i));
            nums.set(i,nums.get(i) - 1)
        }
    }
    int[] dp = new int[bagWeight + 1];
    for(int i = 0;i < weight.size();i++){
        for(int j = bagWeight;j >= weight.get(i);j--){
            dp[j] = Math.max(dp[j],dp[j - weight.get(i)] + value.get(i));
        }
    }

    System.out.println(Arrays.toString(dp));
}

/**版本二：改变遍历个数 */
public void testMultiPack(){
    // 版本二：改变遍历个数
    int[] weight = new int[] {1, 3, 4};
    int[] value = new int[] {15, 20, 30};
    int[] nums = new int[] {2, 3, 2};
    int bagWeight = 10;
    
    int[] dp = new int[bagWeight + 1];

    for(int i = 0;i < weight.length;i++){
        for(int j = bagWeight;j >= weight[i];j--){
            //  以上为一个01背包，添加一个遍历数
            for(int k = 1;k <= nums[i] && (j - k * weight[i]) >= 0;k++){
                dp[j] = Math.max(dp[j],dp[j - k * weight[i]] + k * value[i]);
            }
            System.out.println(Arrays.toString(dp));
        }
    }
}
```

## 3.13 背包问题总结

> **背包问题递推公式**

- 能否装满背包(最多能装多少):`dp[j] = max(dp[j],dp[j - nums[i]] + nums[i])`,对应题目为
  - [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
  - [最后一块石头重量II](https://leetcode.cn/problems/last-stone-weight-ii/)

- 装满背包有几种方法:`dp[j] += dp[j - nums[i]]`,对应题目如下：
  - [目标和](https://leetcode.cn/problems/target-sum/)
  - [零钱兑换II](https://leetcode.cn/problems/coin-change-2/)
  - [组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)
  - [爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

- 装满背包的最大价值:`dp[j] = max(dp[j],dp[j - weight[i]] + value[i])`,对应题目
  - [一和零](https://leetcode.cn/problems/ones-and-zeroes/)

- 装满背包所有物品的最小个数:`dp[j] = min(dp[j],dp[j - nums[i]] + 1)`,对应题目：
  - [零钱兑换](https://leetcode.cn/problems/coin-change/)
  - [完全平方数](https://leetcode.cn/problems/perfect-squares/)

> **遍历顺序**

- 0-1背包
  - 二维dp数组中：先遍历物品还是先遍历背包都是可以的，且第二层for循环从小到大遍历
  - 一维dp数组中：只能先遍历物品然后再遍历背包，而且第二层for循环从大到小遍历

- 完全背包
  - 纯完全背包问题的一维数组实现，先遍历物品还是先遍历背包都可以，且第二层for循环是从小到大遍历
  - 求组合数的话，先遍历物品，再遍历背包容
  - 求排列数的话，先遍历背包，再遍历物品

![背包问题总结](https://code-thinking-1253855093.file.myqcloud.com/pics/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%981.jpeg)

***

# 四、打家劫舍

## 4.1 [打家劫舍](https://leetcode.cn/problems/house-robber/)

> **动态规划五步曲**

- 确定dp数组及其下标含义
dp[i]:表示到达房间i时，偷窃到的最高金额

- 确定递推公式
`dp[i] = max(dp[i - 1],dp[i - 2] + nums[i])`

- 初始化dp数组

```java
dp[0] = nums[0];
dp[1] = Math.max(nums[0],nums[1]);
```

- 确定遍历方向:从小到大遍历

- 举例推导dp数组

> **代码**

```java
class Solution {
    public int rob(int[] nums) {

        if(nums.length == 0){
            return 0;
        }

        if(nums.length == 1){
            return nums[0];
        }

        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for(int i = 2;i < nums.length;i++){
            dp[i] = Math.max(dp[i - 1],dp[i - 2] + nums[i]);
        }

        return dp[nums.length - 1];

    }
}
```

## 4.2[打家劫舍II](https://leetcode.cn/problems/house-robber-ii/)


> **动态规划五步曲**

> **代码**

```java


```

## 4.3[打家劫舍III](https://leetcode.cn/problems/house-robber-iii/)

**树形dp的入门题目**

> **思路**

- 确定递归函数的参数和返回值
  - 返回值：要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。此处返回数组即为dp数组
  - 递归函数参数：当前节点
  
  ```java
  public int[] robTree(TreeNode root){

  }
  ```

- 确定终止条件
  在遍历过程中，如果遇到空节点的话，无论偷还是不偷都是0，因此返回[0,0],这也相当于dp数组初始化。
  
  ```java
    if(root == null){
        return new int[]{8,0};
    }
  ```

- 确定遍历顺序

首先明确的是使用后序遍历，

通过递归左节点，得到左节点偷与不偷的结果 left;

通过递归右节点，得到左节点偷与不偷的结果 right;

```java
int[] left = robTree(root.left);
int[] right = robber(root.right);
```

- 确定单层递归逻辑

如果偷当前节点，那么左右子树就不能偷，因此

```java
    val1 = root.val + left[0] + right[0]
```

如果不偷当前节点，那么左右子树就可以偷，因此

```java
    val2 = max(max(left[0].left[1]),max(right[0],right[1]));
```

最终代码如下

```java
    int[] left = robTree(root.left);
    int[] right = robTree(root.right);
    // 偷当前节点
    int val1 = root.val + left[0] + left[1];

    // 不偷当前节点

    int val2 = Math.max(left[0],left[1]) + Math.max(right[0],right[1]);

    return new int[]{val1.val2} 

```
***

> **代码**

```java
class Solution {
    public int rob(TreeNode root) {

        int[] res = robTree(root);

        return Math.max(res[0],res[1]);

    }

    private int[] robTree(TreeNode root){
        if(root == null){
            return new int[]{0,0};
        }

        int[] left = robTree(root.left);
        int[] right = robTree(root.right);

        // 偷当前节点
        int val1 = root.val + left[0] + right[0];

        // 不偷当前节点
        int val2 = Math.max(left[0],left[1]) + Math.max(right[0],right[1]);

        return new int[]{val2,val1};
    }
}
```
> **复杂度分析**

- 时间复杂度:${O(n)}$
- 空间复杂度:${O(n)}$

***

# 五、股票问题

![股票问题](https://code-thinking.cdn.bcebos.com/pics/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg)

## 5.1 [买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

> **动态规划五步曲**

- 确定dp数组及其下标含义
dp0:表示当天不持有股票所获得的最大利润
dp1:表示当天持有股票时所获得的最大利润

- 确定递推公式
  
```java
dp0 = max(dp0,dp1 + value[i]);
// 注意：只能选择某一天买入该股票
dp1 = max(dp1,- value[i]);
```

- 初始化dp数组

```java
dp0 = 0;
dp1 = -value[0];
```

- 确定遍历方向
从左到右依次进行遍历

- 举例推导dp数组

> **代码**

```java
class Solution {
    public int maxProfit(int[] prices) {
        int dp0 = 0;
        int dp1 = -prices[0];

        for(int i = 1;i < prices.length;i++){
            dp0 = Math.max(dp0,dp1 + prices[i]);
            dp1 = Math.max(dp1,-prices[i]);
        }
        return dp0;
    }
}
```

> **复杂度分析**

- 时间复杂度:${O(n)}$
- 空间复杂度:${O(1)}}$


## 5.2 [买卖股票的最佳时机II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

> **动态规划五步曲**

- 确定dp数组及其下标含义

dp0:当天不持有股票所能获得的最大利润
dp1:当前持有股票时所能获得的最大利润

- 确定递推公式

```java
dp0 = max(dp0,dp1 + prices[i]);
dp1 = max(dp1,dp0 + prices[i]);
```

- 初始化dp数组

```java
dp0 = 0;
dp1 = -prices[0];
```

- 确定遍历方向
从左到右依次进行遍历

- 举例推导dp数组

> **代码**

```java
class Solution {
    public int maxProfit(int[] prices) {
        int dp0 = 0;
        int dp1 = -prices[0];

        for(int i = 1;i < prices.length;i++){
            int temp = dp0;
            dp0 = Math.max(dp0,dp1 + prices[i]);
            dp1 = Math.max(dp1,temp - prices[i]);
        }
        return dp0;
    }
}
```

> **复杂度分析**
- 时间复杂度:${O(n)}$
- 空间复杂度:${O(1)}$


***

## 5.4 [买卖股票的最佳时机IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

> **动态规划五步曲**

- 定义dp数组
  - buy[i][j]:表示第i天进行j次买入操作时所能获得最大收益
  - sell[i][j]:表示第i天进行j次卖出操作时所能获得最大收益

- 确定状态转移方程

```java
// 昨天就买入，今天买入
buy[i][j] = Math.max(buy[i - 1][j],sell[i - 1][j] - prices[i]);
// 昨天卖出，今天卖出
sell[i][j] = Math.max(sell[i - 1][j],buy[i - 1][j - 1] + prices[i]);
```

- 初始化dp数组

数组维度：因为n天最多只能交易n/2次，因此可以将k与n/2进行比较后取其中小者对数组进行初始化

由于buy[0][j]中只有buy[0][0] = -prices[0],表示合法状态，因此对于其他值取极小值表示不合法状态

同理sell[0][j] 中只有sell[0][0]表示合法状态，因此对于其他值取极小值表示不合法状态

sell[i][j] 的状态转移方程中包含 buy[i−1][j−1]，在 j=0 时其表示不合法的状态，因此在 j=0 时，我们无需对 sell[i][j] 进行转移，让其保持值为 0 即可。

- 确定遍历方向与顺序

由递推公式可知，保持递推方向为从左到右一次递推即可

- 确定返回值

由于在所有的 n 天结束后，手上不持有股票对应的最大利润一定是严格由于手上持有股票对应的最大利润的，然而完成的交易数并不是越多越好（例如数组 prices 单调递减，我们不进行任何交易才是最优的），因此最终的答案即为 sell[n−1][0..k] 中的最大值。

***

# 六、子序列问题

## 6.1 [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

### 6.1.1 动态规划
> **动态规划五步曲**

- 确定dp数组及其下标含义
dp[i] 表示位于i时最长严格递增子序列的长度为dp[i]

- 确定递推公式
  
    ```java
    for(int i = 0;i < nums.length;i++){
        for(int j = i - 1;j >= 0;j--){
            if(nums[i] > nums[j]){
                dp[i] = Math.max(dp[i],dp[j] + 1);
            }else{
                dp[i] = Math.max(dp[i],1);;
            }
        }
    }
    ```

- 初始化dp数组
dp[0] = 1,其余位置均为0

- 确定遍历方向与顺序
两层循环嵌套，第一层从左到右，第二层从右到左

- 确定返回值
返回dp数字中的最大值即可

> **代码**

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = 1;
        for(int i = 0;i < nums.length;i++){
            for(int j = i - 1;j >= 0;j--){
                if(nums[i] > nums[j]){
                    dp[i] = Math.max(dp[i],dp[j] + 1);
                }else{
                    dp[i] = Math.max(dp[i],1);;
                }
            }
        }
        int ans = 0;
        for(int i = 0;i < nums.length;i++){
            ans = Math.max(ans,dp[i]);
        }
        return ans;

    }
}
```

> **复杂度分析**

- 时间复杂度:${O(n^2)}$
- 空间复杂度:${O(n)}$

### 6.1.2 动态规划 + 二分查找

[题解](https://leetcode.cn/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/)


## 6.2 [最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

### 6.2.1 动态规划

> **动态规划五步曲**

- 确定dp数组及其下标含义
dp[i]:表示位于位置i时最长的连续递增数列

- 确定递推公式

    ```java
    if(nums[i] > nums[i - 1]){
        dp[i] = dp[i - 1] + 1; 
    }else{
        dp[i] = 1;
    }
   ```
- 初始化dp数组
dp[0] = 0;

- 确定遍历方向与顺序
从左到右依次进行遍历

- 确定返回值
ans = Math.max(dp[i],1);

> **代码**

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = 1;
        int ans = 1;
        for(int i = 1;i < n;i++){
            if(nums[i] > nums[i - 1]){
                dp[i] = dp[i - 1] + 1;
            }else{
                dp[i] = 1;
            }
            ans = Math.max(ans,dp[i]);
        }
        return ans;
    }
}
```

> **复杂度分析**

- 时间复杂度:${O(n)}$
- 空间复杂度:${O(n)}$

### 6.2.2 贪心算法



## 6.3 [最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

> **动态规划五步曲**

- **确定dp数组及下标含义**

dp[i][j]:以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。 （特别注意： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）

- **确定递推公式**

```java
if(A[i - 1] == B[i - 1]){
    dp[i][j] = dp[i - 1][j - 1] + 1;
}
```

- **初始化dp数组**
根据dp[i][j]的定义，dp[i][0] 和dp[0][j]其实都是没有意义的！
但dp[i][0] 和dp[0][j]要初始值，因为 为了方便递归公式dp[i][j] = dp[i - 1][j - 1] + 1;
所以dp[i][0] 和dp[0][j]初始化为0。

- **确定遍历方向与顺序**

从左到右依次进行遍历

- **确定返回值**
返回dp[i][j]中的最大值

> **代码**

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;

        int[][] dp = new int[n + 1][m + 1];

        int ans = 0;

        for(int i = 1;i <= n;i++){
            for(int j = 1;j <= m;j++){
                if(nums1[i - 1] == nums2[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                ans = Math.max(ans,dp[i][j]);
            }
        }
        return ans;
    }
}
```

> **复杂度分析**

- 空间复杂度:$O(n)$
- 时间复杂度:${O(n^ 2)}$
  
## 6.4 [最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)
***
