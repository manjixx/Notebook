# 一、回溯算法基础

> **什么是回溯法**

回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。回溯函数也就是递归函数，指的都是一个函数。

> **回溯法的效率**

回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

> **回溯法解决的问题**

- 组合问题：N个数里面按一定规则找出k个数的集合,**组合无序，排列有序**
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

> **用树形结构理解回溯法**

**所有用回溯法解决的问题都可以抽象为树形结构**

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，就构成的树的深度**。

递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

> **回溯算法模版**

- 确定返回值与函数参数
  回溯算法中函数返回值一般为void
  参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
- 终止条件
  什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
- 回溯搜索的遍历过程
  回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
  ![回溯搜索的遍历过程](https://img-blog.csdnimg.cn/20210130173631174.png)

```java
/**
    核心在于：for循环里的递归，在递归调用之前做选择，在递归调用之后撤销选择
    如上图所示：for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历
*/

void backtrack(路径，选择列表){
     if(终止条件){
        res.add(路径);
        return;
    }

    for 选择 in 选择列表{
        做选择;
        backtrack(路径，选择);
        撤销选择;
    }
}
```

# 二、组合

## 2.1 [组合](https://leetcode.cn/problems/combinations/)

> **回溯法三部曲**

- 确定回溯函数参数列表与返回值

- 确定终止条件

- 回溯遍历搜索过程

> **剪枝操作**

> **代码**

> **复杂度分析**

# 三、分割

# 四、子集

# 五、排列

# 六、棋盘问题

# 七、其他
