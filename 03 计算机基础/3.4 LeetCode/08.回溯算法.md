# 一、回溯算法基础

> **什么是回溯法**

回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。回溯函数也就是递归函数，指的都是一个函数。

> **回溯法的效率**

回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

> **回溯法解决的问题**

- 组合问题：N个数里面按一定规则找出k个数的集合,**组合无序，排列有序**
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

> **用树形结构理解回溯法**

**所有用回溯法解决的问题都可以抽象为树形结构**

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，就构成的树的深度**。

递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

> **回溯算法模版**

- 确定返回值与函数参数
  回溯算法中函数返回值一般为void
  参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
- 终止条件
  什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
- 回溯搜索的遍历过程
  回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
  ![回溯搜索的遍历过程](https://img-blog.csdnimg.cn/20210130173631174.png)

```java
/**
    核心在于：for循环里的递归，在递归调用之前做选择，在递归调用之后撤销选择
    如上图所示：for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历
*/

void backtrack(路径，选择列表){
     if(终止条件){
        res.add(路径);
        return;
    }

    for 选择 in 选择列表{
        做选择;
        backtrack(路径，选择);
        撤销选择;
    }
}
```

# 二、组合

## 2.1 [组合](https://leetcode.cn/problems/combinations/)

> **回溯法三部曲**

- 确定回溯函数参数列表与返回值
  
```java
private void backtrack(int startIndex,int n,int k){

}
```

- 确定终止条件

```java
if(path.size() == k){
  res.add(new ArrayList<>(path));
  return;
}
```

- 回溯遍历搜索过程

```java
for(int i = startIndex;i <= n;i++){
    path.add(i);
    backtrack(i + 1;n;k);
    path.remove();
}

```

> **剪枝操作**

遍历的范围是可以剪枝优化的，怎么优化呢？

来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。如下图所示：

![剪枝优化](https://pic.leetcode-cn.com/3ddd55697423b5831cbbd42f4b901ebbade0daa456c651a70c758fe359d8a0d1-image.png)

可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。

如果**for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数**了，那么就没有必要搜索了。

- 已经选择的元素个数:path.size()
- 还需要的元素个数为:k - path.size()
- 在集合n中至多要从该起始位置: n - (k - path.size()) + 1 开始遍历
为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。


> **代码**

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> track = new LinkedList<>();

    public List<List<Integer>> combine(int n, int k) {
        backtrack(1,n,k);
        return result;
    }

    private void backtrack(int startIndex,int n,int k){
      if(path.size() == k){
        res.add(new ArrayList<>(path));
        return;
      }

      for(int i = startIndex;i <= n - (k - path.size()) + 1;i++){
        path.add(i);
        backtrack(i + 1,n,k);
        path.remove();
      }
    }

```

> **复杂度分析**
- 时间复杂度：$O((^k_n)×k)$
- 空间复杂度:O(n)


## 2.2 [组合总和III](https://leetcode.cn/problems/combination-sum-iii/)

> **回溯法三部曲**

- 确定返回值与函数参数
  - 目标和targetSum
  - k：题目中要求k个数的集合
  - sum：已经收集的元素的总和，下一层for循环的起始位置
  - startIndex（int）为下一层for循环搜索的起始位置。


```java
private void backtrack(int targetSum,int k,int sum,int startIndex){

}
```

- 确定终止条件

```java
if(path.size() == k){
  if(sum == targetSum){
      res.add(new ArrayList<>(path));
  }
  return;
}
```

- 确定单层递归逻辑


```java
// -未进行剪枝操作
for(int i = startIndex; i <= 9;i++){
  sum = sum + i;
  path.add(i);
  backtrack(targetSum,k,sum,i + 1);
  sum = sum - i;
  path.remove();
}

/**
  剪枝优化
  - 当前路径中所含有元素数量 path.size()
  - 还需元素数量 k - path.size()
  - 在集合n中至多要从该起始位置: n - (k - path.size()) + 1 开始遍历为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。
 */

 for(int i = startIndex;i <= 9 - (k - path.size()) + 1;i++){
    path.add(i);
    sum = sum + i;
    backtrack(targetSum,k,sum,i + 1);
    sum = sum - i;
    path.removeLast();
 }
```

> **代码**

```java
class Solution {

    List<List<Integer>> result = new ArrayList<List<Integer>>();
    LinkedList<Integer> path = new LinkedList<Integer>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtrack(n,k,0,1);
        return result;
    }

    public void backtrack(int targetSum,int k,int sum,int startIndex){

        if(path.size() == k){
            if(sum == targetSum){
                result.add(new ArrayList<>(path));
            }
            return;
        }
        // 不剪枝
        // for(int i = startIndex;i <= 9;i++){
        //     sum = sum + i;
        //     path.add(i);
        //     backtrack(targetSum,k,sum, i + 1);
        //     sum = sum - i;
        //     path.removeLast();
        // }
        for(int i = startIndex;i <= 9 - (k - path.size()) + 1;i++){
            path.add(i);
            sum = sum + i;
            backtrack(targetSum,k,sum,i + 1);
            sum = sum - i;
            path.removeLast();
        }
    }
}
```

> **复杂度分析**

- 时间复杂度:${O(M * 2^M)}$,其中 M 为集合的大小，本题中 M 固定为 9。一共有 ${2^M}$个状态，每个状态需要 ${O(M + k) = O(M)}$ 的判断 ${（k \leq M）}$，故时间复杂度为 ${O(M×2^M)}$。
- 空间复杂度:${O(M)}$

## 2.3 [电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

> **动态规划三部曲**

- 确定回溯函数参数列表

首先需要一个String Builder 用来存放子叶节点结果

一个List用于存放最终结果合集


```java
/**
  digits: 题目给出的电话号码字符串
  index: 表示当前遍历到digits中第几个数字
 */

private void backTrack(String digits,int index){

}
```

- 确定终止条件

```java
if(index == digits.length()){
    result.add(sb.toString());
    return;
}
```

- 确定单层递归逻辑

因为需要获得数字对应的字符串因此需要提前定义全局字符串数组变量，用于暂存数字对应的字符串

```java
    String[] numString = new String[]{"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
```

```java
// 获取当前数字对应的字符串
String s = numString[digits.charAt(index) - '0'];

for(int i = 0;i < s.length();i++){
    sb.append(s.charAt(i));
    backTrack(digits,index + 1);
    sb.deleteCharAt(sb.length() - 1);
}
```

> **代码**

```java
class Solution {

    List<String> result = new ArrayList<String>();

    String[] numString = new String[]{"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};

    StringBuilder sb = new StringBuilder();    

    public List<String> letterCombinations(String digits) {

        if(digits == null || digits.length() == 0){
            return result;
        }

        backTrack(digits,0);
        return result;

    }

    private void backTrack(String digits,int index){

        if(index == digits.length()){
            result.add(sb.toString());
            return;
        }

        String s = numString[digits.charAt(index) - '0'];

        for(int i = 0;i < s.length();i++){
            char ch = s.charAt(i);
            sb.append(ch);
            backTrack(digits,index + 1);
            sb.deleteCharAt(sb.length() - 1);
        }
    }
}

```

> **复杂度分析**

- 时间复杂度:${O(3^m ×4^n)}$ 其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、4、5、6、8），n 是输入中对应 4 个字母的数字个数（包括数字 7、9），m+n 是输入数字的总个数。当输入包含 m 个对应 3 个字母的数字和 n 个对应 4 个字母的数字时，不同的字母组合一共有 ${3^m ×4^n}$种，需要遍历每一种字母组合。
- 空间复杂度:${O(m+n)}$，其中 m 是输入中对应 3 个字母的数字个数，n 是输入中对应 4 个字母的数字个数，m+n 是输入数字的总个数。除了返回值以外，空间复杂度主要取决于哈希表以及回溯过程中的递归调用层数，哈希表的大小与输入无关，可以看成常数，递归调用层数最大为 m+n。

## 2.4 [组合总和](https://leetcode.cn/problems/combination-sum/)

## 2.5 [组合总和II](https://leetcode.cn/problems/combination-sum-ii/)

## 2.6 [分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

> **分析**

![](https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg)


> **回溯三部曲**

- 确定返回值与函数参数

本题递归函数参数还需要startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。

```java

void backTrack(String s,int startIndex){

}
```

- 确定终止条件

```java
if(startIndex >= s.length()){
  result.add(new ArrayList<String>(path));
  return;
}
```

- 单层搜索逻辑

```java
for(int i = startIndex;i < s.length();i++){
  if(isPalindrome(s,startIndex,i)){
    // 获取[startIndex,i]在s中的子串
    String sub = s.substring(startIndex,i + 1);
    path.add(sub);
  }else{
    continue;
  }
  backTrack(s,i + 1);
  path.removeLast()
}

// 判断回文子串

private boolean isPalindrome(String s,int start,int end){
  for(int i = start,j = end;i < j;i++,j--){
    if(s.charAt(i) ! = s.charAt(j)){
      return false
    }
  }
  return true;
}
```

> **代码**

```java
class Solution {

    List<List<String>> res = new ArrayList<List<String>>();
    LinkedList<String> path = new LinkedList<String>();
    public List<List<String>> partition(String s) {
        backTrack(s,0);
        return res;
    }

    public void backTrack(String s, int startIndex){
      // 终止条件
      if(startIndex >= s.length()){
          res.add(new ArrayList<String>(path));
          return;
      }

      // 单层搜索逻辑
      for(int i = startIndex;i < s.length();i++){
          if(isPalindrome(s,startIndex,i)){
               String sub = s.substring(startIndex,i + 1);
               path.add(sub); 
          }else{
            continue;
          }

          backTrack(s,i + 1);
          path.removeLast();
      }
    }

    // 判断是否为回文子串

    private boolean isPalindrome(String s,int start, int end){
        for(int i = start,j = end;i < j;i++,j--){
            if(s.charAt(i) ! = s.charAt(j)){
                return false;
            }
        }
        return true;
    }
}

```

> **复杂度分析**
- 时间复杂度:${O(n⋅2^n)}$，其中 n 是字符串 s 的长度。在最坏情况下，s 包含 n 个完全相同的字符，因此它的任意一种划分方法都满足要求。而长度为 n 的字符串的划分方案数为 $2^{n-1}=O(2^n) $，每一种划分方法需要 $O(n)$ 的时间求出对应的划分结果并放入答案，因此总时间复杂度为 $O(n⋅2^n)$。尽管动态规划预处理需要 O(n^2)的时间，但在渐进意义下小于 $O(n⋅2^n)$，因此可以忽略。

- 空间复杂度:：$O(n^2)$，这里不计算返回答案占用的空间。在回溯的过程中，我们需要使用 O(n) 的栈空间以及 O(n) 的用来存储当前字符串分割方法的空间。由于O(n) 在渐进意义下小于 $O(n^2)$，因此空间复杂度为$O(n^2)$.

## 2.7

***

# 三、分割

# 四、子集

# 五、排列

# 六、棋盘问题

# 七、其他
