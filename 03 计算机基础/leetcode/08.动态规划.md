- [一、动态规划基础](#一动态规划基础)
  - [1.1 动态规划](#11-动态规划)
- [二、基础题目](#二基础题目)
  - [2.1 斐波那契数列](#21-斐波那契数列)
    - [思路一:动态规划](#思路一动态规划)
    - [思路二：递归](#思路二递归)
  - [2.2 爬楼梯](#22-爬楼梯)
    - [思路一:动态规划](#思路一动态规划-1)
    - [思路二：递归](#思路二递归-1)
  - [2.3 最小花费爬楼梯](#23-最小花费爬楼梯)
  - [2.4 不同路径](#24-不同路径)
    - [思路一:动态规划](#思路一动态规划-2)
    - [思路二:DFS](#思路二dfs)
    - [思路三:数论](#思路三数论)
  - [2.5 不同路径II](#25-不同路径ii)
- [三、背包问题](#三背包问题)
- [四、打家劫舍](#四打家劫舍)
- [五、股票问题](#五股票问题)
- [六、子序列问题](#六子序列问题)
  
***

# 一、动态规划基础

![动态规划刷题大纲](https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg)

## 1.1 动态规划

> **动态规划**

动态规划(Dynamic Programming)，简称DP，如果**某一问题有很多重叠子问题**，使用动态规划是最有效的。

> **动态规划与贪心的区别**

态规划中每一个状态一定是由上一个状态推导出来

贪心没有状态推导，而是从局部直接选最优。

> **动态规划的解题步骤**

- 确定dp数组（dp table）以及下标的含义
- 确定递推公式
- dp数组如何初始化
- 确定遍历顺序
- 举例推导dp数组

> **动态规划DEBUG**

- 这道题目是否举例推导了状态转移公式
- 是否打印dp数组的日志
- 打印出来了dp数组与预想的是否一致
  
***

# 二、基础题目

## 2.1 [斐波那契数列](https://leetcode.cn/problems/fibonacci-number/)

### 思路一:动态规划

> **思路**

**五步走**

- 确定dp数组及其下标的含义：dp[i]表示第i个斐波那契数
- 确定递推公式
  
```java
dp[i] = dp[i - 1] + dp[i - 2]
```

- dp数组的初始化
  
```java
dp[0] = 0;
dp[1] = 1;
```

- 确定遍历顺序：从前到后遍历

- 举例推导dp数组

> **代码**

```java
class Solution {
    public int fib(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2;i <= n;i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}

/**空间优化 */
 public int fib(int n) {
    if(n == 0 || n == 1){
        return n;
    }
    int dp0 = 0;
    int dp1 = 1;
    int ans = 0;
    for(int i = 2;i <= n;i++){
        ans = dp0 + dp1;
        dp0 = dp1;
        dp1 = ans;
    }
    return ans;
}
```

> **复杂度分析**

- 时间复杂度:O(n)
- 空间复杂度:未优化前O(n),优化后O(1)

### 思路二：递归

**代码实现**

```java
 public int fib(int n) {
        if(n == 0 || n == 1){
            return n;
        }
        return fib(n - 1) + fib(n - 2);
    }

```

**复杂度分析**

- 时间复杂度:O(2^n)
- 空间复杂度：O(n)，算上了编程语言中实现递归的系统栈所占空间

## 2.2 [爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

### 思路一:动态规划

> **思路**

- 确定dp数组及其下标的含义：dp[i] 表示有多少种方法可以爬到当前位置i
- 确定递推公式：

```java
dp[i] = dp[i - 1] + dp[i - 2];
```

- 初始化dp数组
  
```java
dp[0] = 0;
dp[1] = 1;
dp[2] = 2;
```

- 确定遍历顺序:从前到后遍历

- 举例推导dp数组

> **代码**

```java
public int climbStairs(int n) {
        if(n == 1 || n == 2){
            return n;
        }
        int dp1 = 1;
        int dp2 = 2;
        int ans = 0;
        for(int i = 3;i <= n;i++){
            ans = dp1 + dp2;
            dp1 = dp2;
            dp2 = ans;
        }
        return ans;
    }
```

**复杂度分析**

- 时间复杂度:O(n)
- 空间复杂度:O(1)


### 思路二：递归

此处略去
***

## 2.3 [最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

> **思路**

本题思路可参考[链接中思路二](https://leetcode.cn/problems/min-cost-climbing-stairs/solution/yi-bu-yi-bu-tui-dao-dong-tai-gui-hua-de-duo-chong-/)

- 确定dp数组及其下标的含义：dp[i] 为到达当前位置所需的最小花费

- 确定递推公式
  
```java
dp[i] = min(dp[i - 1],dp[i - 2]) + cost[i];
```

- 初始化dp数组
  
```java
dp[0] = cost[0];
dp[1] = cost[1];
```
- 确定遍历顺序:从前到后遍历

- 举例推导dp数组

- 注意此题的返回值

> **代码**

```java
public int minCostClimbingStairs(int[] cost) {
    int len = cost.length;
    int dp0 = cost[0];
    int dp1 = cost[1];
    int ans = 0;

    for(int i = 2; i < len;i++){
        ans = Math.min(dp0,dp1) + cost[i];
        dp0 = dp1;
        dp1 = ans;
    }
    return Math.min(dp0,dp1);
}
```

> **复杂度分析**

- 时间复杂度:O(n);
- 空间复杂度:O(1);

## 2.4 [不同路径](https://leetcode.cn/problems/unique-paths/)

### 思路一:动态规划
> **思路**

- 确定dp数组及其下标的含义：dp[i][j] 表示到达当前位置(i,j)的路径数

- 确定递推公式/转移方程

```java
dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
```

- 初始化dp数组

```java
for(int j = 0; j < n;j++){
    dp[0][j] = 1;
}

for(int i = 0;i < m;i++){
    dp[i][0] = 1;
}
```

- 确定遍历顺序：从前到后，从左到右遍历

```java
for(int i = 1;i < m;i++){
    for(int j = 1;j < n;j++){
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
}
```

- 举例推导dp数组
  
> **代码**

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];

        for(int j = 0; j < n;j++){
            dp[0][j] = 1;
        }

        for(int i = 0;i < m;i++){
            dp[i][0] = 1;
        }

        for(int i = 1;i < m;i++){
            for(int j = 1;j < n;j++){
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];

    }
}
```

> **复杂度分析**

- 时间复杂度:O(m * n)
- 空间复杂度:O(m * n)

### 思路二:DFS

### 思路三:数论


## 2.5 [不同路径II](https://leetcode.cn/problems/unique-paths-ii/)
# 三、背包问题

***

# 四、打家劫舍

***

# 五、股票问题

***

# 六、子序列问题

***
