- [一、动态规划基础](#一动态规划基础)
  - [1.1 动态规划](#11-动态规划)
- [二、基础题目](#二基础题目)
  - [2.1 斐波那契数列](#21-斐波那契数列)
    - [思路一:动态规划](#思路一动态规划)
    - [思路二：递归](#思路二递归)
  - [2.2 爬楼梯](#22-爬楼梯)
    - [思路一:动态规划](#思路一动态规划-1)
    - [思路二：递归](#思路二递归-1)
  - [2.3 最小花费爬楼梯](#23-最小花费爬楼梯)
  - [2.4 不同路径](#24-不同路径)
    - [思路一:动态规划](#思路一动态规划-2)
    - [思路二:DFS](#思路二dfs)
    - [思路三:数论](#思路三数论)
  - [2.5 不同路径II](#25-不同路径ii)
    - [思路一：动态规划](#思路一动态规划-3)
  - [2.6 整数拆分](#26-整数拆分)
  - [2.7 不同的二叉搜索树](#27-不同的二叉搜索树)
    - [思路一:动态规划](#思路一动态规划-4)
- [三 背包问题](#三-背包问题)
  - [3.1 0-1 背包基础](#31-0-1-背包基础)
  - [3.2 分割等和子集](#32-分割等和子集)
    - [3.2.1 思路一: 0-1背包](#321-思路一-0-1背包)
  - [3.3 最后一块石头重量II](#33-最后一块石头重量ii)
    - [思路一:动态规划](#思路一动态规划-5)
- [四、打家劫舍](#四打家劫舍)
- [五、股票问题](#五股票问题)
- [六、子序列问题](#六子序列问题)
  
***

# 一、动态规划基础

![动态规划刷题大纲](https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg)

## 1.1 动态规划

> **动态规划**

动态规划(Dynamic Programming)，简称DP，如果**某一问题有很多重叠子问题**，使用动态规划是最有效的。

> **动态规划与贪心的区别**

态规划中每一个状态一定是由上一个状态推导出来

贪心没有状态推导，而是从局部直接选最优。

> **动态规划的解题步骤**

- 确定dp数组（dp table）以及下标的含义
- 确定递推公式
- dp数组如何初始化
- 确定遍历顺序
- 举例推导dp数组

> **动态规划DEBUG**

- 这道题目是否举例推导了状态转移公式
- 是否打印dp数组的日志
- 打印出来了dp数组与预想的是否一致
  
***

# 二、基础题目

## 2.1 [斐波那契数列](https://leetcode.cn/problems/fibonacci-number/)

### 思路一:动态规划

> **思路**

**五步走**

- 确定dp数组及其下标的含义：dp[i]表示第i个斐波那契数
- 确定递推公式
  
```java
dp[i] = dp[i - 1] + dp[i - 2]
```

- dp数组的初始化
  
```java
dp[0] = 0;
dp[1] = 1;
```

- 确定遍历顺序：从前到后遍历

- 举例推导dp数组

> **代码**

```java
class Solution {
    public int fib(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2;i <= n;i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}

/**空间优化 */
 public int fib(int n) {
    if(n == 0 || n == 1){
        return n;
    }
    int dp0 = 0;
    int dp1 = 1;
    int ans = 0;
    for(int i = 2;i <= n;i++){
        ans = dp0 + dp1;
        dp0 = dp1;
        dp1 = ans;
    }
    return ans;
}
```

> **复杂度分析**

- 时间复杂度:O(n)
- 空间复杂度:未优化前O(n),优化后O(1)

### 思路二：递归

**代码实现**

```java
 public int fib(int n) {
        if(n == 0 || n == 1){
            return n;
        }
        return fib(n - 1) + fib(n - 2);
    }

```

**复杂度分析**

- 时间复杂度:O(2^n)
- 空间复杂度：O(n)，算上了编程语言中实现递归的系统栈所占空间

## 2.2 [爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

### 思路一:动态规划

> **思路**

- 确定dp数组及其下标的含义：dp[i] 表示有多少种方法可以爬到当前位置i
- 确定递推公式：

```java
dp[i] = dp[i - 1] + dp[i - 2];
```

- 初始化dp数组
  
```java
dp[0] = 0;
dp[1] = 1;
dp[2] = 2;
```

- 确定遍历顺序:从前到后遍历

- 举例推导dp数组

> **代码**

```java
public int climbStairs(int n) {
        if(n == 1 || n == 2){
            return n;
        }
        int dp1 = 1;
        int dp2 = 2;
        int ans = 0;
        for(int i = 3;i <= n;i++){
            ans = dp1 + dp2;
            dp1 = dp2;
            dp2 = ans;
        }
        return ans;
    }
```

**复杂度分析**

- 时间复杂度:O(n)
- 空间复杂度:O(1)


### 思路二：递归

此处略去
***

## 2.3 [最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

> **思路**

本题思路可参考[链接中思路二](https://leetcode.cn/problems/min-cost-climbing-stairs/solution/yi-bu-yi-bu-tui-dao-dong-tai-gui-hua-de-duo-chong-/)

- 确定dp数组及其下标的含义：dp[i] 为到达当前位置所需的最小花费

- 确定递推公式
  
```java
dp[i] = min(dp[i - 1],dp[i - 2]) + cost[i];
```

- 初始化dp数组
  
```java
dp[0] = cost[0];
dp[1] = cost[1];
```
- 确定遍历顺序:从前到后遍历

- 举例推导dp数组

- 注意此题的返回值

> **代码**

```java
public int minCostClimbingStairs(int[] cost) {
    int len = cost.length;
    int dp0 = cost[0];
    int dp1 = cost[1];
    int ans = 0;

    for(int i = 2; i < len;i++){
        ans = Math.min(dp0,dp1) + cost[i];
        dp0 = dp1;
        dp1 = ans;
    }
    return Math.min(dp0,dp1);
}
```

> **复杂度分析**

- 时间复杂度:O(n);
- 空间复杂度:O(1);

## 2.4 [不同路径](https://leetcode.cn/problems/unique-paths/)

### 思路一:动态规划
> **思路**

- 确定dp数组及其下标的含义：dp[i][j] 表示到达当前位置(i,j)的路径数

- 确定递推公式/转移方程

```java
dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
```

- 初始化dp数组

```java
for(int j = 0; j < n;j++){
    dp[0][j] = 1;
}

for(int i = 0;i < m;i++){
    dp[i][0] = 1;
}
```

- 确定遍历顺序：从前到后，从左到右遍历

```java
for(int i = 1;i < m;i++){
    for(int j = 1;j < n;j++){
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
}
```

- 举例推导dp数组
  
> **代码**

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];

        for(int j = 0; j < n;j++){
            dp[0][j] = 1;
        }

        for(int i = 0;i < m;i++){
            dp[i][0] = 1;
        }

        for(int i = 1;i < m;i++){
            for(int j = 1;j < n;j++){
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];

    }
}
```

> **复杂度分析**

- 时间复杂度:O(m * n)
- 空间复杂度:O(m * n)

### 思路二:DFS

### 思路三:数论


## 2.5 [不同路径II](https://leetcode.cn/problems/unique-paths-ii/)

### 思路一：动态规划

> **思路**

dp数组的定义、初始化与遍历方向与 不同路径 相同，需要特别注意的是对于**障碍物的处理**

> **代码**

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;

        int[][] dp = new int[m][n];

        for(int j = 0; j < n;j++){
            if(obstacleGrid[0][j] == 1){
                break;
            }
            dp[0][j] = 1;
        }

        for(int i = 0;i < m;i++){
            if(obstacleGrid[i][0] == 1){
                break;
            }
            dp[i][0] = 1;
        }

        for(int i = 1;i < m;i++){
            for(int j = 1;j < n;j++){
                if(obstacleGrid[i][j] == 1){
                    dp[i][j] = 0;
                    continue;
                }
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];

    }
}
```

> **复杂度分析**

- 时间复杂度:O(m * n)
- 空间复杂度:O(m * n)

## 2.6 [整数拆分](https://leetcode.cn/problems/integer-break/)

> **思路**

- 确定dp数组及其下标的含义：dp[i]定义为拆分数字i时可以得到的最大值
- 确定递推公式：
  
```java
dp[i] = max((i - j) * j,(i - j) * dp[j],dp[i])
```

- 初始化dp数组

```java
dp[2] = 1
```

- 确定遍历顺序:由递推公式可得到，遍历方向为从前到后

> **代码**
```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];

        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 1;

        for(int i = 3;i <= n;i++){
            for(int j = 1;j < i;j++){
                int temp = Math.max(dp[j] * (i - j),(i - j) * j);
                dp[i] = Math.max(dp[i],temp);
            }
        }
        return dp[n];
    }
}
```
> **复杂度分析**
- 空间复杂度:O(n);
- 时间复杂度:${O(n^2)}$


## 2.7 [不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

### 思路一:动态规划

> **思路**

- 确定dp数组及其下标的含义:定义dp[i]为根节点为i时，二叉搜索树的数量

- 确定递推公式:
  
    ![递推公式思路图](https://assets.leetcode-cn.com/solution-static/96/96_fig1.png)

    由上图可以看出，dp[i] = dp[i] + dp[i - j] * dp[j - 1], 即以 j - 1 为头节点的左子树数量 * 以 i- j为根接节点的二叉搜索树数量

- dp数组初始化

```java
dp[0] = 1;
```

- 确定遍历方向:从前往后遍历

- 举例推导dp数组
  
> **代码**

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for(int i = 1;i <= n; i++){
            for(int j = 1; j <= i;j++){
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
```

> **复杂度分析**

- 时间复杂度:${o(n^2)}$
- 空间复杂度:${o(n)}$
***

# 三 背包问题

## 3.1 0-1 背包基础

> **常见背包问题**

![常见背包问题](https://img-blog.csdnimg.cn/20210117171307407.png)

对于面试的话，其实掌握**01背包，和完全背包**，就够用了，最多可以再来一个多重背包。

> **0-1背包经典例子**

有n件物品，每件物品重量为w[i],每件物品价值为value[i]，有一个背包承重为w。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

![0-1背包](https://img-blog.csdnimg.cn/20210117175428387.jpg)

每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。

所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！

> **二维数组0-1背包**

**例题**

背包最大重量为4，物品如下表所示，问背包能背的物品最大价值是多少？
|       | 重量  | 价值 |
| :--:  | :--: | :--: |
|  物品0 |  1   |  15  |
|  物品1 |  3   |  20  |
|  物品2 |  4   |  30  |

**动态规划五步曲**


- 确定dp数组及其下标的含义

dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，最大的价值总和

![dp数组](https://img-blog.csdnimg.cn/20210110103003361.png)

- 确定递推公式
  - **明确dp数组的含义：** dp[i][j]的含义为：从下标为[0-i]的物品里任意取，放进容量为j的背包，最大价值总和，因此可以分为放物品和不放物品两个方向来确定：
  
  - **不放物品进背包**:dp[i][j] = dp[i - 1][j]
  
  - **放物品进背包**:dp[i][j] = dp[i - 1][j - weight[i]] + value[i]
  
  - 综上可得:dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i])

- 初始化dp数组(**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。**)
  - **从定义出发:** 当j=0时，无论取哪些物品，背包价值价值一定为0；
  - **从状态转移方程出发:** 因为状态转移方程为`dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - weight[i]] + value[i])`可知i= 0，一定需要初始化。即将物品0放入背包，此时可得dp[0][j] = 15,因此初始化之后的dp数组如下图所示:
  ![初始化后的dp数组](https://img-blog.csdnimg.cn/20210110103109140.png)
  
  - **初始化代码**
  
  ```java
  for(int j = 0;j < bagweight;j++){
    dp[0][j] = 15;
  }
  ```

- 确定遍历方向:**由dp数组的定义可知有两个遍历维度**
  
  - 先遍历物品再遍历背包承重
  
  ![先遍历物品再遍历背包承重](https://img-blog.csdnimg.cn/202101101032124.png)
  
  ![先遍历书包承重再遍历物品](https://img-blog.csdnimg.cn/20210110103244701.png)

- 举例推导dp数组

> **完整测试代码**

```java
public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagsize = 4;
        testweightbagproblem(weight, value, bagsize);
    }

    public static void testweightbagproblem(int[] weight, int[] value, int bagsize){
        int wlen = weight.length, value0 = 0;
        //定义dp数组：dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值
        int[][] dp = new int[wlen + 1][bagsize + 1];
        //初始化：背包容量为0时，能获得的价值都为0
        for (int i = 0; i <= wlen; i++){
            dp[i][0] = value0;
        }
        //遍历顺序：先遍历物品，再遍历背包容量
        for (int i = 1; i <= wlen; i++){
            for (int j = 1; j <= bagsize; j++){
                if (j < weight[i - 1]){
                    dp[i][j] = dp[i - 1][j];
                }else{
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]);
                }
            }
        }
        //打印dp数组
        for (int i = 0; i <= wlen; i++){
            for (int j = 0; j <= bagsize; j++){
                System.out.print(dp[i][j] + " ");
            }
            System.out.print("\n");
        }
    }
```

> **一维0-1背包**

**分析**

使用二维数组时，递推公式为：```dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - weight[i] + value[i]]```

其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);

与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

**动态规划五步曲**

- 确定dp数组定义及下标含义：在一维dp数组中，dp[j]表示从下标[0-j]的物品中任意取，放进容量为j的背包，价值总和最大

- 确定递推公式：

```java
/**
dp[j]表示未放入物品i
dp[j - weight[i]]表示放入物品i后的价值
 */
dp[j] = max(dp[j],dp[j - weight[i]] + value[j])
```

- 一维数组的初始化

关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。


- 一维数组的遍历顺序

这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。

如果正序遍历

dp[1] = dp[1 - weight[0]] + value[0] = 15

dp[2] = dp[2 - weight[0]] + value[0] = 30

此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

为什么倒序遍历，就可以保证物品只放入一次呢？

倒序就是先算dp[2]

dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）

dp[1] = dp[1 - weight[0]] + value[0] = 15

所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？

不可以！

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。

倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。

- 举例推导dp数组

![](https://img-blog.csdnimg.cn/20210110103614769.png)

**代码**

```java
    public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagWight = 4;
        testWeightBagProblem(weight, value, bagWight);
    }

    public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight){
        int wLen = weight.length;
        //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值
        int[] dp = new int[bagWeight + 1];
        //遍历顺序：先遍历物品，再遍历背包容量
        for (int i = 0; i < wLen; i++){
            for (int j = bagWeight; j >= weight[i]; j--){
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
            }
        }
        //打印dp数组
        for (int j = 0; j <= bagWeight; j++){
            System.out.print(dp[j] + " ");
        }
    }
```

***

## 3.2 [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

### 3.2.1 思路一: 0-1背包

> **思路**

想要用0-1背包解决一个问题，首先需要明确如下问题：

- 背包容量

- 背包中放入物品的重量以及物品的价值

- 背包中的元素是否可以重复入包，如果可以重复入包则为完全背包，否则为0-1背包

**针对本题的分析**

- 背包的体积为sum / 2
- 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
- 背包如果正好装满，说明找到了总和为 sum / 2 的子集。
- 背包中每一个元素是不可重复放入。

**动态规划五步曲**

- 1.确定dp数组及其下标的含义

    01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值可以最大为dp[j]。

    套到本题，dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]。

- 2.确定递推公式

    01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。

    所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);

- 3. dp数组如何初始化

本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。

- 4. 确定遍历顺序

    如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放入内层，且内层for循环倒序遍历

- 5. 举例推导dp数组

> **代码**

```java
class Solution {
    public boolean canPartition(int[] nums) {

        int sum = 0;

        for(int i = 0;i < nums.length;i++){
            sum = sum + nums[i];
        }

        if(sum % 2 == 1){
            return false;
        }

        int target = sum / 2;

        int[] dp = new int[target + 1];

        for(int i = 0;i < nums.length;i++){
            for(int j = target;j >= nums[i];j--){
                dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i]);
            }
        }
        return dp[target] == target;
    }
}
```

## 3.3 [最后一块石头重量II](https://leetcode.cn/problems/last-stone-weight-ii/)

### 思路一:动态规划

> **分析**

本题目可以将石头装入承重为总重量一半的背包中，**那么剩余的石头减去背包中的石头**，那么所求得结果即为最小可能重量。

同上一题一样需要分析几个问题
- 背包容量
  
- 物品重量与物品价值

- 背包中元素是否可以重复入包


本题题目中

- 背包的容量最大值为所有物品的重量

- 物品的重量为stones[i]，价值也为stones[i]

- 背包中元素不可以重复入包，因此为0-1背包解决一个问题

> **动态规划五步曲**

- 1. 确定dp数组及其下标的含义

    dp[j]表示背包容量为j时，可以装入的石头的重量

- 2. 确定递推公式

    0-1背包的递推公式为：dp[j] = max(dp[j],dp[j - stones[i]] + stones[i])

- 3. 初始化dp数组
    
  - dp数组的大小：dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。因为提示中给出1 <= stones.length <= 30，1 <= stones[i] <= 1000，所以最大重量就是30 * 1000 。而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。当然也可以把石头遍历一遍，计算出石头总重量 然后除2，得到dp数组的大小。我这里就直接用15000了。
    
  - dp数组初始化:全部初始化为0

- 4. 确定遍历方向
    先遍历石头然后遍历背包容量，其中背包容量从大到小遍历。

- 5. 举例推导dp数组

    最后dp[target]里是容量为target的背包所能背的最大重量。

    那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。

    在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的。

    那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。

> **代码**

```java
class Solution {
    /**
        该题目为0-1背包问题，定义
            背包承重为sum / 2
            物品重量为stones[i],物品价值为stones[i]
            那么最终结果即位：
            sum - dp[target] - dp[target]
     */
    public int lastStoneWeightII(int[] stones) {

        int sum = 0;

        for(int i = 0;i < stones.length;i++){
            sum = sum + stones[i];
        }

        int target = sum / 2;

        int[] dp = new int[target + 1];

        for(int i = 0;i < stones.length;i++){
            for(int j = target;j >= stones[i];j--){
                dp[j] = Math.max(dp[j],dp[j - stones[i]]+ stones[i]);
            }
        }
        return sum - dp[target] - dp[target];
    }
}
```

> **复杂度分析**

- 时间复杂度:$O(n * sum)$
  
- 空间复杂度:$O{sum}$

# 四、打家劫舍

***

# 五、股票问题

***

# 六、子序列问题

***
