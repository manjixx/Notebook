## P21 Class，Sturct外部的static

static也是C++中令人头疼的一个关键字，这里主要需要将static分为两部分：

- Class，Sturct内部的static,意味着该变量实际上与类的所有实例共享内存，即该变量在类创建的所有实例中。静态变量只有一个实例，类中的静态方法也类似，没有实例会传递给该方法
- Class，Sturct外部的static, 类外面的static，意味着声明为static的符号，链接将只是在内部

> **Class，Sturct外部使用的Static关键字**

在Class和Sturct外部使用的Static关键字的意义为：该变量或函数只在对应的cpp或.h文件中可见，这里直接用例子来说明。

![](https://pic1.zhimg.com/80/v2-0426b7e4a76023e278505025e95659e8_1440w.webp)
![](https://pic2.zhimg.com/80/v2-c65785b1a4c7b09ea079beec7964a079_1440w.webp)

那此时我们为global_var加上static关键字来看一下实际的情况：

![](https://pic1.zhimg.com/80/v2-582c205b6963f60110dd53c1b668040c_1440w.webp)

我们此时发现有`LinkError`，`Math.obj`无法在找到对应的`global_var`，`global_var`只在`Log.cpp`内部才可见，对于函数也是同理。

![](https://pic3.zhimg.com/80/v2-10a029b931b93ae0259d5343009a1816_1440w.webp)

注意：在实际编程过程中我们**推荐尽可能地少用全局变量**，多使用static来局限变量、函数的可见性，但要注意在头文件中定义static变量函数命名问题，因为在Include头文件时就是把头文件的内容粘贴到指定cpp文件中，**要避免重复命名的问题**。

## P22 Class，Sturct内部的static

- static 在一个class中意味着特定的东西，如果static用于修饰变量，这意味在该类的所有实例中，该变量只有一个实例。
- 如果类的某一个实例修改了该变量，那么在所有实例中都会反映该修改。因此通过实例来引用变量是没有意义的,`Entity::x`
- 静态方法也一样无法访问类的实例，静态方法可以被调用，不需要通过类的实例，而在静态方法内部也无法引用类的实例。

在Class，Sturct内部使用static是为了使static修饰的变量只有一份，且使Class中的方法能被`ClassName::Method`直接使用，具体我们来看下以下的例子。

```cpp
class Log {
public:
    int x;
    int y;

    void print() {
        std::cout << x << "," << y << std::endl;
    }

};

int main() {
    Log log1;
    log1.x = 10;
    log1.y = 5;

    Log log2;
    log2.x = 7;
    log2.y = 8;

    log1.print();
    log2.print();

    return 0;
}
//显而易见，我们创建了两个Log的实例，log1，log2，并分别打印实例中的x,y数据
//结果为10,5 7,8
```

```cpp
class Log {
public:
    static int x;//加入static修饰
    static int y;//加入static修饰

    static void print() { //加入static修饰
        std::cout << x << "," << y << std::endl;
    }

};

int Log::x;//定义Class中的static变量（不然linker无法找到--unresolved external symbol）
int Log::y;//定义Class中的static变量（不然linker无法找到--unresolved external symbol）

int main() {
    Log log1;
    log1.x = 10;
    log1.y = 5;

    Log log2;
    log2.x = 7;
    log2.y = 8;

    log1.print();
    log2.print();
    //此时我们发现结果为7，8 7，8 Log class中所有的实例log1，log2 ...都共享了唯一的x,y
    
    //且现在不需要实例就可以使用函数print()
    Log::x = 7;
    Log::y = 8;
    Log::print();
    return 0;
}

/*注意：被static修饰的函数只可以调用static变量，这是因为static function无法访问到任意一个Class实例的数据，或者说他并不知道任意一个Class实例数据是多少。
因为对于一个none static的函数，它更倾向于是这样的
    void print(Log log) { 
        std::cout << log.x << "," << log.y << std::endl;
    }
*/
```

## P23 Local Static in C++

这一节讲述另一环境可能会找到static关键字：在一个局部作用域。

你可以在局部作用域中使用static来声明一个变量，这和前两种有所不同。这一种情况我们要考虑两个方面：

- 变量的生存期life time：生存期指的是变量实际存在的时间。
- 变量的作用域scope：作用域是指我们可以访问变量的范围。

静态局部（local static）变量允许我们声明一个变量，它的生存期基本相当于整个程序的生存期，然而它的作用范围被限制在这个作用域内。

类中的静态局部变量和函数中的静态局部变量二者区别在于：二者生存期一致，但作用域不同，类中的静态局部变量可以被类中的任何东西访问。

```cpp
#include <iostream>

using namespace std

void Function(){
    static int i = 0;
    i++;
    std::cout << i << std::endl;
}

int main(){
    Function();
    Function();
    Function();
    Function();
    
    cin.get();
}

// i 前没有static时，调用Function()五次之后，将会输出5个1
//  i 前有static时 cout 1,2,3,4
```

> **单例类**

单例类是只存在一个实例的类。

**不使用Local Static 创建单例类**

```cpp
#include<iostream>

class Singleton
{
private:
	static Singleton* s_Instance;
public:
	static Singleton& Get() { return *s_Instance; };

	void Hello() 
	{
		std::cout << "Hello" << std::endl;
	}
};

Singleton* Singleton::s_Instance = nullptr;

int main() 
{
	Singleton::Get().Hello();

	std::cin.get();
}

```

**使用局部静态创建单例类**

```cpp
class Singleton
{
public:
    static Singleton &get_instance()
    {
        static Singleton instance;
        return instance;
    }

private:
    Singleton() = default;
    ~Singleton() = default;
    Singleton(const Singleton &) = delete;
    Singleton(Singleton &&) = delete;
    Singleton &operator=(const Singleton &) = delete;
    Singleton &operator=(Singleton &&) = delete;
};
```

## P24 ENums in C++

ENUM是enumeration的缩写，它就是一个**数值集合**。

- 是一种命名方法，当我们想要**使用整数来表示某些状态或者某些数值时**，它非常有用
- 他能帮助我们将一组**数值集合作为类型**，而不仅仅是用整数型作为类型。

```cpp
enum Example{
    A,B,C   // 如果没有对枚举中的元素指定数值时，默认第一个元素是0，第二个是1，依次类推
}

/*
    枚举默认为32位整数，我们可以指定数据类型来改变枚举占用的内存
    不能改为float类型，因为float不是整数
*/
enum Example2 : unsigned char {
    A,B,C   
}

int main(){
    Example value = 5; // 此处会报错，因为value的取值必须是A，B，C中的一个
}
```

枚举是一种非常好用的类型，他最大的用处就是提高代码可读性，他的本质就是用一组变量代替Integer，这里就直接上之前Log的代码来说明。

```cpp
#include <iostream>

class Log {
public:
    enum LogType
    {
        //定义LogType的枚举类型
        LogType_Error = 0,
        LogType_Warning = 1,
        LogType_Info = 2,
    };
private:
    LogType m_LogLevel = LogType_Info;//定义Log级别
public:
    void SetLogLevel(LogType level) {//设置Log级别
        m_LogLevel = level;
    }
    void Error(const char* message) { //根据level输出Error级别Log
        if (m_LogLevel >= LogType_Error) {
            std::cout << "[ERROR]" << message << std::endl;
        }
    }
    void Warn(const char* message) { //根据level输出Warning级别Log
        if (m_LogLevel >= LogType_Warning) {
            std::cout << "[WARNING]" << message << std::endl;
        }
    }
    void Info(const char* message) { //根据level输出Info级别Log
        if (m_LogLevel >= LogType_Info) {
            std::cout << "[INFO]" << message << std::endl;
        }
    }
};

int main() {
    Log log;                                //创建新的log实例
    log.SetLogLevel(Log::LogType_Warning);  //设置等级为Warning
    log.Warn("Hello World");                //输出Warning log
    return 0;
}
//cout [WARNING]Hello World
```

## P25 Constructors in C++

构造函数基本上是一种特殊类型的方法，他在每次实例化对象时运行

构造函数（Constructors）的作用是用来初始化Class中变量的初始值，在C++中，变量默认的值并不会像其他语言（Java，C#）一样默认置0或者空，而是分配内存中的值是多少就是多少，我们可以创建可以非常简单的Class来看。

> **未进行初始化时**

```cpp
#include<iostream>


class Entity
{
public:

	float X, Y;

	void Print()
	{
		std::cout << X << Y << std::endl;
	}
};

int main() 
{

	Entity e;

	e.Print();  // 因为分配内存时，我们未进行初始化，此处输出为内存空间的原来的东西
    
    std::cout << e.X << std::endl;      // 此处输出会报错，未初始化局部变量

	std::cin.get();
}
```

> **加入一个Init函数来初始化x，y的值**

```cpp
/*
    这就是一个比较简单构造函数的思想,但是每次实例化一类时都需要调用Init()函数
*/
#include <iostream>

class Entity {
public:
    float x;
    float y;
    void Init(){
        x = 0.0f;
        y = 0.0f;
    }
    void Print() {
        std::cout << x << "," << y << std::endl;
    }
};

int main() {
    Entity e;
    e.Init();
    e.Print();
    return 0;
}
//cout 0,0  
```

> **使用构造函数**

那么我们实际的任意OOP（Object Oriented Programming）编程语言语法中，都存在构造函数的概念，**构造函数在class内部与class的名称同名，在Class被实例化时调用，支持重载（overload）的语法。**

```cpp
#include <iostream>

class Entity {
public:
    float x;
    float y;
    Entity() { //构造函数1（无参数）
        x = 0.0f;
        y = 0.0f;
    }
    Entity(float num1,float num2) {//构造函数2（两个参数）
        x = num1;
        y = num2;
    }
    void Print() {
        std::cout << x << "," << y << std::endl;
    }
};

int main() {
    //从e1，e2可以看到应用了不同的构造函数
    Entity e1;
    e1.Print();

    Entity e2(2, 3);
    e2.Print();

    return 0;
}
//cout 0,0
//     2,3
```

C++类提供默认的构造函数，当我们不需要构造函数时，可以使用如下语句删除。

```cpp
class Entity {
public:
  Entity() = delete;
}; 
```

## P26 Destructors

析构函数当一个Class的实例被销毁时执行，析构函数的主要作用是为了**释放某个Class实例申请的堆内存**

```cpp
#include<iostream>

class Entity
{
public:

	float X, Y;

	Entity()
	{
		X = 0.0f;
		Y = 0.0f;
	}

	Entity(float x, float y)
	{
		X = x;
		Y = y;
        std::cout << "Constructed Entity!" << std::endl;
	}

	~Entity()
	{
		std::cout << "Destroyed Entity!" << std::endl;
	}

	void Print()
	{
		std::cout << X << Y << std::endl;
	}
};

void useFunc()
{
	Entity e(1, 2);

	e.Print();
}

int main() 
{

	useFunc();

	std::cin.get();
}

/** cout
Constructed Entity!
1,2
Destroyed Entity!
**/
```

析构函数和构造函数在声明与定义时的唯一区别是：析构函数前面添加`~`

![](https://pic4.zhimg.com/80/v2-a9aca18809274cc06d3a2caebf255953_720w.webp)

![](https://pic2.zhimg.com/80/v2-34b780ebb71e732cd488da47f2b9cdc9_720w.webp)

注意：任意一个Class编译器均会为其生成默认的构造函数与析构函数，默认的构造函数与析构函数不执行任何操作，在一些实际工程中，我们可能会创建一些只使用static的class从而不需要构造函数，那可以这么写：

```cpp
#include <iostream>

class Entity {
public:
    Entity() = delete;

    static void Print() {
        std::cout << "static class!" << std::endl;
    }
};

int main() {
    //Entity e1; 此时无法创建实例，因为Entity class没有默认的构造函数
    Entity::Print();

    return 0;
}
```

## P27 Inheritance

Cherno在这一部分内容中主要是阐述了继承，虚函数，纯虚函数，函数的可见性在C++中的概念，其中涉及了许多面向对象编程的内容，为求甚解，这里将一次性把面向对象的三大特性（封装，继承，多态）以及C++虚函数的底层搞清楚。

> **面向对象的三大特性**

封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。
继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。
多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。

## P28 Virtual Functions

## P29 Interfaces (Pure Virtural Functions)

## P30 Visibility in C++

> **C++中的可见性**

| 可见性 |	可见范围  |
| ---    |  ---     |
| Private  | Class本身及他的友元函数（friend）|
| Protected |	Class本身，继承于该Class的子Class  |
| Public	| Class本身，继承于该Class的子Class，该Class所有在Class外的所有实例 |
 
> **英雄Class类的小设计**

当然我们需要一个例子来解释明白，这里就提出一个英雄系统的需求，这里我们就仿照moba游戏中的英雄来思考一下：

- 具备英雄名称，英雄背景，英雄等级
- 英雄具备三维属性（力量，智力，敏捷），且属性随等级成长
- 英雄具备三个小技能，一个终极技能
- 英雄的模型数据（坐标系，移动，动画等）
- 其他拓展（......）

当然实际的系统一定是更加复杂的，我们只是通过这样一小系统的需求来学习面向对象编程的一些概念。

首先我们设计一个Object基类用于表现所有游戏中的人形物体，我们认为这样的Object需要有动画和模型这两个方面，同时需要当前所处坐标系的横纵坐标X,Y，且我们将其中动画（Animate）和模型（Model）变量进行封装，通过Set方法进行变更，如下所示：

```cpp
class Object {
private:
    string Animate;
    string Model;
public:
    float X;//Object的横坐标X
    float Y;//Object的纵坐标Y
    Object(){//构造函数初始化坐标
        X = 0;
        Y = 0;
    }
    //设置动画
    void SetAnimate(string Anim) {
        Animate = Anim;
    }
    //设置模型
    void SetModel(string M) {
        Model = M;
    }
};
```

其次我们来定义一个英雄class的信息，其中包含英雄等级，英雄的三维属性（力量、智力、敏捷），同时我们需要定义英雄的移动，释放技能等，同时英雄class也具有基类Object的所有属性，因此继承自Object。

```cpp
class Hero : public Object {
private:
    int HeroLevel;    //英雄等级
    int Strength;     //力量
    int Inteligence;  //智力
    int Agile;        //敏捷
public:
    void SetAbility(int Str,int Int,int Agi) { //设置英雄的三维属性
        Strength = Str;
        Inteligence = Int;
        Agile = Agi;
    }

    void SetLevel(int Level) { //设置英雄的等级信息
        HeroLevel = Level;
    }

    virtual void Move(int xa, int ya) { //虚函数：英雄移动方法
        X += xa;
        Y += ya;
    }

    virtual void ReleaseSkill(int SkillId) = 0; //纯虚函数：英雄技能释放
};
```

那实际游戏中是有非常多的英雄的，他们可以继承自基础的英雄类，并拓展自己实际的技能，描述，名称，移动速度等，这里在基类Hero中我们需要重写Move方法，以及ReleaseSkill方法。这其中纯虚函数ReleaseSkill必须被重写，类似于其他语言的Interface，而Move方法若不进行重写则默认使用基类Hero中的Move方法。

```cpp
class Saber : public Hero {
private:
    string HeroName;        //英雄名称
    string HeroDescription; //英雄描述
    float HeroSpeed;        //英雄移速
public:
    enum HeroSkill {        //定义英雄技能
        Skill1,Skill2,Skill3,Skill4
    };
 
    void SetHeroName(string Name) {//设置英雄名称
        HeroName = Name;
    }

    void SetHeroDescription(string Description) {//设置英雄描述
        HeroDescription = Description;
    }
    
    void SetHeroSpeed(float Speed) {//设置英雄移速
        HeroSpeed = Speed;
    }

    void Move(int xa, int ya) override { //重写Move()将英雄移速加入
        X += xa * HeroSpeed;
        Y += ya * HeroSpeed;
    }

    void ReleaseSkill(int SkillId) override { //重写ReleaseSkill，根据技能Id释放技能
        if (SkillId == Skill1)
        {
            //Release Skill 1
        }else if (SkillId == Skill2)
        {
            //Release Skill 2
        }else if (SkillId == Skill3)
        {
            //Release Skill 3
        }else if (SkillId == Skill4)
        {
            //Release Skill 4
        }
    }
};
```

实际使用Class如下：

```cpp
int main(){
    Hero* SwordMaster = new Saber();
    SwordMaster.SetAnimate("SwordAnimate");
    SwordMaster.SetModel("SwordModel");
    SwordMaster.SetAbility(50,10,20);
    SwordMaster.SetLevel(15);
    SwordMaster.SetHeroName("剑圣");
    SwordMaster.SetDescription("剑刃风暴");
    SwordMaster.SetHeroSpeed(330);
    SwordMaster.Move(100,100);               //使用的是Saber Class的Move方法
    SwordMaster.ReleaseSkill(Saber::Skill1); //使用的是Saber Class的ReleaseSkill方法
}
```

> **虚函数的实现机制（额外拓展）**

- 虚函数的主要实现方式是通过虚函数表，以及vptr虚表指针完成的。
- 在编译阶段，Class的所有虚函数的地址将会保存到虚函数表中。虚函数表与Class（Hero，Saber）是一一对应的。
- 在对象实例化的阶段，虚表指针将被创建，该指针与对象（SwordMaster）是一一对应的。
- 我们在实际运用时，通过基类的指针指向派生类的对象---->得到了派生类的虚指针。
- 得到派生类的虚指针后找到派生类的虚函数表，在根据地址执行对应的虚函数。

这里的给出这部分概念是了解虚函数在底部的实现机制，以免产生模糊编译器是如何知道我该执行那个函数的，而实际使用虚函数的过程中或遇到许多问题：

- 构造函数，析构函数使用虚函数
- 菱形继承问题
- 性能问题
- 静态绑定与动态绑定

在使用面向对象特性时会出现许多相关问题，大家实际应用是遇到问题可以自行查阅解决方案，这里就不展开啦。
