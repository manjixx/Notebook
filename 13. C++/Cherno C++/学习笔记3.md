## P21 Static in C++，Static for Class and Struct in C++

static也是C++中令人头疼的一个关键字，这里主要需要将static分为两部分：Class，Sturct内部的static，Class，Sturct外部的static。

外部使用的Static关键字
在Class和Sturct外部使用的Static关键字的意义为：该变量或函数只在对应的cpp或.h文件中可见，这里直接用例子来说明。

![](https://pic1.zhimg.com/80/v2-0426b7e4a76023e278505025e95659e8_1440w.webp)
![](https://pic2.zhimg.com/80/v2-c65785b1a4c7b09ea079beec7964a079_1440w.webp)

那此时我们为global_var加上static关键字来看一下实际的情况：

![](https://pic1.zhimg.com/80/v2-582c205b6963f60110dd53c1b668040c_1440w.webp)

我们此时发现有LinkError，Math.obj无法在找到对应的global_var，global_var只在Log.cpp内部才可见，对于函数也是同理。

![](https://pic3.zhimg.com/80/v2-10a029b931b93ae0259d5343009a1816_1440w.webp)

注意：在实际编程过程中我们推荐尽可能地少用全局变量，多使用static来局限变量、函数的可见性，但要注意在头文件中定义static变量函数命名问题，因为在Include头文件时就是把头文件的内容粘贴到指定cpp文件中，要避免重复命名的问题。

## P22 Class，Sturct内部的static

在Class，Sturct内部使用static是为了是static修饰的变量只有一份，且使Class中的方法能被ClassName::Method直接使用，具体我们来看下以下的例子。

```cpp
class Log {
public:
    int x;
    int y;

    void print() {
        std::cout << x << "," << y << std::endl;
    }

};

int main() {
    Log log1;
    log1.x = 10;
    log1.y = 5;

    Log log2;
    log2.x = 7;
    log2.y = 8;

    log1.print();
    log2.print();

    return 0;
}
//显而易见，我们创建了两个Log的实例，log1，log2，并分别打印实例中的x,y数据
//结果为10,5 7,8
class Log {
public:
    static int x;//加入static修饰
    static int y;//加入static修饰

    static void print() { //加入static修饰
        std::cout << x << "," << y << std::endl;
    }

};

int Log::x;//定义Class中的static变量（不然linker无法找到--unresolved external symbol）
int Log::y;//定义Class中的static变量（不然linker无法找到--unresolved external symbol）

int main() {
    Log log1;
    log1.x = 10;
    log1.y = 5;

    Log log2;
    log2.x = 7;
    log2.y = 8;

    log1.print();
    log2.print();
    //此时我们发现结果为7，8 7，8 Log class中所有的实例log1，log2 ...都共享了唯一的x,y
    //且现在不需要实例就可以使用函数print()
    //Log::x = 7;
    //Log::y = 8;
    //Log::print();
    return 0;
}

/*注意：被static修饰的函数只可以调用static变量，这是因为static function无法访问到任意一个Class实例的数据，或者说他并不知道任意一个Class实例数据是多少。
因为对于一个none static的函数，它更倾向于是这样的
    void print(Log log) { 
        std::cout << log.x << "," << log.y << std::endl;
    }
*/
```

## P23 Local Static in C++

这一节讲述另一环境可能会找到static关键字：在一个局部作用域。

你可以在局部作用域中使用static来声明一个变量，这和前两种有所不同。这一种情况我们要考虑变量的生存期life time和变量的作用域scope。

生存期指的是变量实际存在的时间，而变量的作用域是指我们可以访问变量的范围。

静态局部（local static）变量允许我们声明一个变量，它的生存期基本相当于整个程序的生存期，然而它的作用范围被限制在这个作用域内。

```cpp
#include <iostream>

using namespace std

void Function(){
    static int i = 0;
    i++;
    std::cout << i << std::endl;
}

int main(){
    Function();
    Function();
    Function();
    Function();
    
    cin.get();
}

// cout 1,2,3,4
```

> **另一个作用是单例**

```cpp
class Singleton
{
public:
    static Singleton &get_instance()
    {
        static Singleton instance;
        return instance;
    }

private:
    Singleton() = default;
    ~Singleton() = default;
    Singleton(const Singleton &) = delete;
    Singleton(Singleton &&) = delete;
    Singleton &operator=(const Singleton &) = delete;
    Singleton &operator=(Singleton &&) = delete;
};
```

## P24 ENums in C++

枚举是一种非常好用的类型，他最大的用处就是提高代码可读性，他的本质就是用一组变量代替Integer，这里就直接上之前Log的代码来说明。

```cpp
#include <iostream>

class Log {
public:
    enum LogType
    {
        //定义LogType的枚举类型
        LogType_Error = 0,
        LogType_Warning = 1,
        LogType_Info = 2,
    };
private:
    LogType m_LogLevel = LogType_Info;//定义Log级别
public:
    void SetLogLevel(LogType level) {//设置Log级别
        m_LogLevel = level;
    }
    void Error(const char* message) { //根据level输出Error级别Log
        if (m_LogLevel >= LogType_Error) {
            std::cout << "[ERROR]" << message << std::endl;
        }
    }
    void Warn(const char* message) { //根据level输出Warning级别Log
        if (m_LogLevel >= LogType_Warning) {
            std::cout << "[WARNING]" << message << std::endl;
        }
    }
    void Info(const char* message) { //根据level输出Info级别Log
        if (m_LogLevel >= LogType_Info) {
            std::cout << "[INFO]" << message << std::endl;
        }
    }
};

int main() {
    Log log;                              //创建新的log实例
    log.SetLogLevel(Log::LogType_Warning); //设置等级为Warning
    log.Warn("Hello World");              //输出Warning log
    return 0;
}
//cout [WARNING]Hello World
```

## P25 Constructors in C++

构造函数（Constructors）的作用是用来初始化Class中变量的初始值，在C++中，变量默认的值并不会像其他语言（Java，C#）一样默认置0或者空，而是分配内存中的值是多少就是多少，我们可以创建可以非常简单的Class来看。


那么我们考虑是否需要加入一个Init函数来初始化x，y的值，因此我们可以这么写：

```cpp
#include <iostream>
​
class Entity {
public:
    float x;
    float y;
    void Init(){
        x = 0.0f;
        y = 0.0f;
    }
    void Print() {
        std::cout << x << "," << y << std::endl;
    }
};
​
​
int main() {
    Entity e;
    e.Init();
    e.Print();
    return 0;
}
//cout 0,0  这就是一个比较简单构造函数的思想
```

那么我们实际的任意OOP（Object Oriented Programming）编程语言语法中，都存在构造函数的概念，构造函数在class内部与class的名称同名，在Class被实例化时调用，支持重载（overload）的语法。

```cpp
#include <iostream>

class Entity {
public:
    float x;
    float y;
    Entity() { //构造函数1（无参数）
        x = 0.0f;
        y = 0.0f;
    }
    Entity(float num1,float num2) {//构造函数2（两个参数）
        x = num1;
        y = num2;
    }
    void Print() {
        std::cout << x << "," << y << std::endl;
    }
};

int main() {
    //从e1，e2可以看到应用了不同的构造函数
    Entity e1;
    e1.Print();

    Entity e2(2, 3);
    e2.Print();

    return 0;
}
//cout 0,0
//     2,3
```

## P26 Destructors

析构函数当一个Class的实例被销毁时执行，析构函数的主要作用是为了释放某个Class实例申请的堆内存

![](https://pic4.zhimg.com/80/v2-a9aca18809274cc06d3a2caebf255953_720w.webp)

![](https://pic2.zhimg.com/80/v2-34b780ebb71e732cd488da47f2b9cdc9_720w.webp)

注意：任意一个Class编译器均会为其生成默认的构造函数与析构函数，默认的构造函数与析构函数不执行任何操作，在一些实际工程中，我们可能会创建一些只使用static的class从而不需要构造函数，那可以这么写：

```cpp
#include <iostream>

class Entity {
public:
    Entity() = delete;

    static void Print() {
        std::cout << "static class!" << std::endl;
    }
};


int main() {
    //Entity e1; 此时无法创建实例，因为Entity class没有默认的构造函数
    Entity::Print();

    return 0;
}
```

## P27 Inheritance

Cherno在这一部分内容中主要是阐述了继承，虚函数，纯虚函数，函数的可见性在C++中的概念，其中涉及了许多面向对象编程的内容，为求甚解，这里将一次性把面向对象的三大特性（封装，继承，多态）以及C++虚函数的底层搞清楚。

> **面向对象的三大特性**

封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。
继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。
多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。

## P28 Virtual Functions

## P29 Interfaces (Pure Virtural Functions)

## P30 Visibility in C++

> **C++中的可见性**

| 可见性 |	可见范围  |
| ---    |  ---     |
| Private  | Class本身及他的友元函数（friend）|
| Protected |	Class本身，继承于该Class的子Class  |
| Public	| Class本身，继承于该Class的子Class，该Class所有在Class外的所有实例 |
 
> **英雄Class类的小设计**

当然我们需要一个例子来解释明白，这里就提出一个英雄系统的需求，这里我们就仿照moba游戏中的英雄来思考一下：

- 具备英雄名称，英雄背景，英雄等级
- 英雄具备三维属性（力量，智力，敏捷），且属性随等级成长
- 英雄具备三个小技能，一个终极技能
- 英雄的模型数据（坐标系，移动，动画等）
- 其他拓展（......）

当然实际的系统一定是更加复杂的，我们只是通过这样一小系统的需求来学习面向对象编程的一些概念。

首先我们设计一个Object基类用于表现所有游戏中的人形物体，我们认为这样的Object需要有动画和模型这两个方面，同时需要当前所处坐标系的横纵坐标X,Y，且我们将其中动画（Animate）和模型（Model）变量进行封装，通过Set方法进行变更，如下所示：

```cpp
class Object {
private:
    string Animate;
    string Model;
public:
    float X;//Object的横坐标X
    float Y;//Object的纵坐标Y
    Object(){//构造函数初始化坐标
        X = 0;
        Y = 0;
    }
    //设置动画
    void SetAnimate(string Anim) {
        Animate = Anim;
    }
    //设置模型
    void SetModel(string M) {
        Model = M;
    }
};
```

其次我们来定义一个英雄class的信息，其中包含英雄等级，英雄的三维属性（力量、智力、敏捷），同时我们需要定义英雄的移动，释放技能等，同时英雄class也具有基类Object的所有属性，因此继承自Object。

```cpp
class Hero : public Object {
private:
    int HeroLevel;    //英雄等级
    int Strength;     //力量
    int Inteligence;  //智力
    int Agile;        //敏捷
public:
    void SetAbility(int Str,int Int,int Agi) { //设置英雄的三维属性
        Strength = Str;
        Inteligence = Int;
        Agile = Agi;
    }

    void SetLevel(int Level) { //设置英雄的等级信息
        HeroLevel = Level;
    }

    virtual void Move(int xa, int ya) { //虚函数：英雄移动方法
        X += xa;
        Y += ya;
    }

    virtual void ReleaseSkill(int SkillId) = 0; //纯虚函数：英雄技能释放
};
```

那实际游戏中是有非常多的英雄的，他们可以继承自基础的英雄类，并拓展自己实际的技能，描述，名称，移动速度等，这里在基类Hero中我们需要重写Move方法，以及ReleaseSkill方法。这其中纯虚函数ReleaseSkill必须被重写，类似于其他语言的Interface，而Move方法若不进行重写则默认使用基类Hero中的Move方法。

```cpp
class Saber : public Hero {
private:
    string HeroName;        //英雄名称
    string HeroDescription; //英雄描述
    float HeroSpeed;        //英雄移速
public:
    enum HeroSkill {        //定义英雄技能
        Skill1,Skill2,Skill3,Skill4
    };
 
    void SetHeroName(string Name) {//设置英雄名称
        HeroName = Name;
    }

    void SetHeroDescription(string Description) {//设置英雄描述
        HeroDescription = Description;
    }
    
    void SetHeroSpeed(float Speed) {//设置英雄移速
        HeroSpeed = Speed;
    }

    void Move(int xa, int ya) override { //重写Move()将英雄移速加入
        X += xa * HeroSpeed;
        Y += ya * HeroSpeed;
    }

    void ReleaseSkill(int SkillId) override { //重写ReleaseSkill，根据技能Id释放技能
        if (SkillId == Skill1)
        {
            //Release Skill 1
        }else if (SkillId == Skill2)
        {
            //Release Skill 2
        }else if (SkillId == Skill3)
        {
            //Release Skill 3
        }else if (SkillId == Skill4)
        {
            //Release Skill 4
        }
    }
};
```

实际使用Class如下：

```cpp
int main(){
    Hero* SwordMaster = new Saber();
    SwordMaster.SetAnimate("SwordAnimate");
    SwordMaster.SetModel("SwordModel");
    SwordMaster.SetAbility(50,10,20);
    SwordMaster.SetLevel(15);
    SwordMaster.SetHeroName("剑圣");
    SwordMaster.SetDescription("剑刃风暴");
    SwordMaster.SetHeroSpeed(330);
    SwordMaster.Move(100,100);               //使用的是Saber Class的Move方法
    SwordMaster.ReleaseSkill(Saber::Skill1); //使用的是Saber Class的ReleaseSkill方法
}
```

> **虚函数的实现机制（额外拓展）**

- 虚函数的主要实现方式是通过虚函数表，以及vptr虚表指针完成的。
- 在编译阶段，Class的所有虚函数的地址将会保存到虚函数表中。虚函数表与Class（Hero，Saber）是一一对应的。
- 在对象实例化的阶段，虚表指针将被创建，该指针与对象（SwordMaster）是一一对应的。
- 我们在实际运用时，通过基类的指针指向派生类的对象---->得到了派生类的虚指针。
- 得到派生类的虚指针后找到派生类的虚函数表，在根据地址执行对应的虚函数。

这里的给出这部分概念是了解虚函数在底部的实现机制，以免产生模糊编译器是如何知道我该执行那个函数的，而实际使用虚函数的过程中或遇到许多问题：

- 构造函数，析构函数使用虚函数
- 菱形继承问题
- 性能问题
- 静态绑定与动态绑定

在使用面向对象特性时会出现许多相关问题，大家实际应用是遇到问题可以自行查阅解决方案，这里就不展开啦。
