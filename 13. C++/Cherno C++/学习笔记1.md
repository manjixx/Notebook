# 学习笔记 1

## How C++ Works

```c
//Preprocessor Statements
#include<iostream> // 在程序编译前进行，hf相当于拷贝了iostream文件到该Cpp文件下
​
/*Entry Point(Program start from main function)
  main函数是一个特殊的函数，返回类型为int，只有main函数当没有return时，默认返回0
*/ 
int main(){
    // << 是C++操作符重载，cout<< 可以理解为 cout.print()
    std::cout << "Hello World" << std::endl;
    std::cin.get(); // 程序暂停，直到按下enter
}
```

> **VS在对C++进行编译运行时的两个重要参数**

![](https://picx.zhimg.com/v2-e001845daa84fba57c2f8a3f82b41a59_720w.png?source=d16d100b)

- Solution Configuration：编译设置，构建项目时的一系列规则，往往可以进行自定义，在默认给的Debug和Release两种编译设置中，最大的区别就是对代码的优化不同，Debug模式默认关闭代码优化，因此Debug模式要慢很多。
- Solution Platform：往往会是X86-->Win32，X64-->Win64，往往对应操作系统与各类硬件平台
- 更改方式：project右键- properties  

> **C++ 可执行exe文件的简单生成过程**

只有Cpp文件参与Compile，Include的头文件不参与Compile，他们只是把文件内容拷贝到Cpp文件内，最终还是Cpp文件在进行编译，因而简易的编译过程如下所示。

![](https://pic3.zhimg.com/80/v2-e4c4c3072d7773621b0c0caf55c6918a_1440w.webp)

（注：不要依赖VSerro-list报错，他们只是把Output中真实报错做了OverView，更多学会在Compile，Build过程中看Output纠错）

> **C++中典型的两种Error类型**

- Compile Error：往往发生在单独一个的Cpp文件中（例：HelloWorld.cpp第九行缺少;）

![](https://pic1.zhimg.com/v2-d5220e03e24c47b6190722c6a6f53635_720w.png?source=d16d100b)

- Linker Error：多个Cpp、Obj文件之间的问题（HelloWorld.obj找不到Log函数的定义）

![](https://pic1.zhimg.com/v2-e25b6be24e437e342884f7b3cb27a641_720w.png?source=d16d100b)

> **声明与定义**

- 声明：这个符号、这个函数是存在的。
- 定义：这个函数到底是什么。

## How C++ Compiler Works

 compiler的工作将txt文件转换为目标文件的中间文件。

> **Pre-processing（预处理）**

几种常见的Pre-processing Statement（预处理声明）

- #define

```c++
//Math.cpp(cpp文件)
#define INTEGER int
//在预编译后实际文件其实就是把INTEGER替换为int
INTEGER Add(int a, int b) {
 INTEGER result = a + b;
 return result;
}

//Math.i（预编译文件）
#line 1 "D:\\GameDevelopmentLearning\\GameDevelopmentLearning\\GameDevelopmentLearning\\Math.cpp"
//可以看到与编译后，INTEGER被替换为了int
int Add(int a, int b) {
 int result = a + b;
 return result;
}

```

- #if

```c++
//Math.cpp(cpp文件)
#if 0
//在预编译后实际文件根据if条件判断是否需要使用这一部分代码
int Add(int a, int b) {
 int result = a + b;
 return result;
}
#endif
//Math.i（预编译文件）
//可以看到if 0 条件下这一段代码就未被编译器使用
#line 1 "D:\\GameDevelopmentLearning\\GameDevelopmentLearning\\GameDevelopmentLearning\\Math.cpp"
​
#line 8 "D:\\GameDevelopmentLearning\\GameDevelopmentLearning\\GameDevelopmentLearning\\Math.cpp"
```

- #include

```c++
//Math.cpp(cpp文件)
#include "Math.h"
//include的作用就是把include的文件全部复制到当前cpp文件内
int Add(int a, int b) {
 int result = a + b;
 return result;
}

//Math.h(header文件)
int Add(int a, int b);

//Math.i（预编译文件）
//可以看到Math.h文件被复制到了cpp文件内，工程中非常典型的写法，既有函数声明（declaration），也有函数定义（definition）
#line 1 "D:\\GameDevelopmentLearning\\GameDevelopmentLearning\\GameDevelopmentLearning\\Math.cpp"
#line 1 "D:\\GameDevelopmentLearning\\GameDevelopmentLearning\\GameDevelopmentLearning\\Math.h"
int Add(int a, int b);
#line 2 "D:\\GameDevelopmentLearning\\GameDevelopmentLearning\\GameDevelopmentLearning\\Math.cpp"
​
int Add(int a, int b) {
 int result = a + b;
 return result;
}
```

> **Compiling（编译）**

编译就是将cpp文件转换为obj文件，也就是代码转换为机器码，如果打开obj来看可以看到均是16进制的字符串

![](https://pic4.zhimg.com/80/v2-633920f4cec916c5c7c803754122c153_1440w.webp)

为了更加直观的来看实际机器码做了什么，其实从cpp到机器码中间还有一个asm文件我们可以从汇编代码中看到最终的机器码的执行是什么样的。

```asm
; Line 4 //对应 int result = a + b
    mov eax, DWORD PTR _a$[ebp]       
    add eax, DWORD PTR _b$[ebp]
    mov DWORD PTR _result$[ebp], eax
; Line 5 //对应 return result
    mov eax, DWORD PTR _result$[ebp]
```

>  

在实际需要发布的工程中我们需要将代码编译进行优化，VS的配置如下所示：

![](https://pic2.zhimg.com/80/v2-f61b2eb93964b464f82ca4c459757c99_1440w.webp)

![](https://pic1.zhimg.com/80/v2-23c923d522536d5b2c803531f910eb94_1440w.webp)

```asm
; Line 3
    push    ebp
    mov ebp, esp
    mov ecx, OFFSET __2452CD90_Math@cpp
    call    @__CheckForDebuggerJustMyCode@4
    mov eax, DWORD PTR _a$[ebp]
    add eax, DWORD PTR _b$[ebp] //并没有line4 相当于代码直接被优化为return a+b;
; Line 6
    pop ebp
    ret 0
```

当通过代码优化的情况下，我们是无法debug到result这个变量的数值的，这也解释了许多发布项目中经过代码优化后无法Debug到一些变量的原因，同理一些未用到的函数方法在编译时也会省略掉。

```cpp
//Math.cpp
int Add(int a, int b) {
    return 2*5;
}
//Math.asm
mov eax, 10             ; 0000000aH    //常量折叠，直接计算得到10，而不会在分拆成两个常量进行计算
```

## How C++ Linker Works

Linking（链接）

链接的主要目的是将每一个独立的obj文件联系起来将其组成一个可执行的exe文件

```cpp
//Math.cpp
const char* Log(const char* message) {
    return message;
}
​
int Add(int a, int b) {
    Log("Add");
    return a + b;
}
```

- 1. Math.cpp可以被正确编译
- 2. 该工程无非被正确build，会出现Link Error，缺少Entry point 
- 3. Entry point往往是main(),但并不绝对，在VS的Linker->Advanced设置中可以设置Entry point
- 4. 为了保证Linking正确，任何工程必须有一个Entrypoint

常见的Linking Error（链接错误）

- 函数未定义（参数不一致也算）

```cpp 
#include <iostream>
//只有函数声明但并未对Log定义或实现，其实会出现unresolved external symbol char* log ....
const char* Log(const char* message); 
​
int Add(int a, int b) {
 Log("Add");
 return a + b;
}
​
int main() {
 std::cout << Add(5, 5) << std::endl;
 std::cin.get();
}
```

- Math.cpp可以被正确编译
- 该工程无非被正确build，会出现Link Error，缺少对Log函数的定义 
- 当然我们通过注释调用Log函数的代码部分来解决Link Error  //Log("Add")但注释其余使用的部分并不会起到效果，比如`//std::cout << Add(5, 5) << std::endl; `因为链接器认为，代码可能会有其他部分调用Add函数，从而就会调用到Log函数，从而产生错误

- 函数重复定义（谨慎使用include）

```cpp
//Log.h
const char* Log(const char* message) {
 return message;
}
​
//Log.cpp
#include "Log.h"
void InitLog() {
 Log("Init");
}
​
//Math.cpp
#include <iostream>
#include "Log.h"
​
int Add(int a, int b) {
 Log("Add");
 return a + b;
}
​
int main() {
 std::cout << Add(5, 5) << std::endl;
 std::cin.get();
}
```

- 因为#include Log.h 就是将log头文件粘贴到Log.cpp及Math.cpp中，这就造成了Log函数的重复定义，链接器并不知道该调用哪个函数而造成Link error
- 解决方法1：将log函数改为static const char* Log(const char* message)，意思是我每一个Log函数只用于当前obj文件，链接器会为每一个Log函数生成独有的函数签名
- 解决方法2：将log函数改为inline const char* Log(const char* message)，函数内联后相当于将函数体直接粘贴至调用的区域，但考虑到复杂的函数无法内联，此方法并不一定能成功
  
- 比较正确常用的工程写法

```cpp
//Log.h 头文件中主要写函数声明
const char* Log(const char* message);
​
//Log.cpp 对应的cpp文件中进行函数定义与实现
#include "Log.h"
const char* Log(const char* message) {
 return message;
}
​
//Math.cpp 在其他类中引入头文件并进行调用
#include <iostream>
#include "Log.h"
​
int Add(int a, int b) {
 Log("Add");
 return a + b;
}
​
int main() {
 std::cout << Add(5, 5) << std::endl;
 std::cin.get();
}
```

