
## P31 Arrays in C++

> **数组的基本概念**

数组是实际编程过程中最常用的类型，简单点来理解就是把相同类型的变量组织在连续的内存空间中，并通过Index去访问，这里提到的都是Compile前定义好大小的静态数组，直接来看例子：

```cpp
int main() {
    //数组example本质上是一个指针，指向存储这5个int类型的内存地址
    int example1[5];             //在栈内存上申请空间并存储5个int类型变量
    int* example2 = new int[5];  //在堆内存上申请空间并存储5个int类型变量

    for (int i = 0; i < 5; i++)
    {
        example1[i] = 2;
    }

    for (int i = 0; i < 5; i++)
    {
        example2[i] = 2;
    }

    //这段代码就是数组赋值的实际操作，compiler通过指针找到对应的内存，并根据类型（int，char..）进行内存的偏移操作，在这里就是address:example1+2*4,并最后修改对应内存空间的值
    example1[2] = 10;     
    *(example1 + 2) = 15;

    delete[] example2; //申请的堆内存需要我们进行手动释放

    return 0;
}
```

根据实际情况的需要，我们可能需要在堆上申请空间，也可能只需要在栈上申请空间，当前的数组必须要给定确切的size。原生的C++数组，并不能使用类似其他语言的Array.size()方法，但对Compiler而言，是确实能得到数组空间的大小，因为在清理内存时是需要的。

> **C++ 11的Array**

在新的标准中，Array作为一种固定大小的序列容器，非常类似一般的数组，在栈内存上分配连续的内存来储存元素，大小固定不可改变。

```cpp
#include <iostream>
#include <array>

int main() {
    std::array<int,5> example = {1,2,3,4,5};
    //具备使用.size(),.fill(),.swap()等方法
    //同时也可以使用迭代器，因为array已经是一种序列容器了
    for (int i = 0;i < example.size(); i++)  
    {
        std::cout << example[i] << std::endl;
    }
    return 0;
}
//cout 1,2,3,4,5
```

## P32 How String Work in C++（and how to use them）

> **普通的const char**

为了搞清楚String字符串的概念，我们首先得弄懂什么是Char字符，在C++中Char占据一个字节（8位，256种数字）的内存，采用ASCII编码（178种编码，分别代表数字、符号、字母等，具体可自行参照ASCII码表），这在之前的笔记中有所提及。字符串就是字符的集合，也可以说字符数组就是字符串，在此之上再加入一些限制我们就可以当作string来使用，我们先看一下最普通的字符串构建方式（const char*）：

![](https://pic4.zhimg.com/80/v2-42858e8fa82ebe4692c418236aa89d37_720w.webp)

我们可以看到H，e，l，l，o对应的ASCII码，且最后以00结束，字符串以const char*指针的内存地址为string的开始地址，以之后的第一个"0"为结束地址，从而得出了字符“Hello”，字符串的基本逻辑就是这样。

> **不要尝试修改const char* 中的内容**

```cpp
#include <iostream>

int main() {
    const char* name1 = "Hello";
    //name1[2] = 'a'; 不可改动，我们通过asm文件可以看到name1被存储在内存的常量区中
    char name2[] = "Hello";
    name2[2] = 'a';
    //虽然通过char[]可以改动，但他的本质是将Hello从常量区读取出来，创建一个新的name2，并改变name2的值，最后显示，这是一种非常耗费性能和内存的方案，不推荐
}
//Main.asm部分片段
.....
CONST   SEGMENT
??_C@_05COLMCDPH@Hello@ DB 'Hello', 00H         ; `string' //可以看到字符串被存储在常量区
CONST   ENDS
.....
; Line 6 //对应name2[2] = 'a'
    mov eax, DWORD PTR ??_C@_05COLMCDPH@Hello@
    mov DWORD PTR _name2$[ebp], eax
    mov cx, WORD PTR ??_C@_05COLMCDPH@Hello@+4
    mov WORD PTR _name2$[ebp+4], cx
```

> **标准库中的std::string**

之后我们来看现在使用较多的`std::string`，他的本质其实还是构造了一个`const char*`，但是他具备许多模板（templates），同时他支持了字符串很多方法，并且在底层进行了各类重载，使得字符串的使用更为方便。

```cpp
#include <iostream>
#include <string>
​
int main() {
    std::string c = "Hello";
    std::cout << c.size() << std::endl;     //得到字符串的长度5
    std::cout << c.find("He") << std::endl; //返回找到的字符的第一个位置0
    c += "World";                           //重载了+=操作符，可以进行append string
    std::cout << c << std::endl;            //cout: Hello World!
    return 0;
}
/*具体的实现如果有兴趣可以自行查看.../include/xstring 里面便是std对字符串的底层实现*/
```

> **传递string**

当向任意一个函数传递string时，我们更倾向于使用常量引用来进行传值，具体原因如下：

```cpp
#include <iostream>
#include <string>

void PrintString_A(std::string s) {
    //std::string NewString = s; 这种做法相当于新开辟一块栈空间，并将s中的内容复制到NewString所在内存空间中
    std::cout << s << std::endl;
}

void PrintString_B(const std::string& s) {
    //直接引用了main中创建的s，并不额外开辟栈空间
    std::cout << s << std::endl;
}

int main() {
    std::string s = "Hello World!";
    PrintString_A(s);
    PrintString_B(s);
    return 0;
}
```

## P33 String Literals in C++

String Literals的本质是用于支持不同编码条件下的String

```cpp
#include <iostream>
#include <string>

int main() {
    const char* name1 = u8"Hello";   //utf-8 string literal 单字符（1个字节）
    const wchar_t* name2 = L"Hello"; //wide string literal  单字符（2个字节）
    const char16_t* name3 = u"Hello";//utf-16 string literal  单字符（2个字节）
    const char32_t* name4 = U"Hello";//utf-32 string literal  单字符（4个字节）
    const char* name5 = R"Hello\nWorld";  //R可以忽略所有转义字符（cout:Hello\0World）
    return 0;
}
```

## P34 CONST in C++

const首先作用于左边的东西；如果左边没东西，就做用于右边的东西

const被cherno称为伪关键字，因为它在改变生成代码方面做不了什么。有点像类和结构体的可见性。关键是，这是一个承诺，承诺一些东西是不变的，你是否遵守诺言取决于你自己。我们要保持const是因为这个承诺实际上可以简化很多代码。

并且常对象只能调用常函数，比如这样写就会报错：

![](https://img-blog.csdnimg.cn/f14be61ba073457c909290f0a7d01a85.png)

正确方法是GetX方法类在后面加const（只有类才有这样的写法）：

![](https://img-blog.csdnimg.cn/7d8b1a4a2e6d49b8a6a26b7e923a92aa.png)

然后有时我们就会写两个GetX版本，一个有const一个没有，然后下面这个传const+引用的方法就会调用const的GetX版本。

记住，总是标记你的方法为const，如果它们实际上没有修改类或者它们不应该修改类。否则在有常量引用或类似的情况下就用不了你的方法。

而如果要修改别的变量，可以用关键字mutable：

![](https://img-blog.csdnimg.cn/922390324be44fcd90840effe3d10eb1.png)

tips：


```CPP
int* x, *y; // 如果要同行的都是指针
int* x, y;  // y只是一个int型变量，非指针。
```

## P35 The Mutable Keyword in C++

mutable实际上有两种不同的用途：

- 与const一起用，如34讲
- lambda表达式，或者同时覆盖两种方法

> **lambda表达式**

第一种在34中已经讲过了，也是最主要的用法，下面来看第二种：

![](https://img-blog.csdnimg.cn/a1fdf286845842ebb382807eeaa3a3e3.png)

我们想值传递，但是却不可以++，正确写法是：

```cpp
#include <iostream>

int main()
{
	int x = 8;
	auto f = [=]()
	{
		int y = x;
		y++;
		std::cout << y << std::endl;
	};

	f();

	std::cin.get();
}
```

但是这样写很繁琐，就出现mutable关键字了，本质是一样的：

```cpp
#include <iostream>

int main()
{
	int x = 8;
	auto f = [=]() mutable
	{
		x++;
		std::cout << x << std::endl;
	};

	f();

	std::cin.get();
}
```

## P36 C++的成员列表初始化

有一件要注意的事情：在成员初始化列表里需要按顺序写。这很重要，因为不管你怎么写初始化列表，它都会按照定义类的顺序进行初始化。

![](https://img-blog.csdnimg.cn/2614d04355fd41248601c7e5926de06e.png)

比如上图在class Entity中先定义m_Score，再是m_Name，所以成员初始化列表也要按照这个顺序执行。如果打破这个顺序就会导致各种各样的依赖性问题。所以你要确保你做成员初始化列表时，要与成员变量声明时的顺序一致。

这个列表顺序可以随意，只不过有些编译器会警告，因为你不管怎么调换初始化顺序，编译器都会按照成员声明的时候的顺序进行初始化，所以就可能有个初始化先后顺序问题，导致某些依赖问题。

使用成员初始化列表，除了直观好看外，还有一个好处就是避开了一层性能浪费。如果是直接在构造函数中赋值，实际上的过程是先构造，之后再赋值。即以上图为例，二者区别是：
成员初始化列表：

```cpp
std::string m_Name("Unknow");
```

构造函数内赋值：

```cpp
std::string m_Name;
m_Name = std::string("Unknow");
```

前者效率高一些，因为只调用了一次构造函数，而后者有两次构造函数加拷贝赋值。

因此能使用成员初始化列表就一定要使用。


## P37 C++的三元操作符

实际上只是if的语法糖。

## P38 创建并初始化C++对象

一般栈的效率高，但是栈通常非常小，通常是1兆2兆，这取决于你的平台和编译器。因此有时候可能由于空间大小我们会在堆分配内存。

因此C++中我们有两种选择方式：

```cpp
// 栈中
Entity entity("hbh");

// 堆中
Entity* entity = new Entity("hbh");
```

在C#中有一种叫做struct的东西，它是基于值的类型，他们实际上是在栈上分配的，即使你用了new关键字；但是在Java中所有东西都在堆上。C#中所有的类都是在堆上分配的。

cherno看到的一个最大的问题，就是每个来自Java或C#的托管语言的人，都会在C++中到处使用new关键字。简单来说就是性能问题，在堆上分配要比栈花费更长的时间，而且在堆上分配的话，你必须手动释放被分配的内存。

最后，如果对象太大，或是需要显示地控制对象的生存期，那就用堆上创建；否则就栈上分配吧，栈上创建简单多了，也更快。

## P39 C++ new 关键字

如果你来自Java或C#这样的托管语言，内存会自动清理。但在内存方面，你也没有那么多控制能力。

C++中，new一个对象，除了在堆中分配内存外，它还调用构造函数。
（当然也可以直接 int* b = new int; 但这不是new一个对象了）

new 是一个操作符，就像加、减、等于一样。它是一个操作符，这意味着你可以重载这个操作符，并改变它的行为。

通常调用new会调用隐藏在里面的C函数malloc，但是malloc仅仅只是分配内存然后给我们一个指向那个内存的指针，而new还会调用构造函数。同样，delete则会调用destructor析构函数。

当我们使用new时，内存未释放，它没有被标记为释放，它不会被放回空闲列表，所以就不能再被new调用后再分配，直到我们调用delete，我们必须手动操作。

很多C++的策略可以让这个过程自动化，比如基于作用域的指针。也有一些高级策略比如引用计数。

```cpp
int* a = new int;
int* b = new int[50];

delete a;
delete[] b;
```

所谓的placement new，这就是要决定前面的内存来自哪里，所以你并没有真正的分配内存。在这种情况下，你只需要调用构造函数，并在一个特定的内存地址中初始化你的Entity，可以通过些new()然后指定内存地址，比如

```cpp
int* b = new int[50]; 
Entity* entity = new(b) Entity();
```

## P40 C++ 隐式转换与 explicit 关键字

```cpp
#include <iostream>

class Entity
{
private:
	std::string m_Name;
	int m_Age;
public:
	Entity(const std::string& name)
		: m_Name(name), m_Age(-1) {}

	Entity(int age)
		: m_Name("Unknown"), m_Age(age) {}
};

int main()
{
	Entity test1("hbh");
	Entity test2(21);
	Entity test3 = std::string("hbh");
	Entity test4 = 21;

	std::cin.get();
}
```

如上，在test4中，int型的21就被隐式转换为一个Entity对象。同时我们也能看到，对于语句
Entity test3 = "hbh"; 会报错，原因是只能进行一次隐式转换，hbh是const char数组，这里需要先转换为std::string，再从string转换为Entity变量，两次隐式转换是不行的，所以会报错。因此这里我写为了Entity test3 = std::string("hbh");

从cherno个人来说，他不会写Entity test4 = 21;这样的函数，他会尽量避免隐式转换。因为他觉得Entity test2(21);更清晰。

并且若构造函数写为explicit就会禁用这种隐式转换：

![](https://img-blog.csdnimg.cn/579aac743deb421188ff59901d73c703.png)

相应的更改方法可以写为：`Entity test4 = (Entity)21;`













