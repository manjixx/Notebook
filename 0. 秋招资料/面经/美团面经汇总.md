# 一、 操作系统

### 进程和线程解释一下，什么区别?

进程是资源分配的最小单位，线程是运行的最小单位


### 进程间通信方式

匿名管道、命名管道、信号、消息队列、共享内存、信号量、套接字

### 进程调度算法

先来先服务算法
短作业优先算法
时间片轮转算法
优先级队列
多级反馈队列

### 死锁产生的必要条件

- 互斥
- 占有等待
- 非抢占
- 循环等待

### linux的指令了解吗？ 查看日志文件用什么命令？

> **目录切换命令**

- cd usr： 切换到该目录下 usr 目录
- cd ..（或cd../）： 切换到上一层目录
- cd /： 切换到系统根目录
- cd ~： 切换到用户主目录
- cd -： 切换到上一个操作所在目录


> **目录的操作命令(增删改查)**

- mkdir 目录名称： 增加目录。
- ls/ll（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息。
- find 目录 参数： 寻找目录（查）。示例：① 列出当前目录及子目录下所有文件和文件夹: find .；② 在/home目录下查找以.txt 结尾的文件名:find /home -name "*.txt" ,忽略大小写: find /home -iname "*.txt" ；③ 当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件:find . \( -name "*.txt" -o -name "*.pdf" \)或find . -name "*.txt" -o -name "*.pdf"。
- mv 目录名称 新目录名称： 修改目录的名称（改）。注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。
mv 目录名称 目录的新位置： 移动目录的位置---剪切（改）。注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。
- cp -r 目录名称 目录拷贝的目标位置： 拷贝目录（改），-r 代表递归拷贝 。注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r 递归。
- rm [-rf] 目录 : 删除目录（删）。注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用rm -rf 目录/文件/压缩包。

> **文件操作命令(增删改查)**

- touch 文件名称: 文件的创建（增）。
- cat/more/less/tail 文件名称 ：文件的查看（查） 。命令 tail -f 文件 可以对某个文件进行动态监控，例如 tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 tail -f catalina-2016-11-11.log 监控 文 件的变化 。
- vim 文件： 修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤： vim 文件------>进入文件----->命令模式------>按i进入编辑模式----->编辑文件 ------->按Esc进入底行模式----->输入：wq/q! （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。
- rm -rf 文件： 删除文件（删）

> **压缩文件常用命令**

- 1）打包并压缩文件：

Linux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件 ，其中：

z：调用 gzip 压缩命令进行压缩
c：打包文件
v：显示运行过程
f：指定文件名
比如：假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt 或 tar -zcvf test.tar.gz /test/

- 2）解压压缩包：

命令：tar [-xvf] 压缩文件

其中：x：代表解压

示例：

将 /test 下的 test.tar.gz 解压到当前目录下可以使用命令：tar -xvf test.tar.gz
将 /test 下的 test.tar.gz 解压到根目录/usr 下:tar -xvf test.tar.gz -C /usr（- C 代表指定解压的位置）

> **Linux的权限命令**

操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。

通过 ls -l 命令我们可以 查看某个目录下的文件或目录的权限

示例：在随意某个目录下ls -l

![]()

第一列的内容的信息解释如下：

![](https://javaguide.cn/assets/Linux%E6%9D%83%E9%99%90%E8%A7%A3%E8%AF%BB.7c1098a0.png)

**文件类型：**

- d： 代表目录
- -： 代表文件
- l： 代表软链接（可以认为是 window 中的快捷方式）

**Linux 中权限分为以下几种：**

- r：代表权限是可读，r 也可以用数字 4 表示
- w：代表权限是可写，w 也可以用数字 2 表示
- x：代表权限是可执行，x 也可以用数字 1 表示

**文件和目录权限的区别**

对文件和目录而言，读写执行表示不同的意义。

对于文件：

|  权限名称 | 可执行操作|
|   ----    |   ----|
|r	    |可以使用 cat 查看文件的内容|
| w	|可以修改文件的内容|
| x	|可以将其运行为二进制文件|

对于目录:

|  权限名称 | 可执行操作|
|   ----    |   ----|
|r	    |可以查看目录下列表|
| w	|可以创建和删除目录下文件|
| x	|可以使用 cd 进入目录|

需要注意的是： 超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。

在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。

- 所有者(u) ：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 ls ‐ahl 命令可以看到文件的所有者 也可以使用 chown 用户名 文件名来修改文件的所有者 。
- 文件所在组(g) ：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 ls ‐ahl命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。
- 其它组(o) ：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组

**修改文件/目录的权限命令**

chmod

示例：修改/test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。

chmod u=rwx,g=rw,o=r aaa.txt 或者 chmod 764 aaa.txt


> **用户管理命令**

- useradd 选项 用户名:添加用户账号
- userdel 选项 用户名:删除用户帐号
- usermod 选项 用户名:修改帐号
- passwd 用户名:更改或创建用户的密码
- passwd -S 用户名 :显示用户账号密码信息
- passwd -d 用户名: 清除用户密码

> **Linux系统用户组管理**

- groupadd 选项 用户组 :增加一个新的用户组
- groupdel 用户组:要删除一个已有的用户组
- groupmod 选项 用户组 : 修改用户组的属性

> **查看日志命令**

tail:

-n 是显示行号；相当于nl命令；例子如下：

tail -100f test.log 实时监控100行日志

head:

跟tail是相反的，tail是看后多少行日志；例子如下：

head -n 10 test.log 查询日志文件中的头10行日志;

head -n -10 test.log 查询日志文件除了最后10行的其他所有日志;

cat：

tac是倒序查看，是cat单词反写；例子如下：

cat -n test.log |grep "debug" 查询关键字的日志
# 二、 计算机网络

## http协议属于哪一层

http属于应用层协议，其全称为超文本传输协议

## http返回的状态码有哪些，什么含义，比如404,200,500等

- 1xx：表示中间状态
- 2xx：表示成功，200表示成功，204代表成功未携带数据，206表示成功带分段数据
- 3xx:表示资源重定向
- 4xx:表示客户端请求错误
- 5xx：表示客户端请求错误
  
## TCP和UDP的区别

> **概述**

- TCP是面向连接的、可靠的字节流传输
- UDP是非连接的，不可靠的包传输

> **TCP与UDP的区别**

*1. 连接*

- TCP 是面向连接的传输层协议，传输数据前先要建立连接。
- UDP 是不需要连接，即刻传输数据。

*2. 服务对象*

- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信

*3. 可靠性*

- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
- UDP 是尽最大努力交付，不保证可靠交付数据。

*4. 拥塞控制、流量控制*

- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

*5. 首部开销*

- TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 `20` 个字节，如果使用了「选项」字段则会变长的。
- UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

*6. 传输方式*

- TCP 是流式传输，没有边界，但保证顺序和可靠。
- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

*7. 分片不同*

- TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
- UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

## TCP三次握手

TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而**建立连接是通过三次握手来进行的**。三次握手的过程如下图：

![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

- 一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态

![第一个报文—— SYN 报文](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzE1LmpwZw?x-oss-process=image/format,png)

- 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1` ，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。 

![第二个报文 —— SYN + ACK 报文](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzE2LmpwZw?x-oss-process=image/format,png)

- 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。

![第三个报文 —— ACK 报文](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzE3LmpwZw?x-oss-process=image/format,png)

- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 `ESTABLISHED` 状态。

- 服务器收到客户端的应答报文后，也进入 `ESTABLISHED` 状态。

从上面的过程可以发现**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**，这也是面试常问的题。

一旦完成三次握手，双方都处于 `ESTABLISHED` 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。

## TCP四次挥手

- 第一次：客户端发送FIN报文通知服务器即将断开
- 第二次:服务器收到FIN报文后返回ACK报文表示收到客户端断开通知
- 第三次:服务器发送FIN报文给客户端
- 第四次:客户端发送ACK报文到服务器端，表示查询

## cookie和session的区别，session中一般存放什么类型的信息

> **定义**

- Cookie相当于服务器生成一个票据给客户端，当客户端收到票据之后，保存起来，以后客户端每次访问服务器的时候，都需要携带这个票据

- 当客户端第一次请求服务器的时候，服务器生成一份session保存在服务端，将该数据(session)的id以cookie的形式传递给客户端；以后的每次请求，浏览器都会自动的携带cookie来访问服务器(session数据id)。

 > **Cookie和Session的区别**：

- 存储位置不同：
  - a. cookie的数据信息存放在客户端浏览器上。
  - b. session的数据信息存放在服务器上。
- 存储容量不同：
  - a. 单个cookie保存的数据<=4KB，一个站点最多保存20个Cookie。
  - b. 对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。
- 存储方式不同：
  - a. cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。
  - b. session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。


## 网站输入一个网址，会进行哪一些操作
- 客户端浏览器中输入网址URL
- 发送到DNS获得对应web服务器的网址
- 客户端浏览器与WEB服务器建立TCP连接
- 客户端向服务器端发送对应的HTTP请求或者HTTPS请求
- WEB服务器响应请求，返回指定的URL数据
- 客户端下载数据，解析HTML源文件
- 分析页面中的超链接，显示在当前页

# 三、算法与数据结构

## 判断链表是否有环

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {

        if(head == null){
            return head;
        }

        ListNode fast = head;
        ListNode slow = head;
        
        while(true){
            if(fast == null || fast.next == null){
                return null;
            }
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow){
                break;
            }
        }

        fast = head;

        while(fast != slow){
            fast = fast.next;
            slow = slow.next;
        }

        return slow;
        
    }
}
```

## 数组中第k大的数

- 暴力求解
  
```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return (nums[nums.length - k ]);
    }
}
```

- PriorityQueue

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        for(int num : nums){
            minHeap.add(num);
            if(minHeap.size() > k){
                minHeap.poll();
            }
        }
        return minHeap.poll();
    }
}
```

- 小顶堆

```java

class Solution {
    public int findKthLargest(int[] nums, int k) {

        // 对前k个元素构建成小顶堆

        for(int i = 0;i < k;i++){
            swim(nums,i);
        }

        // 剩下元素与堆顶比较，若大于堆顶则去掉堆顶，再将其放入
        for(int i = k;k < nums.length;i++){
            if(nums[i] > nums[0]){
                swap(nums,i,0);
                sink(nums,0,k- 1);
            }
        }
        return nums[0]

    }


    private void swim(int[] heap,int i){
        while(i > 0 && priorityThan(heap[i],heap[(i - 1) / 2]){
            swap(heap,i,(i - 1) / 2);
            i = (i - 1) / 2;
        }
    }

    private void sink(int[] heap,int i,int heapSize){
        while(2 * i + 1 <= heapSize){
            int j = 2 * i + 1;

            if(j + 1 <=  heapSize && priorityThan(heap[j + 1],heap[j])){
                j++;
            }

            if(priorityThan(heap[i],heap[j])){
                break;
            }

            swap(heap,i,j);
            i = j;
        }
    }
    
    private boolean priorityThan(int vi,int v2){
        return v1 < v2;
    }

    private void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}

```

## 给40亿个数，以及一个整数，判断该整数是否存在于这40亿个数中， 使用什么算法？

利用位图法思想：对于40亿个 unsigned int 的整数，每个数字用1个二进制数（一个二进制数占用1Bit，1Byte = 8Bit）来表示该数字是否存在，0为不存在，1为存在。从低位开始数：

第1个二进制数表示整数0是否存在

第2个二进制数表示整数1是否存在

第3个二进制数表示整数2是否存在

依次类推 ... ...

第4294967296个二进制数用于表示整数4294967295是否存在。

unsigned int 在32&64位编译器的范围为 0～4294967295，4294967296个二进制数大约占用512M内存，是一个可以接受的范围。

**Java实现**

由于Java中无法直接操作二进制数，因此我们可以通过 int 来实现。1个二进制数占用1 Bit；1个 int 占用4 Byte，也就是32 Bit。因此，我们可以使用1个int来表示32个二进制数。

 

所以，我们有以下思路：

 

第1个int表示：整数0 ~ 31是否存在

 

第2个int表示：整数32 ~ 63是否存在

 

第3个int表示：整数64 ~ 95是否存在，依此类推。

因此，我们最终可以使用一个int数组来表示4294967296个二进制数，通过数组的下标来指示第几个int。

# 四、JAVA

## 3.1 Java基础

> **HashMap底层原理？头插法尾插法产生的问题**

JDK1.8之后，HashMap底层是利用数组+链表与红黑树实现。
- 当链表长度大于8时，(如果当前数组长度小于64时，首先会对数组进行扩容)会自动将链表转换为红黑树。以减少搜索时间。

JDK1.7之前采用头插法、JDK1.8之后采用尾插法

采用头插法在并发扩容的时候，会改变链表中原本的顺序，以至于在并发场景下产生链表成环的问题。而采用尾插法在扩容时，链表会保持原有顺序，不会出现链表成环的问题。


> **线程安全map及其实现原理**

**JDK1.8之前**

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java7_concurrenthashmap.png)

首先将数据分为一段一段（这个“段”就是 Segment）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。

ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。

一个ConcurrentHashMap包含一个Segment数组，Segment数组的个数一旦初始化就无法改变。Segment数组个数默认是16，即默认可以同时支持16个线程并发写。

Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。也就是说，对同一 Segment 的并发写入会被阻塞，不同 Segment 的写入是可以并发执行的。

**JDK1.8之后**

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java8_concurrenthashmap.png)

此时ConcurrentHashMap取消了Segment分段锁，采用Node + CAS + synchronized来保证并发安全。数据结构与HashMap 1.8的类似。当链表长度超过8之后会将链表转换为红黑树。

Java 8 中，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。

> **阻塞队列**

阻塞队列(BlockingQueue)是指一个支持两个附加操作的队列，这两个附加操作为：

- 在队列为空时，从队列获取元素操作将会被阻塞
- 在队列为满时，向队列添加元素的操作会被阻塞。

阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。

阻塞队列的种类：

- ArrayBlockingQueue:由数组结构组成的有界阻塞队列
- LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为Integer.MAX_VALUE）阻塞队列
- PriorityBlockingQueue：支持优先级排序的无界阻塞队列
- DelayQueue：使用优先级队列实现的延迟无界阻塞队列
- SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列
- LinkedTransferQueue：由链表结构组成的无界阻塞队列
- LinkedBlockingDeque：由链表组成的双向阻塞队列

> **深拷贝、浅拷贝与引用拷贝**

引用拷贝：在堆中不创建新对象，新变量直接指向原对象的引用

浅拷贝:浅拷贝会在堆上创建一个新的对象，如果原对象内部的属性是引用类型，则浅拷贝会直接复制内部对象的引用地址，即拷贝对象与原对象公用一个内部对象

深拷贝:深拷贝会完全复制整个对象。

> **Integer a=10; int b=10; ab 输出true还是false Integer a =200; Integer b=200; ab输出true还是false**

```java
    Integer a = 10;
    int b = 10;
    a == b; // true

    Integer a = 100;
    Integer b = 100;
    a == b; //true 因为 Integer 对 byte 范围做了缓存 IntegerCache 所以只要是：-128~127 用 == 都是相等的，超过的都是 false

    Integer a = 200;
    Integer b = 200;

    a == b // false;
    a.equals(b); // true
```

## 3.2 JVM

> **JVM运行时内存模型？**

JVM运行时内存模型可分为四个区域:

- 堆、方法区、程序计数器、栈。其中堆和方法区是线程私有的、程序计数器和栈是线程公有的。  
- 堆:存放所有对象的实例，也是垃圾回收的主要区域因此也被称为GC堆。
- 方法区: 会存放被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量等
- 栈:虚拟机栈和本地方法栈。
  - Java虚拟机栈是线程私有的随线程创建而创建随线程死亡而死亡。方法的调用通过栈实现，每当一个方法调用就有一个栈帧被压入展，每个方法调用结束后会有一个栈帧被弹出。栈由栈帧组成，每个栈帧中包括：局部变量表、操作数栈、动态链接、方法返回地址等。运行中会出现`StackOverFlowError`和`OutOfMemoryError`错误；
  - 本地方法栈所发挥的作用与虚拟机栈的作用很类似：区别在于虚拟机栈是为Java方法所服务，本地方法栈为本地方法所服务。
- 程序计数器：当前线程所执行的字节码行号指示器，是唯一个不回出现`OutOfMemoryError`的内存区域。

> **垃圾回收算法**

- 标记-清除算法:首先标记出来不需要回收的对象，然后将未标记的对象进行回收
- 标记-整理算法:首先标记出不需要回收的对象，然后将其像内存一端移动，将边界外的对象清楚
- 标记-复制算法:将内存区域分为两块，当进行内存清理时，将一侧存活对象复制到另外一侧，然后将原始那一侧区域全部清除
- 分代算法:将对象根据存活周期分为新生代和老年代，然后根据各个年代的特征使用不同的算法。比如新生代中每次都有大量对象死去，因此可以采用“标记-复制算法”，而老年代对象存活率较高因此可以选择“标记-清除”或者“标记-整理算法”
  
> **垃圾回收器**

- 年轻代：
  - Serial：最基本的、历史最悠久的垃圾收集器。是一个单线程垃圾收集器。新生代采用标记复制算法，老年代采用标记整理算法
  - ParNew: Serial垃圾收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为与Serial完全一致。
  - Parallel Scanvenge收集器: 也是采用标记-复制算法的多线程垃圾收集器，但Parallel Scanvenge收集器关注的重点在于吞吐量。是JDK1.8默认的垃圾收集器
  
  ```java
    -XX:+UseParalleGC   //使用 Parallel 收集器+ 老年代串行
    -XX:+UseParaleelOldGC       // 使用 Parallel 收集器+ 老年代并行
  ```

- 老年代:
  - Serial Old: Serial收集器的老年版本，同样是一个单线程收集器，其主要用途包括:JDK1.5之前与Parallel Scanvenge收集器配合使用，另一用途是作为CMS的后备方案
  - Parelle Old：Parallel Scanvenge的老年版本，使用多线程与“标记清理算法”。在注重吞吐量以及CPU资源的场合都可以优先考虑Parallel Scanvenge和Parallel Old收集器
  - CMS：Concurrent Mark Sweep收集器，是获得最短停顿时间为目标的收集器。非常符合用户体验的应用上使用。采用标记-清除算法实现。标记过程分为：
    - 初始标记
    - 并发标记
    - 重新标记
    - 并发清除
- G1 垃圾收集器
  - 面向服务器的垃圾收集器，主要针对配备多颗处理器以及大容量内存的机器，以极高概率满足GC停顿时间要求的同时还具备高吞吐量的特征。

> **Xms，Xmx，Xss分别是什么含义**

- Xss:规定了虚拟机栈的大小
- Xms:java初始堆的大小
- Xmx:表示java堆所能达到的最大值

> **类加载的过程**

类加载的过程包括:

- 加载:通过全名限定加载类文件到内存区域
- 验证:然后验证该class文件，包括文件格式校验、元数据校验、字节码校验等
- 准备:为该内存对象分配内存
- 解析:将符号引用转化为直接引用
- 初始化:开始执行构造器代码

> **双亲委派机制**

java虚拟机的类加载器可以分为:自定义类加载器、应用程序类加载器、扩展类加载器、启动类加载器

当我们需要加载一个类的时候，首先会向上委派父类加载器进行加载，如果父类加载器没法加载，则会交给子类加载器去加载。

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。

## 3.3 Java并发编程

### 线程池了解吗

> **线程池**

线程池提供了一种限制和管理资源的方式，每个线程池维护着一些基本的统计信息，例如已完成任务的数量。其优势在于：

- 1. 降低资源消耗。通过重复利用已创建线程降低线程创建和销毁的消耗
- 2. 提高响应速度 ：当任务到达时，任务可以不需要等到线程创建就能立即执行。
- 3. 提高线程的可管理性

> **线程池的使用**

线程池真正实现类是ThreadPoolExecutor，共计有4中构造方法：

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
 
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         threadFactory, defaultHandler);
}
 
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          RejectedExecutionHandler handler) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), handler);
}
 
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

其中关键参数包括：

- corePoolSize:核心线程数
- maximumPoolSize:最大线程数
- keepAliveTime:线程闲置超时时长
- unit:指定keepAliveTime的时间单位

> **线程池使用流程**

- 创建线程池
- 向线程池提交任务
- 线程池执行任务
- 关闭线程池
  
```java
// 创建线程池
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(CORE_POOL_SIZE,
                                             MAXIMUM_POOL_SIZE,
                                             KEEP_ALIVE,
                                             TimeUnit.SECONDS,
                                             sPoolWorkQueue,
                                             sThreadFactory);
// 向线程池提交任务
threadPool.execute(new Runnable() {
    @Override
    public void run() {
        ... // 线程执行的任务
    }
});
// 关闭线程池
threadPool.shutdown(); // 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程
threadPool.shutdownNow(); // 设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表
```

> **线程池的工作原理**

![](https://img-blog.csdnimg.cn/20190809200646357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaW1teXN1bi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

### 创建线程池，线程加入线程池的过程

线程池的创建不允许使用Executor创建，使用Executor创建线程池弊端在于会导致`OutOfMemoryError`,通过ThreadPoolExecutor的方式来创建可以更加明确线程池的运行规则，避免资源耗尽风险，创建方式总共有如下两种：

- 方法一:通过构造方法实现,共计有4种构造方法:
![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ThreadPoolExecutor%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png)

- 方法二：通过Executor框架工具类Executors实现，我们可以创建三种类型的ThreadPoolExecutor：
  - FixedThreadPool:该方法返回固定数量的线程池，且线程池中的线程的数量始终不变，当一个新的任务提交池，线程中若有空闲线程则立即执行。如果没有则任务暂存到一个任务队列中，待有线程空闲时，便处理队列中的任务
  - SingleThreadPool:该方法返回一个只有一个线程的线程池，如果有多于1个的任务被提交到线程池，则存入队列，待线程空闲，按先入先出的顺序执行队列中的任务
  - CachedThreadPool:该方法返回一个可根据实际情况进行调整的线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。

    ![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB.png)

### AQS(Abstact Queue Synchronized)

> **AQS介绍**

AQS全称为 Abstract Queue Synchronized，这个类在java.util.concurrent.locks包下面实现。AQS是同步器和锁的实现框架，使用AQS可以高效便捷的实现大量且应用广泛的同步器，如`ReentrantLock`(可重入锁)、`Seamphore`(信号)等皆基于AQS。

> **AQS原理概览**

AQS的核心思想是，如果被请求的共享资源空闲，那么将申请该资源的线程设置为有效工作线程，并且将共享资源设置为锁定状态。如果共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配机制，该机制使用CLH队列实现，即将暂时获取不到锁的线程加入到队列中。

CLH队列是一个虚拟双向队列，即不存在队列实例，仅存在节点间的连接关系。AQS是将每条请求共享资源的线程封装成一个CLH锁队列中的一个结点来实现锁的分配。

![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/AQS%E5%8E%9F%E7%90%86%E5%9B%BE.png)

AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对值的修改

```java
    private volatile int state;//共享变量，使用volatile修饰保证线程可见性
```

状态信息通过protected类型的getState、setState、compareAndSetState进行操作

```java
//返回同步状态的当前值
protected final int getState() {
    return state;
}
//设置同步状态的值
protected final void setState(int newState) {
    state = newState;
}
//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）
protected final boolean compareAndSetState(int expect, int update) {
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```

> **AQS对资源的共享方式**

- Exclusive(独占):只有一个线程能执行，如果ReentrantLock。又可分为公平锁和非公平锁：
  - 公平锁:按照线程在队列中的排队顺序，先到者先拿到锁
  - 非公平锁:当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的
- Share(共享):多个线程可同时执行，如 CountDownLatch、Semaphore、 CyclicBarrier、ReadWriteLock

## 3.3 设计模式

> **手写双重校验锁的单例模式**

```java
public class Singleton{
    private volatile static Singleton instance = null;  // 1

    public static Singleton getInstance{
        if(instance == null){                           // 2
            synchronized(Singleton.class){              // 3
                if(instance == null){                   // 4
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

- 为什么要是用volatile?
  - volatile 保证了JVM对指令顺序进行优化，使得创建实例严格遵循，先分配内存然后再分配指针的顺序执行
  - volatile要求线程堆变量修改完成后立即存入共享内存，保证变量修改的可见性
- 为什么要用static?
  - 保证变量属于类，而不是属于对象实例，保证一个类只有一个变量
- 为什么不给getInstance方法修饰synchronized，而是在这里给类上锁?
  - 因为没有必要，如果在最外层判断出已有单例对象，则无需调用任何同步方法。而若给getInstance方法修饰synchronized，那么无论如何都有synchronized带来的额外开销。
- 为什么要有第二层校验?
    在多线程环境下，如果没有第二层校验（4），假设如下场景:
    线程A执行完2，在2与3之间发生了线程切换，切换到线程B
    线程B执行3并获取了锁，并对instance初始化。
    切换回线程A，执行3，获得了锁并进行instance初始化，会发现instance被初始化了2次因此必须进行二次校验。

# 五、 数据库MySQL

> **事务的四大特性**

- 原子性
- 一致性
- 隔离性
- 持久性

原子性由redo log保证
一致性由 undo log 保证一个类只有一个变量
隔离性由锁和MVCC保证
持久性：由ACI来保证

> **MySQL的隔离级别？如何解决幻读**

MySQL隔离级别可分为：

- 读未提交：是指一个事物更改的数据，当前未提交即可被其他事务看到
- 读提交:一个事物更改数据后，只有提交改事务之后才能被其他事务所看到
- 可重复度:是指一个事物从开始到提交全过程，该数据全程不会改变
- 串行化:会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

其中解决幻读是通过：串行化实现的

> **MYSQL都有什么索引，索引底层的数据结构，为什么走索引速度快？**

MySQL底层索引根据数据结构可以分为B+树索引，哈希索引，Full-text索引

根据物理存储可以分为：主键索引和辅助索引，主键索引key:存放的是数据表的主键，data域存放的是数据值，辅助索引data域存放的是索引的值

索引底层的数据结构是B+树，B+树是对B树的升级，B+树只会在叶子节点中存放索引和数据，叶子节点间通过链表连接，非叶子节点中只存放索引，不存放数据。

走索引速度的提升是因为，为数据创建唯一的索引，可以减少数据的检索量，提升数据扫描速度。

> **B树与B+树的区别**

B+只有叶子节点存储data，非叶子节点不存储data，叶子节点间通过链表相连

B树所有字节点都存储key-data，所有节点组成这棵树，且叶子节点指针为null

> **B+树索引与HashMap索引的区别**

- Hash索引不支持范围查询，而B+树支持范围查询
- Hash索引不支持联合索引的最左侧原则，而B+树
- Hash索引不支持OrderBy排序，而B+树支持
- Hash索引无法进行模糊查询，而B+树支持
- 等值查询时Hash索引效率高于B+树
  
> **联合索引及其使用情况**

联合索引：是指使用表中多个字段创建的索引

