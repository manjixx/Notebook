![操作系统所处位置](https://img2018.cnblogs.com/blog/1515111/202002/1515111-20200228111630399-665436860.png)

# 2.1 进程

## 2.1.1 进程模型
> 进程

我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个运行中的程序，就被称为「进程」（Process）。

「进程」（Process）:。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变批的当前值。

![进程](https://camo.githubusercontent.com/47bf9cc1a71228bec1d1155dc7c149b557666eae3dc495bfe503561833637745/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542462539422545372541382538422545352539322538432545372542412542462545372541382538422f342d2545382542462539422545372541382538422545342542412541342545362539422542462545382542462539302545382541312538432e6a7067)

>多道程序设计

CPU在各进程之间来回切换其间每个进程各运行几十或几百个毫秒。

>并行与并发的区别

![并行与并发的区别](https://camo.githubusercontent.com/323d360f950c1e0fbce8d42fa280f510b1adad5a36fe7a62042dc6f6ccbd011a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542462539422545372541382538422545352539322538432545372542412542462545372541382538422f352d2545352542392542362545352538462539312545342542382538452545352542392542362545382541312538432e6a7067)

### 2.1.2 进程的创建

> 四件事会导致进程的创建
- 系统初始化
- 正在运行的程序执行了创建进程的系统调用
- 用户诘求创建一个新进程。
- 个批处理作业的初始化。

> 守护进程与普通进程

「守护进程 (daemon) 」

- 守护进程是生存期长的一种进程，没有控制终端。它们常常在系统引导装入时启动，仅在系统关闭时才终止。

- UNIX系统有很多守护进程，守护进程程序的名称通常以字母“d”结尾。例如 http 服务的守护进程叫 httpd，mysql 服务的守护进程叫 mysqld。

- 在UNIX中可以用ps 程序列出正在运行的进程 Windows 中，可使用任务管理器。

「普通进程」

> 创建进程

**「UNIX系统」**

- UNIX系统中，只有一个系统调用可以用来创建新进程： fork 。

- 这个系统调用会创建一个与调用进程相同的副本。在调用了fork后，这两个进程（父进程和子进程）拥有相同的内存映像、同样的环境字
符串和同样的打开文件。

- 通常子进程接着执行execve或一个类似的系统调用，以修改其内存映像并运行一个新的程序。

**「Windows系统」**

- 一个Win 32 函数调用createProcess 既处理进程的创建，也负责把正确的程序装入新的进程。

- 该调用有10个参数，其中包括要执行的程序、输人给该程序的命令行参数、各种安全属性、有关打开的文件是否继承的控制位、优先级信息、该进程（若有的话）所需要创建的窗口
规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。

- 除了CreateProcess, Win32 中有大约 100个其他的函数用干处理进程的管理、同步以及相关的事务

**「父进程与子进程的地址空间」**

- 在UNIX中，子进程共享父进程的所有内存，但这种情况下内存通过写时复制 (copy-on-write) 共享，这意味着一且两者之一想要修改部分内存，则这块内存首先被明确地复制，以确保修改发生在私有内存区域。再次强调，**可写的内存是不可以共享的．**

- Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的．

## 2.1.3 进程的终止

> **进程终止的条件**

- **正常退出(自愿的)**
  - 当编译器完成了所给定程序的编译之后，编译器执行一个系统调用，通知操作系统它的工作已经完成。面向屏样的程序也支持自愿终止
  - 在UNIX中该调用是exit 而在Windows 中，相关的调用ExitProcess 
- **出错退出（自愿的)**
- **严重错误（非自愿)**
- **被其他进程杀死（非自愿）**
  - 某个进程执行一个系统调用通知操作系统杀死某个其他进程
  - 在UNIX中，这个系统调用是kill 。在Win32 中对应的函数TerminateProcess

在有些系统中，当一个进程终止时，不论是自愿的还是其他原因，由该进程所创建的所有子进程也一律立即被杀死。不过UNIX和Windows 都不是这种工作方式。

## 2.1.4 进程的层次结构

> **UNIX系统**

UNIX中，进程和它的所有子进程以及后裔共同组成一个进程组。

当用户从键盘发出一个信号时该信号被送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。

每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。

> **Windows**

- Windows 中没有进程层次的概念，所有的进程都是地位相同的。

- 唯一类似千进程层次的暗示是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。但是，它有权把这个令牌传送给某个其他进程 这样就不存在进程层次了。
  
- 在UNIX中，进程就不能剥夺其子继承的＂继承权”。

## 2.1.4 进程的状态

> **进程活动期间的三种基本状态**

![进程的三种基本状态](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/7-进程三个基本状态.jpg)

上图中各个状态的意义：

- 运行状态（*Runing*）：该时刻进程占用 CPU；
- 就绪状态（*Ready*）：可运行，由于其他进程处于运行状态而暂时停止运行；
- 阻塞状态（*Blocked*）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；

> **进程的另外两个基本状态：**

- 创建状态（*new*）：进程正在被创建时的状态；
- 结束状态（*Exit*）：进程正在从系统中消失时的状态；

> **完整的进程状态**

**一个完整的进程状态的变迁如下图：**

![进程五种状态的变迁](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/8-进程五个状态.jpg)

**进程的状态变迁：**

- *NULL -> 创建状态*：一个新进程被创建时的第一个状态；
- *创建状态 -> 就绪状态*：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；
- *就绪态 -> 运行状态*：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；
- *运行状态 -> 结束状态*：当进程已经运行完成或出错时，会被操作系统作结束状态处理；
- *运行状态 -> 就绪状态*：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；
- *运行状态 -> 阻塞状态*：当进程请求某个事件且必须等待时，例如请求 I/O 事件；
- *阻塞状态 -> 就绪状态*：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；

> **挂起状态**

**挂起状态产生的原因**

如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，显然不是我们所希望的，毕竟物理内存空间是有限的，被阻塞状态的进程占用着物理内存就一种浪费物理内存的行为。

所以，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。


![虚拟内存管理-换入换出](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/9-换入换出.jpg)

那么，就需要一个新的状态，来**描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态**。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。

导致进程挂起的原因不只是因为进程所使用的内存空间不在物理内存，还包括如下情况：

- 通过 sleep 让进程间歇性挂起，其工作原理是设置一个定时器，到期后唤醒进程。
- 用户希望挂起一个程序的执行，比如在 Linux 中用 `Ctrl+Z` 挂起进程；


**挂起状态的种类**

- 挂起状态可以分为两种，阻塞挂起状态与就绪挂起状态

- 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
- 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；

> **进程的七种状态变迁**

![七种状态变迁](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/10-进程七中状态.jpg)


## 2.1.6 进程的实现

### 进程的控制结构

> **进程控制块**

为了实现进程换型，操作系统维护着一张表格（一个结构数组）即**进程控制块**（*process control block，PCB*），来描述进程的。

**PCB 是进程存在的唯一标识**，每个进程占用一个进程表项，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

> **PCB 具体包含的信息**

**进程描述信息：**

- 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
- 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；

**进程控制和管理信息：**

- 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
- 进程优先级：进程抢占 CPU 时的优先级；

**资源分配清单：**

- 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。

**CPU 相关信息：**

- CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

可见，PCB 包含信息还是比较多的。

> **PCB 的组织方式**

通常是通过**链表**的方式进行组织，把具有**相同状态的进程链在一起，组成各种队列**。比如：

- 将所有处于就绪状态的进程链在一起，称为**就绪队列**；
- 把所有因等待某事件而处于等待状态的进程链在一起就组成各种**阻塞队列**；
- 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。

那么，就绪队列和阻塞队列链表的组织形式如下图：

![就绪队列和阻塞队列](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/12-PCB状态链表组织.jpg)

除了链接的组织方式，还有索引方式，它的工作原理：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。

一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。

### 进程的控制

我们熟知了进程的状态变迁和进程的数据结构 PCB 后，再来看看进程的**创建、终止、阻塞、唤醒**的过程，这些过程也就是进程的控制。

> **01. 创建进程**

操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止时，其在父进程处继承的资源应当还给父进程。同时，终止父进程时同时也会终止其所有的子进程。

注意：Linux 操作系统对于终止有子进程的父进程，会把子进程交给 1 号进程接管。本文所指出的进程终止概念是宏观操作系统的一种观点，最后怎么实现当然是看具体的操作系统。

创建进程的过程如下：

- 为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB，PCB 是有限的，若申请失败则创建失败；
- 为进程分配资源，此处如果资源不足，进程就会进入等待状态，以等待资源；
- 初始化 PCB；
- 如果进程的调度队列能够接纳新进程，那就将进程插入到就绪队列，等待被调度运行；

> **02. 终止进程**

进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 `kill` 掉）。注意此处异常结束应该包括上述中的出错退出与严重错误退出。

终止进程的过程如下：

- 查找需要终止的进程的 PCB；
- 如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；
- 如果其还有子进程，则应将其所有子进程终止；
- 将该进程所拥有的全部资源都归还给父进程或操作系统；
- 将其从 PCB 所在队列中删除；

> **03. 阻塞进程**

当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。

阻塞进程的过程如下：

- 找到将要被阻塞进程标识号对应的 PCB；
- 如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；
- 将该 PCB 插入到阻塞队列中去；

>**04. 唤醒进程**

进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。

如果某进程正在等待 I/O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。

唤醒进程的过程如下：

- 在该事件的阻塞队列中找到相应进程的 PCB；
- 将其从阻塞队列中移出，并置其状态为就绪状态；
- 把该 PCB 插入到就绪队列中，等待调度程序调度；

进程的阻塞和唤醒是一对功能相反的语句，如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句。

### 进程的上下文切换

各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个**一个进程切换到另一个进程运行，称为进程的上下文切换**。

> **CPU 上下文**


大多数操作系统都是多任务，通常支持大于 CPU 数量的任务同时运行。实际上，这些任务并不是同时运行的，只是因为系统在很短的时间内，让各个任务分别在 CPU 运行，于是就造成同时运行的错觉。

任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。

所以，操作系统需要事先帮 CPU 设置好 **CPU 寄存器和程序计数器**。


CPU 寄存器是 CPU 内部一个容量小，但是速度极快的内存（缓存）。

程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。


因此CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 **CPU 上下文**。


> **CPU 上下文切换**

CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。


系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。

上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：
- **进程上下文切换**
- **线程上下文切换**
- **中断上下文切换**


> **进程的上下文切换**

进程是由内核管理和调度的，所以进程的切换只能发生在内核态。所以，**进程的上下文切换包含了：**
  
- 虚拟内存、栈、全局变量等 **用户空间的资源**
- 内核堆栈、寄存器等 **内核空间的资源**

通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：

![进程上下文切换](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/操作系统/进程和线程/13-进程上下文切换.jpg)

大家需要注意，进程的上下文开销是很关键的，我们希望它的开销越小越好，这样可以使得进程可以把更多时间花费在执行程序上，而不是耗费在上下文切换。

> **发生进程上下文切换的场景**

- 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，**当某个进程的时间片耗尽时**，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；
  
- **进程在系统资源不足（比如内存不足）时**，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；
- 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度

- **当有优先级更高的进程运行时**，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行
  
- **发生硬件中断时**，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；

以上，就是发生进程上下文切换的常见场景了。
