# Chapter 01. 基础

**算法**这个词来描述一种**有限、确定、有效的**并适合用计算机程序来实现的解决问题的方法。算法是计算机科学的基础，是这个领域研究的核心。

本书的目的是研究多种重要而实用的**算法**，即适合用计算机实现的解决问题的方法。和算法关系最紧密的是**数据结构**，即便于算法操作的组织数据的方法。本章介绍的就是学习算法和数据结构所需要的基本工具

- Java语法基础
- 数据抽象并定义抽象数据类型(ADT)以进行模块化编程
- 三种基础抽象数据类型:背包、队列和栈
- 分析算法性能方法
- 连通性问题

`所有算法都是先有API、再有实现，之后是证明，最后是数据`

## 1.1 基础编程模型

我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为**基础编程模型**。

### 1.1.1 Java程序的基本结构

要创建静态方法库和定义数据类型，会用到下面七种语法，它们是Java语言的基础，也是大多数现代语言所共有的。

- 原始数据类型：它们在计算机程序中精确地定义整数、 浮点数和布尔值等。它们的定义包括取值范围和能够对相应的值进行的操作，它们能够被组合为类似于数学公式定义的表达式。
- 语句：语句通过创建变量并对其赋值、控制运行流程或者引发副作用来进行计算。我们会使用六种语句： 声明、 赋值、 条件、 循环、 调用和返回。
- 数组：数组是多个同种数据类型的值的集合。
- 静态方法：静态方法可以封装并重用代码，使我们可以用独立的模块开发程序。
- 字符串：字符串是一连串的字符， Java 内置了对它们的一些操作。
- 标准输入 / 输出：标准输入输出是程序与外界联系的桥梁。
- 数据抽象：数据抽象封装和重用代码，使我们可以定义非原始数据类型，进而支持面向对象编程。
我们将在本节学习前六种语法，数据抽象是下一节的主题

**java编译流程:**

- javac编译
- java命令运行

### 1.1.2 原始数据类型与表达式

### 1.1.3 语句

- 声明语句：创建某种类型的变量并用标识符为其命名。
- 赋值语句：将（由表达式产生的）某种类型的数值赋予一个变量。 Java 还有一些隐式赋值的语法可以使某个变量的值相对于当前值发生变化，例如将一个整型值加 1。
- 条件语句：能够简单地改变执行流程——根据指定的条件执行两个代码段之一。
- 循环语句：更彻底地改变执行流程——只要条件为真就不断地反复执行代码段中的语句。
- 调用和返回语句：和静态方法有关（见 1.1.6 节），是改变执行流程和代码组织的另一种方式。
程序就是由一系列声明、赋值、条件、循环、调用和返回语句组成的。

### 1.1.4 简便记法

- 声明并初始化
- 隐式赋值
- 单语句代码段
- for 语句

### 1.1.5 数组

典型代码数组处理代码

```java
/**找出数组中的最大元素 */
double max = a[0];
for (int i = 1; i < a.length; i++)
    if (a[i] > max) 
        max = a[i];
    
/**计算数组元素的平均值 */
int N = a.length;
double sum = 0.0;
for (int i = 0; i < N; i++)
    sum += a[i];
double average = sum / N;

/*复制数组 */

int N = a.length;
double[] b = new double[N];
for (int i = 0; i < N; i++)
    b[i] = a[i];


/** 颠倒数组元素的顺序 */

int N = a.length;
for (int i = 0; i < N/2; i++)
{
    double temp = a[i];
    a[i] = a[N-1-i];
    a[N-i-1] = temp;
}

/**矩阵相乘 */
int N = a.length;
double[][] c = new double[N][N];
for (int i = 0; i < N; i++)
    for (int j = 0; j < N; j++)
    { // 计算行 i 和列 j 的点乘
        for (int k = 0; k < N; k++)
            c[i][j] += a[i][k]*b[k][j];
    }
```

### 1.6.1 静态方法

修饰符 static将静态方法与实例方法区别开来

#### 1.6.1.1 静态方法

典型静态方法的实现

```java
/**计算一个整数的绝对值 */
public static int abs(int x){
    if(x < 0) return -x;
    else return x;
}

/**计算一个浮点数的绝对值 */

public static double abs(double x){
    if(x < 0.0) return -x;
    else return x;
}

/**判定一个数是否为素数 */

public static boolean isPrime(int N){
    if(N < 2) return false;
    for(int i = 2;i * i <= N; i++){
        if(N % i == 0) return false;
    }
    return true;
}

/**
    计算平方根 : 牛顿迭代法
*/

public static double sqrt(double c){
    if(c < 0) return Double.NaN;
    double err = 1e-15;
    double t = c;
    while(Math.abs(t - c/t) > err * t)
        t = (c/t + t) / 2.0;
    return t;
}

/**
 计算直角三角形的斜边 
 */
public static double hypotenuse(double a, double b){ 
    return Math.sqrt(a*a + b*b); 
}

/** 
 计算调和级数（请见表 1.4.5）
*/
public static double H(int N)
{
    double sum = 0.0;
    for (int i = 1; i <= N; i++)
    sum += 1.0 / i;
    return sum;
}
```

> **补充牛顿迭代法**

**牛顿迭代法原理:**思路就是不断取切线，用线性方程的根逼近非线性方程`f(x)=0`的a根X。

![](https://img-blog.csdn.net/20170826120834034)

源代码如上所示，在这段简洁巧妙的代码中我们主要理解两个点：

- (1）t = (c/t + t) / 2.0 的由来
  - 确定我们需要求解的函数${y=f(x)}$，在求平方根中该函数为${f(x)=x^2-c}$;
  - 假设给定初始点的横坐标为x0，则其对应的切线方程为${Q(x)=f '(x0)*(x-x0) + f(x0)}$,在求平方根的算法中该切线方程为${Q(x) = 2*x0*(x - x0) + x0^2-c}$;
  - 根据切线方程与横坐标的交点得到下一个迭代点的横坐标，若前一迭代点的横坐标记为Xn，则下一迭代点的横坐标记为Xn+1，令第二条中的${x0=Xn,Q(x)  = 0}$可以得到Xn+1的表达式：${Xn+1 = (c/Xn + Xn) / 2}$上式便是算法源代码中使用的迭代公式。
-（2）Math.abs(t-c/t) > err * t 条件的由来；
  - 首先对于收敛条件，或者说误差的判断条件我们有以下几个选择：
    - 1. ${Math.Abs(t*t - c) > err}$ : 最为直观的误差形式，直接带入方程得到与所求函数值的差值，我姑且在这里称其为“绝对误差”，我在一些网上的博文中看到了使用这个误差的代码；
    - 2. ${Math.Abs(t - c/t) > err}$ ：我又根据数学中对牛顿迭代误差的分析，通过微分中值定理得到形式类似的误差形式，我在这里姑且称之为“中值误差”，这种误差我在stackOverflow上看到了类似代码；
    - 3. ${Math.Abs(t - c/t) > err*t}$ ：最后就是《算法》这本书中源代码中使用的误差表达形式，这里姑且称之为“算法误差”，如果我没有看过源代码，我自己是不能直接写出这种形式的，那么使用这种形式的误差的理由是什么呢？
  - 这里我们使用这三种误差来计算1e-100的平方根，代码中的err=1e-15。
    - 首先是使用“绝对误差”,得到结果如下, 显然这是个错误答案，因为用IEEE 754标准表示的Double类型其范围为+/-1.7976931348623157E+308，绝对误差一是超出了double的精度范围，二是直接小于我们设定的收敛条件得到了错误答案。
![](https://img-blog.csdnimg.cn/25c4bfe89f9f4e08ae0ced7b89d3b795.png)  
    - 其次使用“中值误差”，得到结果如下.可以看到中值误差也过早地进入到了我们的收敛条件中，得到了错误的结果，那如果我们给err进行一个适应性的缩放会不会得到正确的结果呢？
        ![](https://img-blog.csdnimg.cn/026d2da751e0424da3e7ffacc58c9c08.png)

    - 最后我们使用《算法》中的源代码进行计算，可以得到下图可以看到我们得到了正确的结果，
    
        ![](https://img-blog.csdnimg.cn/2feb5bee978f4de8b35d4c3a0d760385.png)

  - 通过这个测试我们知道了几点：
    - 一是《算法》源代码中的误差形式可以从微分中值定理推导得到，
    - 二是为了使算法对于任意的double类型变量都能够得到正确的结果，要对收敛条件进行一个适当的缩放，这样可以避免收敛条件过大导致对于较小的数值得到错误的结果，或对于过大的数值导致收敛过慢或不收敛。

#### 1.1.6.2 方法调用

#### 1.1.6.3 方法的性质

- 方法的参数按值传递
- 方法名可以被重载
- 方法只能返回一个值，但可以包含多个返回语句
- 方法可以产生副作用

#### 1.1.6.4 递归

递归编写时有如下重要三点:

- 递归总有一个最简单的情况——方法的第一条语句总是一个包含 return 的条件语句。
- **递归调用总是去尝试解决一个规模更小的子问题**，这样递归才能收敛到最简单的情况。在下面的代码中，第四个参数和第三个参数的差值一直在缩小。
- **递归调用的父问题和尝试解决的子问题之间不应该有交集**。在下面的代码中，两个子问题各自操作的数组部分是不同的。

```c
/**二分查找的递归实现 */
public static int rank(int key, int[] a){ 
    return rank(key, a, 0, a.length - 1); 
}
public static int rank(int key, int[] a, int lo, int hi){ 
    //如果key存在于a[]中，它的索引不会小于lo且不会大于hi
    if (lo > hi) return -1;
    int mid = lo + (hi - lo) / 2;
    if (key < a[mid]) return rank(key, a, lo, mid - 1);
    else if (key > a[mid]) return rank(key, a, mid + 1, hi);
    else return mid;
}
```

***

## 1.2 数据抽象

***

## 1.3 背包、队列和栈

***

## 1.4 算法分析

***

## 1.5 案例研究
