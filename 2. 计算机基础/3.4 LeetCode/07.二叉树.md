# 一、 二叉树理论基础

## 1.1二叉树的种类

### 1.1.1 满二叉树

- 定义：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。深度为k，有2^k-1个节点的二叉树。

![满二叉树](https://img-blog.csdnimg.cn/20200806185805576.png)


### 1.1.2 完全二叉搜索树

- 定义：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

![完全二叉搜索树](https://img-blog.csdnimg.cn/20200920221638903.png)

- 优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。


### 1.1.3 二叉搜索树

- 二叉搜索树是一个有序树。
  - 若它的左子树不空，则左子树上所有结点的值 < 它的根结点的值；
  - 若它的右子树不空，则右子树上所有结点的值 > 它的根结点的值；
  - 它的左、右子树也分别为二叉排序树

![二叉搜索树](https://img-blog.csdnimg.cn/20200806190304693.png)


### 1.1.4 平衡二叉搜索树(平衡二叉树)

- 定义：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

![平衡二叉树](https://img-blog.csdnimg.cn/20200806190511967.png)


>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，
>注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。
>所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚！

## 1.2 二叉树的存储方式

- 链式存储

![二叉树的链式存储](https://img-blog.csdnimg.cn/2020092019554618.png)

- 顺序存储

![二叉树的顺序存储](https://img-blog.csdnimg.cn/20200920200429452.png)

如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。

## 1.3 二叉树的遍历方式

- 二叉树主要有两种遍历方式：
  - 深度优先遍历：先往深走，遇到叶子节点再往回走  
  - 广度优先遍历：一层一层的去遍历

- 从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：
  - 深度优先遍历
    - 前序遍历（递归法，迭代法）
    - 中序遍历（递归法，迭代法）
    - 后序遍历（递归法，迭代法）
    <center>![二叉树三种遍历方式](https://img-blog.csdnimg.cn/20200806191109896.png)</center>
    
  - 广度优先遍历
    - 层次遍历（迭代法）


## 1.4 二叉树的定义

```java
  public class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
      this.val = val;
    }
    TreeNode(int val, TreeNode left, TreeNode right){
      this.val = val;
      this.left = left;
      this.right = right;
    }
}
```

***

# 二、 二叉树的遍历方式

## 2.1 二叉树的递归遍历

递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

因此可以使用栈实现递归。

- 递归算法的三要素：
  - 确定递归函数的参数和返回值
  - 确定递归的终止条件
  - 确定单层递归的逻辑

- 二叉树的递归遍历
  - [二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
  - [二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
  - [二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

## 2.2 二叉树的迭代遍历

### 2.2.1 前序遍历（迭代法）

> 代码
 
```java
class Solution{

    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = ArrayList<Integer>();

        if(root == null){
          return ans;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();

        stack.add(root);

        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            ans.add(node.val);
            if(node.right != null){
                stack.push(node.right);
            }
            if(node.left != null){
                stack.push(node.left);
            }
        }
        return ans; 
    }
}
```

- 复杂度分析
  - 空间复杂度：${O(n)}$
  - 时间复杂度：${O(n)}$ 

### 2.2.2 中序遍历（迭代法）

> 代码
 
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        Deque<TreeNode> stack = new  LinkedList<TreeNode>();
        if(root == null){
          return ans;
        }
        TreeNode node = root;
        while(node != null || !stack.isEmpty()){
            if(node != null){
                stack.push(node);
                node = node.left;
            }else{
                node = stack.pop();
                ans.add(node.val);
                node = node.right;
                stack.push(node);
            }
        }
        return ans;
    }
}
```

- 复杂度分析
  - 空间复杂度：${O(n)}$
  - 时间复杂度：${O(n)}$ 

### 2.2.3 后序遍历（迭代法）

- 代码

```java
class Solution{
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        if(root == null){
          return ans;
        }
        
        Deque<TreeNode> stack = new LinkedList<TreeNode>();

        stack.push(root);

        while(!stack.isEmpty()){
             TreeNode node = stack.pop();
             ans.add(node.val);
             if(node.left != null){
                stack.push(node.left);
             }
             if(node.right != null){
                stack.push(node.right);
             }
        }
        Collections.reverse(ans);
        return ans;
    }
}
```

- 复杂度分析
  - 空间复杂度：${O(n)}$
  - 时间复杂度：${O(n)}$ 

### 2.2.4 二叉树的统一迭代法

## 2.3 二叉树的层序遍历

### 2.3.1 [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

> **迭代层序遍历**

```java
class Solution{
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();

        if(root == null){
            return ans;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.add(root);

        int i = 1;

        while(!queue.isEmpty()){
            List<Integer> tmp = new ArrayList<Integer>();
            int count = queue.size();
            for(int i = 0;i < count;i++){
                TreeNode node = queue.offer();
                tmp.add(node.val);
                if(node.left != null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
            }

            if(i % 2 == 0){
                i++;
                Collections.reverse(tmp);
            }

            ans.add(new ArrayList<Integer>(tmp));
        }
        return ans;
    }
}
```

### 2.3.2 [二叉树的层序遍历II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

> **递归层序遍历**


```java
/**
    递归层序遍历
 */

 class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        int depth = 0;
        order(root, ans,depth);
        return ans;
    }

    private void order(TreeNode root, List<List<Integer>> ans, int depth){
        if(root == null){
            return;
        }
        depth++;
        if(ans.size() < depth){
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> temp = new ArrayList<Integer>();
            ans.add(temp);
        }
        ans.get(depth - 1).add(root.val);
        order(root.left,ans,depth);
        order(root.right,ans,depth);
    }
 }
```

> **迭代层序遍历**

```java
class Solution{
    public List<List<Integer>>  levelOrderBottom(TreeNode root){
        List<List<Integer>> ans = new ArrayList<List<Integer>>();

        if(root == null){
            return ans;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.add(root);

        int k = 1;

        while(!queue.isEmpty()){
            List<Integer> tmp = new ArrayList<Integer>();
            int count = queue.size();
            for(int i = 0;i < count;i++){
                TreeNode node = queue.poll();
                tmp.add(node.val);
                if(node.left != null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
            }

            ans.add(new ArrayList<Integer>(tmp));
        }

        Collections.reverse(ans);
        return ans;
    }
}
```

### 2.3.3 [二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

> **迭代层序遍历**

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();

        if(root == null){
            return ans;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.add(root);

        int k = 0;

        while(!queue.isEmpty()){
            List<Integer> tmp = new ArrayList<Integer>();
            int count = queue.size();
            for(int i = 0;i < count;i++){
                TreeNode node = queue.poll();
                tmp.add(node.val);
                if(node.left != null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
            }

            if(k % 2 != 0){
                Collections.reverse(tmp);
            }
            k++;

            ans.add(new ArrayList<Integer>(tmp));
        }
        return ans;

    }
}
```

### 2.3.4 [二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();

        if(root == null){
            return ans;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.offer(root);

        while(!queue.isEmpty()){
            int count = queue.size();
            for(int i = 0;i < count;i++){
                TreeNode node = queue.poll();
                if(i == count - 1){
                    ans.add(node.val);
                }
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
            }
        }

        return ans;
    }
}
```

### 2.3.5 [二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

```java
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> ans = new ArrayList<Double>();

        if(root == null){
            return ans;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.offer(root);

        while(!queue.isEmpty()){
            int count = queue.size();
            int sum = 0;
            for(int i = 0;i < count;i++){
                TreeNode node = queue.poll();
                sum += node.val;
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
            }
            ans.add(sum / count);
        }

        return ans;
    }
}
```

### 2.3.6 [N叉树的遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

```java
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();

        if(root == null){
            return ans;
        }

        Queue<Node> queue = new LinkedList<Node>();

        queue.offer(root);

        while(!queue.isEmpty()){
            int count = queue.size();
            List<Integer> list = new ArrayList<Integer>(); 
            for(int i = 0;i < count;i++){
               Node node = queue.poll();
               list.add(node.val);
                if(node.children != null){
                    List<Node> nodeList = node.children;
                    for(int j = 0;j < nodeList.size();j++){
                        queue.offer(nodeList.get(j));
                    }
                }
            }
            ans.add(new ArrayList<>(list));
        }
        return ans;
    }
}
```

### 2.3.7 [在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();

        if(root == null){
            return ans;
        }
        
        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.offer(root);

        while(!queue.isEmpty()){
            int max = 0;
            int count = queue.size();

            for(int i = 0;i < count;i++){
                TreeNode node = queue.poll();
                max = Math.max(max,node.val);

                if(node.left != null){
                    queue.offer(node.left);
                }

                if(node.right != null){
                    queue.offer(node.right);
                }
            }

            ans.add(max);
        }

        return ans;
    }
}
```

### 2.3.8 [填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

> **递归法**

- 确定递归函数的参数和返回值

```java
public static void connect(Node left,Node right){

}
```

- 确定递归的终止条件

```java
if(left == null || right == null){
    return;
}
```

- 确定单层递归的逻辑
  - 连接左右节点
  - 连接左节点的子节点、连接右节点的子节点
  - 连接左节点的右子节点与右节点的左子节点

```java
class Solution {
    public Node connect(Node root){
        if(root == null){
            return root;
        }

        connectNode(root.left,root.right);
        return root;
    }

    public void connectNode(Node left,Node right){
        if(left == null || right == null){
            return;
        }

        // 连接左右节点

        left.next = right;

        // 连接左节点的子节点、连接右节点的子节点
        connectNode(left.left,left.right);
        connectNode(right.left,right.right);

        // 连接左节点的右子节点与右节点的左子节点
        connectNode(left.right,right.left);
    }
}

```

> **迭代法**

- 层序遍历

```java
class Solution{
    public Node connect(Node root){
        if(root == null){
            return root;
        }

        Queue<Node> queue = new LinkedList<Node>();

        queue.offer(root);

        while(!queue.isEmpty()){

            int size = queue.size();
            // 获取首节点
            Node cur = queue.poll();

            if(cur.left != null){
                queue.offer(cur.left);
            }

            if(cur.right != null){
                queue.offer(cur.right);
            }
            // i从1开始
            for(int i = 1;i < size;i++){
                Node node = queue.poll();

                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }

                cur.next = node;
                cur = node;
            }

            // 最后一个节点指向null
            cur.next = null;
        }
    }
    return root;
}
```

### 2.3.9 [二叉树最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

### 2.3.10 [二叉树最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

---

# 三、 二叉树的属性

## 3.1 [对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

> **递归法**

二叉树是否对称需要判断三层

- root节点的左右节点值是否为空，如果二者均为空，则对称
- root节点左右节点一为空一不为空，则不对称
- 左右节点值相等，且左节点的左节点与右节点的右节点对称，左节点的右节点与右节点的左节点对称。

```java

// 确定递归函数的参数和返回值
public boolean symmetric(TreeNode left,TreeNode right){
    // 确定递归的终止条件
    if(left == null && right == null){
        return true;
    }

    if(left == null || right == null){
        return false;
    }

    // 确定单层递归的逻辑
    return left.val == right.val && symmetric(left.left,right.right) && symmetric(left.right,right.left);
}
```
> 迭代法

![](https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif)

```java
public boolean isSymmetric(TreeNode root){
    if(root == null){
        return true;
    }

    Queue<TreeNode> queue = new LinkedList<TreeNode>();

    queue.offer(root.left);
    queue.offer(root.right);

    while(!queue.isEmpty()){

        TreeNode right = queue.poll();
        TreeNode left = queue.poll();
        // 左节点为空、右节点为空，此时说明是对称的
        if(left == null && right == null){
            continue;
        }
        // 左右一个节点不为空，或者都不为空但数值不相同，返回false
        if(left == null || right == null || ((left.val != right.val))){
            return false;
        }

        queue.offer(left.left);
        queue.offer(right.right);
        queue.offer(left.right);
        queue.offer(right.left);
    }
    return true;
}

```

## 3.2 [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

注意理解最小深度

![](https://img-blog.csdnimg.cn/20210203155800503.png)

> **递归法**

- 确定递归函数的参数和返回值

```java
public int minDepth(TreeNode root){
    return depth;
}
```

- 确定递归的终止条件

```java
if(root == null){
    return 0;
}
```

- 确定单层递归的逻辑

```java
// 如果左节点为空右节点不为空，则返回右节点里的最小深度
if(root.left == null && root.right != null){
    return 1 + minDepth(root.right);
}
// 如果左节点不为空右节点为空，则返回左节点里的最小深度
if(root.left != null && root.right == null){
    return 1 + minDepth(root.left);
}
// 如果左右节点都不为空，则返回二者里的最小值 + 1
return 1 + Math.min(minDepth(root.left),minDepth(root.right));

```

> **迭代法**

应用层序遍历二叉树

```java
class Solution{
    public int minDepth(TreeNode root){
        if(root == null){
            return 0;
        }
        
        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.offer(root);

        int depth = 1;

        while(!queue.isEmpty()){
            int count = queue.size();
            depth++;

            for(int i = 0;i < count;i++){
                TreeNode node = queue.poll();

                if(node.left == null && node.right == null){
                    return depth;
                }

                if(node.left != null){
                    queue.offer(node.left);
                }

                if(node.right != null){
                    queue.offer(node.right);
                }
            }
        }
        return depth;
    }
}

```

## 3.3[二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

> **递归法**

- 确定递归函数的参数和返回值

```java
public int maxDepth(TreeNode root) {

}
```

- 确定递归的终止条件

```java
if(root == null){
    return 0;
}
```

- 确定单层递归的逻辑

```java
return 1 + Math.max(maxDepth(root.left),maxDepth(root.right));
```

> **迭代法**

利用层序遍历完成二叉树最大深度的计算

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.offer(root);

        int depth = 0;

        while(!queue.isEmpty()){
            int count = queue.size();

            for(int i = 0;i < count;i++){
                TreeNode node = queue.poll();

                if(node.left != null){
                    queue.offer(node.left);
                }

                if(node.right != null){
                    queue.offer(node.right);
                }
            }
            depth++;
        }
        return depth;
    }
}
```

## [3.4 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

> **递归法**

```java
// 确定递归函数的参数和返回值

public int getCount(TreeNode root){
    // 确定终止条件
    if(root == null){
        return 0;
    }

    // 确定单层递归的逻辑
    return 1 + getCount(root.left) + getCount(root.right);
}
```

> **迭代法**

```java
public int countNodes(TreeNode root) {
        if(root == null){
            return 0;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.offer(root);

        int ans = 0;

        while(!queue.isEmpty()){
            int count = queue.size();
            ans += count;

            for(int i = 0;i < count;i++){
                TreeNode node = queue.poll();

                if(node.left != null){
                    queue.offer(node.left);
                }

                if(node.right != null){
                    queue.offer(node.right);
                }
            }
        }
        return ans;
    }
```


# 四、二叉树的修改与改造

# 五、求二叉搜索树的属性

# 六、二叉树公共祖先问题

# 七、二叉搜索树的修改与改造
