# 一、 二叉树理论基础

## 1.1二叉树的种类

### 1.1.1 满二叉树

- 定义：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。深度为k，有2^k-1个节点的二叉树。

![满二叉树](https://img-blog.csdnimg.cn/20200806185805576.png)


### 1.1.2 完全二叉搜索树

- 定义：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

![完全二叉搜索树](https://img-blog.csdnimg.cn/20200920221638903.png)

- 优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。


### 1.1.3 二叉搜索树

- 二叉搜索树是一个有序树。
  - 若它的左子树不空，则左子树上所有结点的值 < 它的根结点的值；
  - 若它的右子树不空，则右子树上所有结点的值 > 它的根结点的值；
  - 它的左、右子树也分别为二叉排序树

![二叉搜索树](https://img-blog.csdnimg.cn/20200806190304693.png)


### 1.1.4 平衡二叉搜索树(平衡二叉树)

- 定义：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

![平衡二叉树](https://img-blog.csdnimg.cn/20200806190511967.png)


>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，
>注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。
>所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚！

## 1.2 二叉树的存储方式

- 链式存储

![二叉树的链式存储](https://img-blog.csdnimg.cn/2020092019554618.png)

- 顺序存储

![二叉树的顺序存储](https://img-blog.csdnimg.cn/20200920200429452.png)

如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。

## 1.3 二叉树的遍历方式

- 二叉树主要有两种遍历方式：
  - 深度优先遍历：先往深走，遇到叶子节点再往回走  
  - 广度优先遍历：一层一层的去遍历

- 从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：
  - 深度优先遍历
    - 前序遍历（递归法，迭代法）
    - 中序遍历（递归法，迭代法）
    - 后序遍历（递归法，迭代法）
    <center>![二叉树三种遍历方式](https://img-blog.csdnimg.cn/20200806191109896.png)</center>
    
  - 广度优先遍历
    - 层次遍历（迭代法）


## 1.4 二叉树的定义

```java
  public class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
      this.val = val;
    }
    TreeNode(int val, TreeNode left, TreeNode right){
      this.val = val;
      this.left = left;
      this.right = right;
    }
}
```

***

# 二、 二叉树的遍历方式

## 2.1 二叉树的递归遍历

递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

因此可以使用栈实现递归。

- 递归算法的三要素：
  - 确定递归函数的参数和返回值
  - 确定递归的终止条件
  - 确定单层递归的逻辑

- 二叉树的递归遍历
  - [二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
  - [二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
  - [二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

## 2.2 二叉树的迭代遍历

### 2.2.1 前序遍历（迭代法）

> 代码
 
```java
class Solution{

    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = ArrayList<Integer>();

        if(root == null){
          return ans;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();

        stack.add(root);

        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            ans.add(node.val);
            if(node.right != null){
                stack.push(node.right);
            }
            if(node.left != null){
                stack.push(node.left);
            }
        }
        return ans; 
    }
}
```

- 复杂度分析
  - 空间复杂度：${O(n)}$
  - 时间复杂度：${O(n)}$ 

### 2.2.2 中序遍历（迭代法）

> 代码
 
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        Deque<TreeNode> stack = new  LinkedList<TreeNode>();
        if(root == null){
          return ans;
        }
        TreeNode node = root;
        while(node != null || !stack.isEmpty()){
            if(node != null){
                stack.push(node);
                node = node.left;
            }else{
                node = stack.pop();
                ans.add(node.val);
                node = node.right;
                stack.push(node);
            }
        }
        return ans;
    }
}
```

- 复杂度分析
  - 空间复杂度：${O(n)}$
  - 时间复杂度：${O(n)}$ 

### 2.2.3 后序遍历（迭代法）

- 代码

```java
class Solution{
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        if(root == null){
          return ans;
        }
        
        Deque<TreeNode> stack = new LinkedList<TreeNode>();

        stack.push(root);

        while(!stack.isEmpty()){
             TreeNode node = stack.pop();
             ans.add(node.val);
             if(node.left != null){
                stack.push(node.left);
             }
             if(node.right != null){
                stack.push(node.right);
             }
        }
        Collections.reverse(ans);
        return ans;
    }
}
```

- 复杂度分析
  - 空间复杂度：${O(n)}$
  - 时间复杂度：${O(n)}$ 

### 2.2.4 二叉树的统一迭代法

## 2.3 二叉树的层序遍历

### 2.3.1 [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

> **迭代层序遍历**

```java
class Solution{
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();

        if(root == null){
            return ans;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.add(root);

        int i = 1;

        while(!queue.isEmpty()){
            List<Integer> tmp = new ArrayList<Integer>();
            int count = queue.size();
            for(int i = 0;i < count;i++){
                TreeNode node = queue.offer();
                tmp.add(node.val);
                if(node.left != null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
            }

            if(i % 2 == 0){
                i++;
                Collections.reverse(tmp);
            }

            ans.add(new ArrayList<Integer>(tmp));
        }
        return ans;
    }
}
```

### 2.3.2 [二叉树的层序遍历II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

> **递归层序遍历**


```java
/**
    递归层序遍历
 */

 class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        int depth = 0;
        order(root, ans,depth);
        return ans;
    }

    private void order(TreeNode root, List<List<Integer>> ans, int depth){
        if(root == null){
            return;
        }
        depth++;
        if(ans.size() < depth){
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> temp = new ArrayList<Integer>();
            ans.add(temp);
        }
        ans.get(depth - 1).add(root.val);
        order(root.left,ans,depth);
        order(root.right,ans,depth);
    }
 }
```

> **迭代层序遍历**

```java
class Solution{
    public List<List<Integer>>  levelOrderBottom(TreeNode root){
        List<List<Integer>> ans = new ArrayList<List<Integer>>();

        if(root == null){
            return ans;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.add(root);

        int k = 1;

        while(!queue.isEmpty()){
            List<Integer> tmp = new ArrayList<Integer>();
            int count = queue.size();
            for(int i = 0;i < count;i++){
                TreeNode node = queue.poll();
                tmp.add(node.val);
                if(node.left != null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
            }

            ans.add(new ArrayList<Integer>(tmp));
        }

        Collections.reverse(ans);
        return ans;
    }
}
```

### 2.3.3 [二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

> **迭代层序遍历**

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();

        if(root == null){
            return ans;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.add(root);

        int k = 0;

        while(!queue.isEmpty()){
            List<Integer> tmp = new ArrayList<Integer>();
            int count = queue.size();
            for(int i = 0;i < count;i++){
                TreeNode node = queue.poll();
                tmp.add(node.val);
                if(node.left != null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
            }

            if(k % 2 != 0){
                Collections.reverse(tmp);
            }
            k++;

            ans.add(new ArrayList<Integer>(tmp));
        }
        return ans;

    }
}
```

# 三、 二叉树的属性

# 四、二叉树的修改与改造

# 五、求二叉搜索树的属性

# 六、二叉树公共祖先问题

# 七、二叉搜索树的修改与改造
