# 常见数据结构

## 线性数据结构

- 数组
- 链表
- 栈
- 队列

## 图

### 图的基本概念

图就是由顶点的**有穷非空集合和顶点之间的边组成的集合**。通常表示为：G(V,E)，其中，G表示一个图，V表示顶点的集合，E表示边的集合。

- 顶点：图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）
- 边：顶点之间的关系用边表示
- 度：度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。
- 无向图和有向图
- 无权图和有权图

### 图的存储

> **邻接矩阵**

邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。

如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 `A[i][j]=n` 。

- 在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，A[i][j]=1，当顶点i和顶点j没有关系时，A[i][j]=0。如下图所示：

![](https://javaguide.cn/assets/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8.3ba1bccc.png)

无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。

> **邻接表**

- 邻接链表使用一个**链表**来**存储某个顶点的所有后继相邻顶点**。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 邻接表。

![](https://javaguide.cn/assets/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8.2869ec57.png)

![](https://javaguide.cn/assets/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8.362b00d5.png)


### 图的搜索

> **广度优先搜索**

广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：

![](https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%9B%BE%E7%A4%BA.4f9122d2.png)

广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列 。

**第1步：**

![广度优先搜索1](./pictures/图/广度优先搜索1.png)

**第2步：**

![广度优先搜索2](./pictures/图/广度优先搜索2.png)

**第3步：**

![广度优先搜索3](./pictures/图/广度优先搜索3.png)

**第4步：**

![广度优先搜索4](./pictures/图/广度优先搜索4.png)

**第5步：**

![广度优先搜索5](./pictures/图/广度优先搜索5.png)

**第6步：**

![广度优先搜索6](./pictures/图/广度优先搜索6.png)

> **深度优先搜索**

深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：

![](https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%9B%BE%E7%A4%BA.a5e0d06f.png)

和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈 :

**第1步：**

![深度优先搜索1](./pictures/图/深度优先搜索1.png)

**第2步：**

![深度优先搜索1](./pictures/图/深度优先搜索2.png)

**第3步：**

![深度优先搜索1](./pictures/图/深度优先搜索3.png)

**第4步：**

![深度优先搜索1](./pictures/图/深度优先搜索4.png)

**第5步：**

![深度优先搜索1](./pictures/图/深度优先搜索5.png)

**第6步：**

![深度优先搜索1](./pictures/图/深度优先搜索6.png)

## 堆

### 堆的定义与分类

堆是满足任意一个节点的值都大于等于（或小于等于）所有子节点的值这一条件的树

> **堆的分类**

- 大顶堆 ：堆中的每一个节点的值都大于等于子树中所有节点的值
- 小顶堆 ：堆中的每一个节点的值都小于等于子树中所有节点的值

### 堆的用途

**相对于有序数组而言，堆的主要优势在于更新数据效率较高。** 堆的初始化时间复杂度为 O(nlog(n))，堆可以做到O(1)时间复杂度取出最大值或者最小值，O(log(n))时间复杂度插入或者删除数据

### 堆的存储

### 堆的操作

- 插入元素 ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮
- 删除堆顶元素 ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。

### 堆排序

- 第一步是建堆，将一个无序的数组建立为一个堆
- 第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。

## 树

## 二叉树的分类

> 满二叉树

> 完全二叉树

> **平衡二叉树**
平衡二叉树 **是一棵二叉排序树**，且具有以下性质：

1. 可以是一棵空树
2. 如果不是空树，它的**左右两个子树的高度差的绝对值不超过 1**，并且左右两个子树都是一棵平衡二叉树。

平衡二叉树的常用实现方法有 红黑树、AVL 树、替罪羊树、加权平衡树、伸展树 等。

## 二叉树的存储

> 链式存储

> 顺序存储

## 二叉树的遍历

> 先序遍历
> 中序遍历
> 后序遍历

## 红黑树

红黑树的特点:

1. 每个节点非红即黑
2. 根节点总是黑色的
3. 每个叶子节点都是黑色的空节点
4. 如果节点是红色的，它的字节点必须是黑色的，反之则不一定
5. 从根节点到字节点必须包含相同数目的黑色节点。 

红黑树的应用 ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。

> **红黑树的旋转操作**

旋转操作(Rotate)的**目的是使节点颜色符合定义**，让RBTree的高度达到平衡。
Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。

![](https://pic2.zhimg.com/80/v2-b22d2a98bb0ab3b2dc08316577221e61_1440w.png)
