# 二、数组和链表

## 2.1 概述

数组/链表代表着计算机最基本的两种存储形式：**顺序存储和链式存储**，所以他俩可以算是最基本的数据结构。

链表涉及到主要的算法技巧:

- 双指针

数组涉及到的主要计算技巧

- 双指针
  - 中间向两端扩散的双指针（寻找回文子串）
  - 两端向中间收缩的双指针（二分查找、判断是否为回文子串）
  - 快慢指针（滑动窗口）
- 前缀和
- 差分数组

## 2.1 数组前缀数组

前缀和技巧适⽤于快速、频繁地**计算⼀个索引区间内的元素之和**。

### 2.1.1 一维数组的前缀和

> **例题描述**

[⼒扣第 303 题 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/description/)

sumRange 函数需要计算并返回⼀个索引区间之内的元素和，即计算闭区间 [left, right] 的累加和

> **暴力求解**

```java
class NumArray {

    private int[] nums;

    public NumArray(int[] nums) {
        this.nums = nums;

    }
    
    public int sumRange(int left, int right) {
        int ans = 0;

        for(int i = 0;i <= right;i++){
            if(i >= left){
                ans += nums[i];
            }
        }
        return ans;
    }
}
```

缺点: 时间复杂度为 ${O(N)}$，其中N为nums数组的长度

> **前缀和数组**

核⼼思路是我们 new ⼀个新的数组 preSum 出来，preSum[i] 记录 nums[0..i-1] 的累加和.

看这个 preSum 数组，如果我想求索引区间 [1, 4] 内的所有元素之和，就可以通过 ${preSum[5] - preSum[1]}$ 得出。

这样，sumRange 函数仅仅需要做⼀次减法运算，避免了每次进⾏ for 循环调⽤，**最坏时间复杂度**为常数 ${O(1)}$。

```java
class NumArray {

    private int[] nums;
    private int[] preSum;

    public NumArray(int[] nums) {
        this.nums = nums;
        preSum = new int[nums.length + 1];
        for(int i = 1;i < preSum.length;i++){
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
    }
    
    public int sumRange(int left, int right) {
        int ans = preSum[right + 1] - preSum[left];
        return ans;
    }
}
```

### 2.1.2 二维矩阵的前缀和

> **例题描述**

[LeetCode-304:⼆维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。

> **二维数组前缀和**

- 二维数组前缀和计算

![](https://img-blog.csdnimg.cn/img_convert/3004d0cf07f611ac2f72248056338dfc.png)

```java
s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]
```

- 利用二维数组前缀和计算区域和

![](https://img-blog.csdnimg.cn/img_convert/96a7903dc9223d5ee71aab49f3be5de6.png)

```java
s[x2, y2] - s[x1, y2] - s[x2, y1] + s[x1, y1]
```

sumRegion 函数的时间复杂度也⽤前缀和技巧优化到了 O(1)，这是典型的「空间换时间」思路。

```java
class NumMatrix {

    private int[][] matrix;
    private int[][] preSum;

    public NumMatrix(int[][] matrix) {
        this.matrix = matrix;
        int m = matrix.length;
        int n = matrix[0].length;
        preSum = new int[m + 1][n + 1];

        for(int i = 1;i < m + 1;i++){
            for(int j = 1;j < n + 1;j++){
                preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1] ;
            }
        }

    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        int ans = 0;
        ans = preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1];
        return ans;
    }
```

## 2.2 数组差分数组

## 2.3 数组-双指针

## 2.4 数组-滑动窗口（快慢指针）

## 2.5 数组-二分查找（两端向中间收缩的双指针）

## 2.6 链表-双指针

## 2.7 链表-递归思想