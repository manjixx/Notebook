# 二、数组和链表

## 2.1 概述

数组/链表代表着计算机最基本的两种存储形式：**顺序存储和链式存储**，所以他俩可以算是最基本的数据结构。

链表涉及到主要的算法技巧:

- 双指针

数组涉及到的主要计算技巧

- 双指针
  - 中间向两端扩散的双指针（寻找回文子串）
  - 两端向中间收缩的双指针（二分查找、判断是否为回文子串）
  - 快慢指针（滑动窗口）
- 前缀和
- 差分数组

## 2.1 数组前缀数组

前缀和技巧适⽤于快速、频繁地**计算⼀个索引区间内的元素之和**。

### 2.1.1 一维数组的前缀和

> **例题描述**

[⼒扣第 303 题 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/description/)

sumRange 函数需要计算并返回⼀个索引区间之内的元素和，即计算闭区间 [left, right] 的累加和

> **暴力求解**

```java
class NumArray {

    private int[] nums;

    public NumArray(int[] nums) {
        this.nums = nums;

    }
    
    public int sumRange(int left, int right) {
        int ans = 0;

        for(int i = 0;i <= right;i++){
            if(i >= left){
                ans += nums[i];
            }
        }
        return ans;
    }
}
```

缺点: 时间复杂度为 ${O(N)}$，其中N为nums数组的长度

> **前缀和数组**

核⼼思路是我们 new ⼀个新的数组 preSum 出来，preSum[i] 记录 nums[0..i-1] 的累加和.

看这个 preSum 数组，如果我想求索引区间 [1, 4] 内的所有元素之和，就可以通过 ${preSum[5] - preSum[1]}$ 得出。

这样，sumRange 函数仅仅需要做⼀次减法运算，避免了每次进⾏ for 循环调⽤，**最坏时间复杂度**为常数 ${O(1)}$。

```java
class NumArray {

    private int[] nums;
    private int[] preSum;

    public NumArray(int[] nums) {
        this.nums = nums;
        preSum = new int[nums.length + 1];
        for(int i = 1;i < preSum.length;i++){
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
    }
    
    public int sumRange(int left, int right) {
        int ans = preSum[right + 1] - preSum[left];
        return ans;
    }
}
```

### 2.1.2 二维矩阵的前缀和

> **例题描述**

[LeetCode-304:⼆维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。

> **二维数组前缀和**

- 二维数组前缀和计算

![](https://img-blog.csdnimg.cn/img_convert/3004d0cf07f611ac2f72248056338dfc.png)

```java
s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]
```

如果定义s为 m + 1 * n + 1 维数组则：

```java
s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i - 1][j - 1]
```

- 利用二维数组前缀和计算区域和

![](https://img-blog.csdnimg.cn/img_convert/96a7903dc9223d5ee71aab49f3be5de6.png)

```java
s[x2, y2] - s[x1, y2] - s[x2, y1] + s[x1, y1]
```

sumRegion 函数的时间复杂度也⽤前缀和技巧优化到了 O(1)，这是典型的「空间换时间」思路。

```java
class NumMatrix {

    private int[][] matrix;
    private int[][] preSum;

    public NumMatrix(int[][] matrix) {
        this.matrix = matrix;
        int m = matrix.length;
        int n = matrix[0].length;
        preSum = new int[m + 1][n + 1];

        for(int i = 1;i < m + 1;i++){
            for(int j = 1;j < n + 1;j++){
                preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1] ;
            }
        }

    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        int ans = 0;
        // 如果定义 m + 1 * n + 1维 前缀和数组 那么涉及到 row2 与 col2的均需 + 1 row1 与col1 均不加
        ans = preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1];
        return ans;
    }
```

***

## 2.2 数组差分数组

差分数组的主要适⽤场景是**频繁对原始数组的某个区间的元素进⾏增减**。

> **题目**

给你输⼊⼀个数组 nums，然后⼜要求给区间 ${nums[2..6]}$ 全部加 1，再给 ${nums[3..9]}$ 全部减3，再给 ${nums[0..4]}$ 全部加 2，再给...

> **传统方法**

利用`for循环`逐给范围内数字`加\减val`,这种思路的时间复杂度是${O(N)}$，由于这个场景下对 nums 的修改⾮常频繁，所以效率会很低下。

> **差分数组**


利用差分数组技巧，diff[i] 就是 nums[i] 和 nums[i-1] 之差。 **通过差分数组是可以反推出原始数组nums**

```java
/*构建差分数组 */

int[] diff = new int[nums.length];

diff[0] = nums[0];

for(int i = 1;i < nums.length;i++){
    diff[i] = nums[i] - nums[i - 1];
}

/* 利用差分数组diff 还原原始数组 */

int[] res = new int[diff.length];
res[0] = diff[0];

for(int i = 1;i < n;i++){
    res[i] = diff[i] + res[i - 1];
}
```

构造差分数组 `diff`，就可以快速进⾏区间增减的操作，如果你想对区间 `nums[i..j]`的元素全部加3，那么只需要让 `diff[i] += 3`，然后再让 `diff[j+1] -= 3` 即可

原理很简单，在 `diff` 数组反推 `nums` 数组的过程，`diff[i] += 3` 意味着给 `nums[i..]` 所有的元素都加了 3，然后 `diff[j+1] -= 3` ⼜意味着对于 `nums[j+1..]` 所有元素再减 3，那综合起来，就是对nums[i..j] 中的所有元素都加 3 了

上述操作只要花费 ${O(1)}$ 的时间修改 `diff` 数组，就相当于给 `nums` 的整个区间做了修改。即通过修改 `diff`，然后通过`diff` 数组反推，即可得到 `nums` 修改后的结果。

**将差分数组抽象为一个工具类:**

```java
class Difference{
    // 差分数组
    private int[] diff;

    /* 输⼊⼀个初始数组，区间操作将在这个数组上进⾏ */
    public Difference(int[] nums) {
       assert nums.length > 0;
        diff = new int[nums.length];
        // 根据初始数组构造差分数组
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        } 
    }

    /* 给闭区间 [i ,j]增加 val，val可以是负数 */
    public void increment(int i, int j, int val) { 
        diff[i] += val;
        if(j + 1 < diff.length - 1){
            diff[j + 1] -= val;
        }
    }

    /* 返回结果数组 */
    public int[] result() {
        int[] res = new int[diff.length];
        // 根据差分数组构造结果数组
        res[0] = diff[0];

        for(int i = 1;i < diff.length;i++){
            res[i] = res[i - 1] + diff[i];
        }

        return res;
    }

}
```

## 2.3 数组-双指针

## 2.4 数组-滑动窗口（快慢指针）

## 2.5 数组-二分查找（两端向中间收缩的双指针）

## 2.6 链表-双指针

## 2.7 链表-递归思想

***

## 2.8 课后习题

### 2.8.1 前缀和习题

- [x] [1314.矩阵区域和](https://leetcode.cn/problems/matrix-block-sum/?show=1)
- [x] [1352.最后 K 个数的乘积](https://leetcode.cn/problems/product-of-the-last-k-numbers/?show=1)
- [x] [238.除⾃身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/?show=1)
- [ ] [327. 区间和的个数](https://leetcode.cn/problems/count-of-range-sum/?show=1)
- [ ] [437. 路径总和](https://leetcode.cn/problems/path-sum-iii/?show=1)
- [ ] [523.连续的⼦数组和](https://leetcode.cn/problems/continuous-subarray-sum/?show=1)
- [ ] [525. 连续数组](https://leetcode.cn/problems/contiguous-array/?show=1)
- [ ] [560. 和为 K 的⼦数组](https://leetcode.cn/problems/subarray-sum-equals-k/?show=1)
- [ ] [724. 寻找数组的中⼼下标](https://leetcode.cn/problems/find-pivot-index/?show=1)
- [ ] [862. 和⾄少为 K 的最短⼦数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/?show=1)
- [ ] [918. 环形⼦数组的最⼤和](https://leetcode.cn/problems/maximum-sum-circular-subarray/?show=1)
- [ ] [974. 和可被 K 整除的⼦数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/?show=1)
- [ ] [剑指 Offer II 010. 和为 k 的⼦数组](https://leetcode.cn/problems/QTMn0o/?show=1))
- [ ] [剑指 Offer II 011. 0 和 1 个数相同的⼦数组](https://leetcode.cn/problems/A1NYOS/?show=1)
- [ ] [剑指 Offer II 012. 左右两边⼦数组的和相等](https://leetcode.cn/problems/tvdfij/?show=1)
- [x] [剑指 Offer II 013. ⼆维⼦矩阵的和](https://leetcode.cn/problems/O4NDxx/?show=1)
- [ ] [剑指 Offer II 050. 向下的路径节点之和](https://leetcode.cn/problems/6eUYwP/?show=1)
- [ ] [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/?show=1)
- [x] [剑指 Offer 66. 构建乘积数组](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/)

### 2.8.2 差分数组习题

- [ ] [370 区间加法 🟠 🔒](https://leetcode.cn/problems/range-addition/)
- [x] [1094. 拼车 🟠](https://leetcode.cn/problems/car-pooling/)
- [ ] [1109. 航班预订统计 🟠](https://leetcode.cn/problems/corporate-flight-bookings/)
- [x] [1450. 在既定时间做作业的学生人数 🟢](https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/description/)
- [ ] [846. 一手顺子 🟠](https://leetcode.cn/problems/hand-of-straights/description/)
