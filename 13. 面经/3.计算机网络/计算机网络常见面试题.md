# 计算机网络常见面试题总结

## 一、计算机网络基础

### 1.1 OSI 七层模型是什么？每一层的作用是什么？

- 应用层:为计算机用户提供服务
- 表示层:数据处理(编解码、加密解密、压缩解压缩)
- 会话层:管理(建立、维护)应用程序之间的会话
- 传输层:为两台主机进程间通信提供服务
- 网络层:路由和寻址，解决分组在多个网络(路由上传输的问题
- 数据链路层:解决分组在一个网络上传输的问题
- 物理层:解决使用何种信号传输比特的问题

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/osi-model-detail.png)

### 1.2 TCP/IP 四层模型是什么？每一层的作用是什么？

- **应用层**:供两个终端设备上的**应用程序之间信息交换的服务**，它定义了信息交换的格式，消息会交给下一层传输层来传输。
- 传输层:负责向**两台终端设备进程之间**的通信提供通用的数据传输服务
- 网络层:解决分组**在多个网络上传输(路由)的问题**
- 网络接口层：
  - 数据链路层:解决分组在一个网络上或一段链路上的传输问题
  - 物理层:解决使用何种信号传输比特的问题

### 1.3 TCP/IP四层模型中，每一层包含的协议与核心技术

> **应用层**

- HTTP 协议（超文本传输协议，网页浏览常用的协议）
- DHCP 协议（动态主机配置）
- DNS 系统原理（域名系统）
- FTP 协议（文件传输协议）
- Telnet协议（远程登陆协议）
- 电子邮件协议等（SMTP、POP3、IMAP）

> **传输层**

- TCP协议
- UDP协议

> **网络层**

- IP协议(TCP/IP 协议的基础，分为 IPv4 和 IPv6）)
- ARP协议(地址解析协议，用于解析 IP 地址和 MAC 地址之间的映射)
- ICMP协议(控制报文协议，用于发送控制消息)
- NAT协议(网络地址转换协议)
- RIP 协议、OSPF 协议、BGP 协议（路由选择协议）

> **网络接口层**

- 差错检测技术
- 多路访问协议（信道复用技术）
- CSMA/CD 协议
- MAC 协议
- 以太网技术

### 1.4 为什么网络要分层？

- 各层之间相互独立，不用考虑其他层是如何实现的。
- 提高了整体的灵活性
- 分层将复杂的网络问题分解为许多较小的、界线比较清晰的局部问题来处理与解决，使得网络变得易于设计、实现与标准化

### 1.5 应用层常见协议有哪些？

#### 1.5.1 HTTP:超文本传输协议

**超文本传输协议（HTTP，HyperText Transfer Protocol)** 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/450px-HTTP-Header.png)

HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。

另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。

#### 1.5.2 SMTP:简单邮件传输(发送)协议

**简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）** 基于 TCP 协议，用来发送电子邮件。

![SMTP 协议](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/what-is-smtp.png)

注意⚠️：**接受邮件的协议不是 SMTP 而是 POP3 协议。**

SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：

1. 电子邮件的发送过程
2. 如何判断邮箱是真正存在的？

**电子邮件的发送过程？**

比如我的邮箱是“dabai@cszhinan.com”，我要向“xiaoma@qq.com”发送邮件，整个过程可以简单分为下面几步：

1. 通过 **SMTP**  协议，我将我写好的邮件交给163邮箱服务器（邮局）。
2. 163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。
3. qq邮箱服务器接收邮件之后就通知邮箱为“xiaoma@qq.com”的用户来收邮件，然后用户就通过 **POP3/IMAP** 协议将邮件取出。

**如何判断邮箱是真正存在的？**

很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：

1. 查找邮箱域名对应的  SMTP 服务器地址
2. 尝试与服务器建立连接
3. 连接成功后尝试向需要验证的邮箱发送邮件
4. 根据返回结果判定邮箱地址的真实性

推荐几个在线邮箱是否有效检测工具：

1. https://verify-email.org/
2. http://tool.chacuo.net/mailverify
3. https://www.emailcamel.com/

#### 1.5.3 POP3/IMAP:邮件接收的协议

这两个协议没必要多做阐述，只需要了解 **POP3 和 IMAP 两者都是负责邮件接收的协议**即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。**SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3/IMAP。**  

IMAP 协议相比于POP3更新一点，为用户提供的可选功能也更多一点,几乎所有现代电子邮件客户端和服务器都支持IMAP。大部分网络邮件服务提供商都支持POP3和IMAP。

#### 1.5.4 FTP:文件传输协议

**FTP 协议** 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。

FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：

> FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：
>
> 1. 控制连接：用于传送控制信息（命令和响应）
> 2. 数据连接：用于数据传送；
>
> 这种将命令和数据分开传送的思想大大提高了 FTP 的效率。

![FTP工作过程](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/ftp.png)

#### 1.5.5 Telnet:远程登陆协议

**Telnet 协议** 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。

#### 1.5.6 SSH:安全的网络传输协议

**SSH（ Secure Shell）** 是目前较可靠，**专为远程登录会话和其他网络服务提供安全性的协议**。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH  建立在可靠的传输协议 TCP 之上。

**Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。**

![TCP和UDP](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/TCP%E5%92%8CUDP.png)

## 二、HTTP 与 HTTPS

### 2.1 从输入URL 到页面展示到底发生了什么？（非常重要）

- 浏览器根据输入域名进行DNS域名解析获取域名对应的IP地址
- 建立TCP连接
- 发送HTTP请求
- 服务器处理HTTP请求，并返回响应报文
- 浏览器开始显示HTML

![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg)

请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议

### 2.2 HTTP状态码有哪些

- 1xx:信息性状态码，表示接收的请求正在处理
- 2xx:成功信息状态码，表示请求正常处理完毕
- 3xx:重定向状态码,需要进行附加操作完成请求
- 4xx:客户端错误状态码，服务器无法处理请求
- 5xx:服务器错误状态码，服务器处理请求出错

> **1xx Informational（信息性状态码）**

相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。

> **2xx Success（成功状态码）**

- 200 OK ：请求被成功处理。比如我们发送一个查询用户数据的HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。
- 201 Created ：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。
- 202 Accepted ：服务端已经接收到了请求，但是还未处理。
- 204 No Content ： 服务端已经成功处理了请求，但是没有返回任何内容。

> **3xx Redirection（重定向状态码）**

- 301 Moved Permanently ： 资源被永久重定向了。比如你的网站的网址更换了。
- 302 Found ：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。

> **4xx Client Error（客户端错误状态码）**

- 400 Bad Request ： 发送的HTTP请求存在问题。比如请求参数不合法、请求方法错误。
- 401 Unauthorized ： 未认证却请求需要认证之后才能访问的资源。
- 403 Forbidden ：直接拒绝HTTP请求，不处理。一般用来针对非法请求。
- 404 Not Found ： 你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。
- 409 Conflict ： 表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。

> **5xx Server Error（服务端错误状态码）**

- 500 Internal Server Error ： 服务端出问题了（通常是服务端出Bug了）。比如你服务端处理请求的时候突然抛出异常，但是异常并为在服务端被正确处理。
- 502 Bad Gateway ：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。

### 2.3 HTTP与HTTPS的区别

1. **安全性**：HTTP 是超文本传输协议，**信息是明文传输**，存在安全风险的问题。**HTTPS 则解决 HTTP 不安全的缺陷**，在 TCP 和 HTTP 网络层之间加入了 **SSL/TLS 安全协议**，使得报文能够加密传输。
2. **建立连接**： HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
3. **端口号**：HTTP 的端口号是 80，HTTPS 的端口号是 443。
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

HTTPS通过信息加密，校验机制、身份证书解决了HTTP传输的篡改风险、窃听、冒充风险。

### 2.4 HTTP 1.0和HTTP 1.1 的区别

- **连接方式**:HTTP 1.0 为短连接，HTTP 1.1 支持长连接。
- **状态响应码**:HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。
- **缓存机制**: HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略
- **带宽优化与网络连接的使用**:HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- **Host头处理**:HTTP/1.1在请求头中加入了Host字段。

### 2.5 HTTP是无状态协议, 如何保存用户状态?

通过引入Session机制，在服务端记录用户状态。服务器给特定用户创建特定的Session之后就可以标识这个用户并且跟踪这个用户。

Session存放在服务端，而实现Session跟踪一般是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

如果Cookie 被禁用怎么办：最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。

### 2.6 URI与URL的区别

- URI(Uniform Resource Indentifier)：统一资源标志符，可以标识唯一资源，URI作用更像身份证号
- URL(Uniform Resource Locator):统一资源定位符，可以提供该资源的路径，是一种具体的URI，即URL可以标识一个资源，还提供如何定位该资源。

## 三、TCP与UDP

### 3.1 TCP与UDP的区别

> **概述**

- TCP面向连接的可靠的字节流传输
- UDP无连接的不可靠的报文传输

> **区别**

- **是否面向连接**:UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。
- **是否为可靠传输**:远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达
- **是否有状态**:这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了
- **传输效率**:TCP 的传输效率要比 UDP 低很多。
- **传输形式**:TCP 是面向字节流的，UDP 是面向报文的。
- **首部开销**:TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。
- **是否支持广播或者多播服务**:TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；
  
### 3.2 什么时候选择 TCP,什么时候选 UDP?

- **UDP 一般用于即时通信**，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。
- **TCP 用于对传输准确性要求特别高的场景**，比如文件传输、发送和接收邮件、远程登录等等。

### 3.3 HTTP 基于 TCP 还是 UDP？

HTTP 协议是基于 TCP 协议的，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。

### 3.4 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?

> **运行在TCP协议之上的协议**

- **HTTP 协议** ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。
- **HTTPS 协议** ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议
- **FTP 协议**：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。
- **SMTP 协议**：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，基于 TCP 协议，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。
- **POP3/IMAP 协议**： POP3 和 IMAP 两者都是负责邮件接收的协议。
- **Telent 协议**：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。
- **SSH 协议** : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上

> **运行于 UDP 协议之上的协议**

- DHCP协议:动态配置IP地址
- DNS:域名系统解析协议

### 3.3 TCP三次握手

> **三次握手过程**

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png)

- 第一次握手:客户端发送SYN(SEQ = x)标志的数据包到服务端，然后进入SYN_SEND状态等待服务器确认
- 第二次握手:服务端发送带有SYN+ACK(SEQ = y,ACK = x+ 1)标识的数据包到服务端，然后服务端进入SYN_RECV状态
- 第三次握手:客户端发送带有ACK(ack = y + 1)标识的数据包到服务端，然后客户端和服务端都进入ESTABLISH状态，完成三次握手

> **为什么要三次握手**

三次握手的目的是建立可靠的通信信道，**双方确认自己与对方的发送与接收是正常的。**

- 第一次握手 ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
- 第二次握手 ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
- 第三次握手 ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

### 3.4 TCP四次挥手

> **四次回收过程**

- 第一次挥手：客户端发送一个FIN(SEQ = x)标志的数据包到服务端，来关闭客户端到服务端的数据传送.客户端进入FIN-WAIT-1状态
- 第二次挥手:服务器收到FIN标志数据包，发送一个ACK(SEQ = x)标志的数据包到客户端，然后进入COLSE-WAIT状态，客户端进入FIN-WAIT-2状态
- 第三次挥手:服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-到客户端请求关闭连接，然后，服务端进入LAST-ACK状态。
- 第四次挥手:客户端发送 ACK (SEQ=y+1)标志的数据包到服务端，进入TIME-WAIT状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。

客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。

> **为什么要四次挥手**

TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

> **为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？**

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。

等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。

> **如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？**

客户端没有收到 ACK 确认，会重新发送 FIN 请求。

> **第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？**

第四次挥手，客户端发送给服务器的ACK可能丢失，如果服务器因为某些原因没收到ACK的话，服务端就会重发FIN，如果客户端在2*MSL的时间内收到了FIN,就会重新发送ACK并再次等待2MSL,防止Sever没有收到ACK而反复重发FIN。

MSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。

### 3.5 TCP传输可靠性保障

TCP通过重传机制、滑动窗口、流量控制、拥塞避免来保证可靠传输

- 重传机制:超时重传、快重传、SACK、D-SACK
- 滑动窗口:发送窗口、接收窗口
- 流量控制
- 拥塞控制:慢启动、拥塞避免、拥塞发生、快恢复
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

> **TCP如何实现流量控制**

TCP **利用滑动窗口实现流量控制**。流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 为全双工(Full-Duplex, FDX)通信，两端**各有一个发送缓冲区与接收缓冲区**，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。

**TCP 发送窗口可以划分成四个部分**

- 已经发送并且确认的TCP段
- 已经发送未确认的TCP段
- 未发送但接受方准备接受的TCP段
- 未发送且接受方未准备接收的TCP段
  
![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-send-window.png)

**TCP 接收窗口可分为三个段**

- 已经接收且确认的TCP段
- 等待接收且允许发送方发送的TCP段
- 不可接收且不允许发送的TCP段

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-receive-window.png)

接收窗口的大小是根据接收端处理数据的速度动态调整的。 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。

> **TCP 拥塞控制的实现**

TCP拥塞控制采用了四种算法:慢启动、拥塞避免、快重传和快恢复

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

- **慢开始:** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，较好的方法是先探测一下。即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。
- **拥塞避免:** 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即**每经过一个往返时间 RTT** 就把发送放的 cwnd 加 1.
- **快重传与快恢复:** 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。
  - **快速重传算法**：当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。
  - **快速恢复:** 快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以进入快速恢复之前，cwnd 和 ssthresh 已被更新了：cwnd = cwnd/2 ，也就是设置为原来的一半;慢启动门限ssthresh = cwnd;

> **ARQ停止等待协议**

**自动重传请求**（Automatic Repeat-reQuest，ARQ）是 OSI 模型中**数据链路层和传输层的错误纠正协议之一**。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。

- **停止等待ARQ协议**

停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组

- **连续ARQ协议**

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

## 四、ARP协议

ARP 协议，全称 地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。ARP 协议解决了 IP 地址转 MAC 地址的一些问题。