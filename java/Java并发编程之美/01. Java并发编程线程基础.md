# 1. 什么是线程

- 进程：系统进行资源分配和调度的基本单位

- 线程：CPU分配的基本单位

- 进程与线程的关系

  - 启动主函数main时，就启动了一个JVM进程，而main函数所在的线程就是改进程中的一个线程，称之为主线程
  
  ![进程与线程的关系](https://img-blog.csdnimg.cn/img_convert/c68cd7582cd963c4af5d400b115efaa5.png)
  
  - 一个进程中有多个线程，多个线程共享进程的堆和方法区资源，每个线程有自己的程序计数器和栈区域
  
  - 程序计数器：记录该线程让出CPU时的执行地址的，待再次分配到时间片时线程就可以从自己私有的计数器指定地址继续执行，注意如果执行的是native方法，pc计数器记录的是undefined地址，只有执行java代码时pc计数器才记录下一条指令地址
  
  - 栈：存储线程的局部变量，是线程私有的，此外栈还用来存放线程的调用栈帧
  
  - 堆：所有线程共享，在进程创建时分配，主要存放使用new操作创建的对象实例
  
  - 方法区：线程共享，存放JVM加载的类、常量及静态变量等信息

# 2. 线程创建与运行

- Java中有三种线程创建方式
  
  - 实现Runnable接口的run方法

  - 继承Thread类并重写run的方法

  - 使用FutureTask方式

## 继承Thread类方法
- 调用start方法后线程并未马上处于执行而是处于就绪状态，就绪状态是指该程序已经获取了除CPU以外的其他资源，等待获取CPU资源后才会真正启动了线程

- 优点：在run()方法内获取当前线程直接使用this就可以，无需使用Thread.currentThread()方法；

- 缺点：Java不支持多继承，如果继承了Thread类，就没办法继承其他类。其次任务与代码没有分离，当多个线程执行一样的任务需要多份任务代码，而Runnable则没有该限制

```java
public class ThreadTest{
  // 继承Thread类并重写run方法
  public static class MyThread extends Thread{
    @ Override
    public void run(){
      System.out.println("I am a child thread");
    }
  }
  
  public static void main(String[] args){
    
    // 创建线程
    MyThread thread = new MyThread();
    
    // 启动线程
    thread.start();
  }
}
```

## 实现Runable接口的run方法

```java
public static class RunableTask implements Runable{
  @Override
  public void run(){
    System.out.println("I am a child thread");
  }
}

public static void main(String[] args) throws InterruptedException{
  RunnableTask task = new RunableTask();
  
  new Thread(task).start();
  new Thread(task).start();
}
```

- 如代码所示，两个线程共用一个task代码逻辑，如果需要可以给RunableTask添加参数进行任务区分。此外RunableTask可以继承其他类
- 缺点：没有返回值

## FutureTask的方式

```java
// 创建任务类，类似Runable

public static class CallerTask implements Callable<String>{
  
  @Override
  public String call() throws Exception{
    return "hello";
  }
}

public static void main(String[] args) throws InterruptedException{
  //创建异步任务
  FutureTask<String> futureTask = new FutureTask(new CallerTask());
  
  // 启动线程
  new Thread(futureTaks).start();
  
  try{
    // 等待任务执行完毕，并返回结果
    String result = futureTask.get();
    System.out.println(result);
  } catch(ExecutionException e){
    e.printStackTrace();
  }
}
```

## 小结
- 使用继承方式是方便传参，可以在子类中添加成员变量，通过set方法设置参数或者通过构造函数进行传递
- 如果使用Runable方式，则只能使用主线程里被声明为final的变量，不好的地方是java不支持多继承，如果继承了Thread类不能再继承其他类，而Runable没有这个限制。
- 前两种方式都没办法拿回任务结果，但FutureTask可以


# 3. 线程等待与通知

# 4. 等待线程执行终止的join方法

# 5. 让线程睡眠的sleep方法

# 6. 让CPU交出执行权的yield方法

# 7. 线程中断

# 8. 理解线程上下文切换

# 9. 线程死锁

# 10. 守护线程与用户线程

# 11. ThreadLocal
